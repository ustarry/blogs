<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>探索Windows：Windows内存结构体系</title>
      <link href="/blogs/posts/windows/pd2a35742938d.html"/>
      <url>/blogs/posts/windows/pd2a35742938d.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：同步设备IO与异步设备IO</title>
      <link href="/blogs/posts/windows/pf26a423cf526.html"/>
      <url>/blogs/posts/windows/pf26a423cf526.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：线程同步</title>
      <link href="/blogs/posts/windows/p8acaa0787154.html"/>
      <url>/blogs/posts/windows/p8acaa0787154.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><p>通常，线程之间需要进行通信，而通信时很可能就会导致数据混乱的现象。就好比一个人正在读书时，另一个人正在修改书中文字。这样书的内容将乱七八糟。对于多个线程同时访问一个共享资源，或一个线程需要通知其他线程某任务已经完成时，需要用到线程同步。Microsoft已提供了很多基础设施，使得线程同步很容易。</p><h2 id="用户模式下的线程同步"><a href="#用户模式下的线程同步" class="headerlink" title="用户模式下的线程同步"></a>用户模式下的线程同步</h2><p>我们可以有多种方式实现线程同步</p><h3 id="使用原子锁"><a href="#使用原子锁" class="headerlink" title="使用原子锁"></a>使用原子锁</h3><p>线程同步的一大部分与原子访问有关(atomic access)有关。</p><h2 id="内核对象进行线程同步"><a href="#内核对象进行线程同步" class="headerlink" title="内核对象进行线程同步"></a>内核对象进行线程同步</h2>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：探索Windows内核对象线程</title>
      <link href="/blogs/posts/windows/pbdbc280bfc62.html"/>
      <url>/blogs/posts/windows/pbdbc280bfc62.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="线程的创建时机"><a href="#线程的创建时机" class="headerlink" title="线程的创建时机"></a>线程的创建时机</h2><p>之前的探索过程中，我们知道，每个进程至少都有一个线程。进程有两个组成部分：一个进程内核对象和一个地址空间。类似地，线程也有两个组成成分</p><ul><li><p>线程内核对象：操作系统用它管理线程</p></li><li><p>线程栈：用于维护线程执行时所需的所有函数参数和局部变量</p></li></ul><p>进程是有惰性的，进程从来不执行任何东西，他只是一个线程的容器。线程共享同一个地址空间，执行同样代码，处理相同数据，此外，这些线程还共享对象句柄。</p><p>因此，进程相对于线程使用的系统资源更多。<strong>原因在于为一个进程创建一个虚拟的地址空间需要大量系统资源，系统发生大量记录活动，占用大量内存。线程几乎不涉及记录活动，所以不需要占用多少内存。</strong></p><p>每个计算机都有强大的资源CPU。让CPU闲着是没有任何道理的（假设不考虑省电和散热等问题）。为了让CPU保持“忙碌”，我们可以让他执行多个任务。下面有多个案例：</p><ul><li><p>Windows Indexing Services(Windows索引服务)创建了一个低优先级的线程，此线程定期醒来，并对硬盘上的特定资源的文件内容进行索引，这极大改进了性能。</p></li><li><p>只要暂停输入，Microsoft Visual Studio自动编译C#和Microsoft Visual Basic .NET源代码文件。（星光探索者都心动地想学C#了）</p></li><li><p>Web浏览器在后台与服务器进行通信，在当前网站结果出来前，用户可以调整浏览器窗口大小，转到其它网站</p></li></ul><p><strong>多线程简化了应用程序的用户界面设计</strong>。多线程应用程序有很多好处。当然并不是任何问题都可以分解成线程解决。</p><p>通常，应用程序有一个UI线程，此线程负责创建窗口，其他线程都是工作线程，用于工作，绝对不会创建窗口。例如网易的<a href="https://gitee.com/setoutsoft/NIM_Duilib_Framework">NIM_Duilib_Framework: 网易云信Windows应用界面开发框架（基于Duilib）</a>就使用了类似的思想。并且UI线程优先级高于工作线程，这样一来，用户界面才能迅速响应用户操作。</p><h2 id="线程的运行"><a href="#线程的运行" class="headerlink" title="线程的运行"></a>线程的运行</h2><p>每个线程都必须有一个入口点函数，这是线程执行的起点。线程的入口点函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI 线程入口点函数名(PVOID pvParam)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 执行代码 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终线程函数结束运行并返回，此时线程栈内存也会释放，线程内核对象引用计数也会递减。<strong>线程内核对象的寿命大于等于线程本身寿命。</strong></p><p>线程函数必须返回一个值，就像_tmain函数和_tWinMain函数一样。这是该线程的退出代码。</p><p>创建线程对象，可调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread">CreateThread 函数</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES   lpThreadAttributes,  <span class="comment">// 安全描述符</span></span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T                  dwStackSize,         <span class="comment">// 线程栈大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPTHREAD_START_ROUTINE  lpStartAddress,      <span class="comment">// 线程入口函数地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID                  lpParameter,         <span class="comment">// 线程入口函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD                   dwCreationFlags,     <span class="comment">// 线程创建的标志，传0使其立即运行</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPDWORD                 lpThreadId           <span class="comment">// 线程ID，可传NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数仍然是熟悉的安全描述符，当然可以传NULL。第二个参数是线程栈大小，也就是一个线程可以使用的地址空间。每个线程都拥有自己的栈，如果传0将使用可执行程序的默认值，链接器设置的默认值为1MB。当然并不是dwStackSize传多少，栈大小就有多少，系统会将dwStackSize向上取整到页面大小。</p><p>Windows是一个抢占式的多线程系统(preeemptive multithreading system)，这意味着新线程和调用CreateThread函数的线程可以同时执行。线程可以通过下列四种方式终止运行：</p><ul><li><p>线程函数返回（强烈推荐）</p></li><li><p>调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread">ExitThread函数</a>杀死自己，即主调线程（避免使用）</p></li><li><p>调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread">TerminateThread函数</a>杀掉自己或杀其他线程（避免使用）</p></li><li><p>包含线程的进程终止运行（避免使用）</p></li></ul><p>就类似进程终止的方式一样，线程函数返回可以正确执行相应的清理工作。第二种和第三种则可能不能正确的清理，尤其是第三种，因为第三种情况杀别的线程时，线程不会收到自己即将被杀死的通知。</p><p>对于调用TerminateThread方式杀线程，这个函数不是阻塞函数，因此并不能保证这个函数返回时，目标线程已被杀死。此外，如果线程是通过返回或ExitThread的方式终止运行，该线程的堆栈也会被销毁，如果用的是TerminateThread，那么除非拥有此线程的进程终止运行，否则系统不会销毁这个线程的堆栈。这样实现的目的是为了防止其他线程引用本线程堆栈上的数据时，引起访问违规。</p><p>对于包含线程的进程终止运行这种方式，这样会使进程中剩余的所有线程全部被强行杀死。这意味着正确的应用程序清理工作不会执行。因此，如果应用程序并发运行多个线程，需要在主线程返回之前，明确处理好每个线程的终止过程。</p><p>线程终止运行时，会发生：</p><ul><li><p>线程拥有的所有用户对象都被释放。系统会自动销毁由线程或安装的任何窗口，并卸载由线程创建或安装的任何挂钩，其他对象只有在拥有线程的进程终止时才会销毁</p></li><li><p>线程的退出代码从STLL_ACTIVE(定义为0x103)变为线程入口函数返回值，TerminateThread或ExitThread调用的代码</p></li><li><p>线程内核对象变为触发状态。如果线程是进程的最后一个活动线程，系统认为进程终止了</p></li><li><p>线程内核对象引用计数递减1</p></li></ul><p>虽然线程不再运行，但仍然可以调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getexitcodethread">GetExitCodeThread函数</a>获得线程的返回值。</p><h2 id="线程原理"><a href="#线程原理" class="headerlink" title="线程原理"></a>线程原理</h2><p>下面是线程内核对象示意图：</p><p><img src="https://images0.cnblogs.com/blog/387401/201301/07111529-ed71590f4cdd4c48ba6aeefe155b2ab8.jpg"></p><p>一旦创建了线程内核对象,系统就分配内存,供线程的堆栈使用,此内存是从进程的地址空间内分配的,因为线程没有自己的地址空间,因此线程没有自己的地址空间.线程堆栈始终是从高位内存地址向低位地址构建的</p><p>指令指针(IP)及 RtlUserThreadStart 函数</p><p>因为新线程的指令指针被设置为 RtlUserThreadStart,所以这个函数实际就是线程开始执行的地方,观察 RltUserThreadStart 的原型,你会以为他接收了两个参数,但这就暗示着该函数是从另一个函数调用的,而实情并非如此.新线程只是在此处产生并且开始执行.之所以能访问这个两个参数,是由于操作系统将值显示地写入线程堆栈(参数通常就是这样传给函数的)</p><p>新线程执行 RtlUserThreadStart 函数时候,将发生以下事情</p><ul><li><p>围绕线程函数,会设置一个结构化异常处理(Structured Exception Handling,SEH)帧.这样一来线程执行期间所有产生的任何异常都能得到系统的默认处理.</p></li><li><p>系统调用线程函数,把传给 CreateThread函数的 pvParam 参数传递给它.</p></li><li><p>线程函数返回时,RtlUserThreadStart 调用 ExitThread函数,将你的线程函数的返回值传给它.线程内核对象的使用计数器递减,然后线程停止执行</p></li><li><p>如果线程产生了一个为被处理的异常,RtlUserThreadStart 函数所设置的 SEH 帧会处理这个异常.通常,这意味着系统会向用户显示一个消息框,而且当用户关闭此消息框时,RtlUserThreadStart 会调用 ExitProcess来终止整个进程.而不只是终止有问题的线程</p></li></ul><p>注意,在 RtlUserThreadStart 内,线程会调用 ExitThread 或者 ExitProcess.这意味着线程永远不能退出此函数;它始终在内部”消亡”</p><p>线程创建时，会先创建一个线程内核对象（分配在进程的地址空间上），存储上下文CONTEXT及一些统计信息，具体包括：</p><ul><li><p>寄存器SP：指向栈中线程函数指针的地址</p></li><li><p>寄存器IP：指向装载的NTDLL.dll里RtlUserThreadStart函数地址</p></li><li><p>Usage Count：引用计数，初始化为2</p></li><li><p>Suspend Count：挂起计数，初始化为1。</p></li><li><p>ExitCode：退出代码，线程在运行时为STILL_ACTIVE(且初始化为该值)</p></li><li><p>Signaled：初始化为未触发状态</p></li></ul><p>大约每隔20ms windows就会查看所有当前存在的线程内核对象。并在可调度的线程内核对象中选择一个，将其保存在CONTEXT结构的值载入cpu寄存器。这被称为上下文切换(context switch)。大约又过20ms(GetSystemTimeAdjustmnet函数第二个参数的返回值) windows将当前cpu寄存器存回内核对象，线程被挂起。Windows再次检查内核对象，并在可调度的内核对象中选择一个进行调度。此过程不断重复直到系统关闭。</p><p>此外，在线程内核对象中有一个值表示线程的挂起计数。调用CreateProcess或者 CreateThread时，系统将创建线程内核对象，并把挂起计数初始化为1。在线程初始化之后，CreateProcess 或者Createrhread 函数将查看是否有CREATE_SUSPENDED标志传入。如果有，函数会返回并让新的线程处于挂起状态。如果没有，函数会将线程的挂起计数递减为0。当线程的挂起计数为0时，线程就成为可调度的了，除非它还在等待某个事件发生（例如键盘输入）。</p><h2 id="CONTEXT结构"><a href="#CONTEXT结构" class="headerlink" title="CONTEXT结构"></a>CONTEXT结构</h2><p>CONTEXT结果保存着特定于处理器寄存器的数据，请参考WinNT.h头文件。CONTEXT结构分为几部分，CONTEXT_CONTROL包含CPU的控制寄存器，比如指令指针，栈指针，标志和函数返回地址。CONTEXT_INTEGER标识CPU整数寄存器，CONTEXT_FLOATING_POINT标识CPU浮点寄存器，CONTEXT_DEBUG_REGISTERS标识CPU调试寄存器，CONTEXT_SEGMENTS标识CPU段寄存器，CONTEXT_EXTENDED_REGISTERS标识CPU拓展寄存器。</p><p>我们可调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext">GetThreadContext 函数</a>获得线程内核对象内部，获得当前CPU状态集合。在调用GetThreadContext之前，需要先初始化一个CONTEXT结构，并设置其ContextFlags属性，然后挂起目标线程，最后才获取。可调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext">SetThreadContext函数</a>修改寄存器状态</p><h2 id="线程的挂起和恢复，睡眠与切换"><a href="#线程的挂起和恢复，睡眠与切换" class="headerlink" title="线程的挂起和恢复，睡眠与切换"></a>线程的挂起和恢复，睡眠与切换</h2><p>通过创建一个处于挂起状态的线程，我们可以在线程执行任何代码之前改变它的环境。改变了线程的环境之后，必须使其变为可调度的。这可以通过调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread">ResumeThread函数</a>，传入调用CreateThread时所返回的线程句柄（或者传给CreateProcess的ppiProclnfo参数所指向的结构中的线程句柄）</p><p>一个线程可以被多次挂起。如果一个线程被挂起三次，则在它有资格让系统为它分配CPU之前必须恢复三次。除了在创建线程时使用 CREATE_SUSPENDED标志外，还可以通过调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread">SuspendThread</a>来挂起线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">ResumeThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hThread</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">SuspendThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hThread</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>任何线程都可以调用这个函数挂起另一个线程（只要有线程的句柄）。显然，线程可以将自挂起，但是它无法自己恢复。与ResumeThread 一样，SuspendrThread 返回线程之前的挂起计数。一个线程最多可以挂起MAXIMUM SUSPEND_COUNT（WinNT.h中定义为127次。请注意，就内核模式下面执行情况而言，SuspendThread 是异步的，但在线程恢复之前，它是无法在用户模式下执行的。</p><p>实际开发中，应用程序在调用SuspendThread时必须小心，因为试图挂起一个线程时，我们不知道线程在做什么。例如，如果线程正在分配堆中的内存，线程将锁定堆。当其他线程要访问堆的时候，它们的执行将被中止，直到第一个线程恢复。只有在确切知道目标线程是哪个（或者它在做什么），而且采取完备措施避免出现因挂起线程而引起的问题或者死锁的时候，调用SuspendThread才是安全的。</p><p>其实，<strong>Windows中不存在挂起和恢复进程的概念，因为系统从来不会给进程调度CPU时间</strong>。在一个特殊情况下，即调试器处理WaitForDebugEvet返回的调试事件时，Windows将冻结被调试进程中的所有线程，直到调试器调用ContinueDebugEvent。Windows没有提供其他方式挂起进程中的所有线程，因为存在竞态条件问题。例如，在线程被挂起时，可能创建一个新的进程。系统必须想方设法挂起这个时间段中任何新的线程。</p><p>线程还可以告诉系统，在一段时间内自己不需要调度了。这可以通过调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep">Sleep 函数</a>实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sleep</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwMilliseconds</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>调用Sleep函数，将使线程自愿放弃属于它的时间片中剩下的部分。</p><p>系统设置线程不可调度的时间只是“近似于”所设定的毫秒数。没错，如果告诉系统想睡眠100ms，那么线程将睡眠差不多这么长时间，但是可能会长达数秒甚至数分钟。Windows不是实时操作系统。我们的线程可能准时醒来，但是实际情况取决于系统中其他线程的运行情况。</p><p>可以调用Sleep并给dwMs参数传入INFINITE。这是在告诉系统，永远不要调度这个进程。这样做没有什么用处。让线程退出并将其栈和内核对象返还给系统，要好得多。</p><p>可以给Sleep传入0。这是在告诉系统，主调线程放弃了时间片的剩余部分，它强制系统调度其他线程。但是系统有可能重新调度刚刚调用了Sleep的那个线程。如果没有相同或者较高优先级的可调度线程时，就会发生这样的事情。</p><p>我们可以调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-switchtothread">SwitchToThread 函数</a>使主调线程自动放弃CPU时间。</p><p>调用这个函数时，系统查看是否存在正急需CPU时间的饥饿线程。如果没有，SwitchToThread 立即返回。如果存在，SwitchToThread将调度该线程（其优先级可能比SwitchToThread的主调线程低）。饥饿线程可以运行一个时间量，然后系统调度程序恢复正常运行。</p><p>通过这个函数，需要某个资源的线程可以强制一个可能拥有该资源的低优先级的线程放弃资源。如果在调用SwitchToThread时没有其他线程可以运行，则函数将返回FALSE；否则，函数将返回一个非零值。</p><h2 id="线程的执行时间"><a href="#线程的执行时间" class="headerlink" title="线程的执行时间"></a>线程的执行时间</h2><p>我们可使用新的<a href="https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-gettickcount64">GetTickCount64 函数</a>先后获取一个时间点，然后相减算出任务消耗的时间。但是在Windows，我们不可能知道线程能获得CPU时间，当线程失去CPU时间时，计时更困难了。因而，我们应该调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadtimes">GetThreadTimes函数</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetThreadTimes</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE     hThread,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPFILETIME lpCreationTime,  <span class="comment">// 线程创建时间绝对值，单位100ns</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPFILETIME lpExitTime,      <span class="comment">// 线程退出时间，单位100ns</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPFILETIME lpKernelTime,    <span class="comment">// 线程执行内核模式操作系统代码用时间绝对值，100ns单位</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPFILETIME lpUserTime       <span class="comment">// 线程执行应用程序代码所用时间,100ns单位</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>要进行高精度的性能分析，我们可调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter">QueryPerformanceCounter函数</a>或<a href="https://learn.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency">QueryPerformanceFrequency函数</a></p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>在调度程序给一个可调度线程分配CPU之前，CPU可以运行一个线程大约20ms。这是优先级都相同的情况，实际上，各个线程有很多不同的优先级，这将影响调度程序如何选择下一个要运行的线程。</p><p>每个线程被赋予0（最低）~31（最高）的优先级数。CPU首先查看优先级最高的线程，并以循环（round-robin）的方式进行调度。一个31优先级的结束，cpu会调度领一个优先级为31的线程。只要有优先级为31的线程，系统就不会给优先级0-30的线程分配CPU，称为饥饿（starvation）在多处理器系统上饥饿发生的可能性要小得多。</p><p>较高优先级的线程会抢占较低优先级线程的时间片，例如一个优先级的5线程正在执行，系统确定有一个更高优先级的线程准备运行，会立即暂停较低优先级的线程（即使他还有时间片没用完）并将cpu分配给较高优先级的线程，该线程将获得一个完整的时间片。</p><p>系统启动时会创建一个0优先级的页面清零线程（zero page thread）负责在系统空闲时将内地中所有闲置页面清零。进程运行，我们便可以通过调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setpriorityclass">SetPriorityClass</a>，设置优先级类，来改变自己的优先级。可调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getpriorityclass?redirectedfrom=MSDN">GetPriorityClass函数</a>获得进程的优先级类。</p><p>Windows支持6个优先级类(priority class)，优先级从小到大分别是idle, below normal, normal, above normal, high, real-time，当然normal最为常用，idle适用于系统什么都不做时运行的应用程序，例如屏幕保护程序。只有在绝对必要时才使用high优先级类，因为high优先级类要求此进程中的线程立即响应事件，执行实时任务，任务管理器就使用这个优先级，因此用户可以通过它结束失控的线程。使用real-time优先级时，进程甚至能与系统组件抢CPU时间片，这可能会导致用户操作无响应，用户误认为死机了。</p><p>选择了优先级后，我们转而关注自己应用程序的线程。线程使用的是相对进程优先级，从小到大分别是idle, lowest, below normal, normal, above normal, highest, time-critical。</p><p>通常来说，CreateThread总是创建相对线程优先级为normal的新线程，如果要创建其他优先级的线程，我们需要先CreateThread时传入CREATE_SUSPENDED标志，然后调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadpriority">SetThreadPriority函数</a>，最后调用ResumeThread唤醒线程。Windows没有提供返回线程优先级的函数，这是Microsoft故意的，它保留了任何时候改变调度算法的权利。</p><p>偶尔，系统也会提升一个线程的优先级，通常是为了响应某种I&#x2F;O事件如窗口消息或磁盘读取。系统只提升优先级值在1-15（即动态优先级范围,dynamic priority range）的线程，系统不会把线程的优先级提升到实时范围（高于15），因为这样会影响操作系统。下列函数可以允许或禁止系统对线程或进程进行动态提升，查询是否启用进程或线程优先级提升等</p><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadpriorityboost?redirectedfrom=MSDN">SetThreadPriorityBoost function (processthreadsapi.h) - Win32 apps | Microsoft Learn</a></p><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setprocesspriorityboost?redirectedfrom=MSDN">SetProcessPriorityBoost function (processthreadsapi.h) - Win32 apps | Microsoft Learn</a></p><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadpriorityboost?redirectedfrom=MSDN">GetThreadPriorityBoost function (processthreadsapi.h) - Win32 apps | Microsoft Learn</a></p><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getprocesspriorityboost?redirectedfrom=MSDN">GetProcessPriorityBoost function (processthreadsapi.h) - Win32 apps | Microsoft Learn</a></p><h2 id="C-x2F-C-运行库相关事项"><a href="#C-x2F-C-运行库相关事项" class="headerlink" title="C&#x2F;C++运行库相关事项"></a>C&#x2F;C++运行库相关事项</h2><p>Visual Studio附带了4个C&#x2F;C++运行时库用于本机代码的开发，还有两个库面向Microsoft .NET的托管环境，这些库都支持多线程开发</p><table><thead><tr><th>库名称</th><th>描述</th></tr></thead><tbody><tr><td>LibCMt.lib</td><td>库的静态链接发行版本</td></tr><tr><td>LibCMtD.lib</td><td>库的静态链接调试版本</td></tr><tr><td>MSVCRt.lib</td><td>导入库，用于动态链接MSVCR80.dll库的发行版本</td></tr><tr><td>MSVCMRt.lib</td><td>导入库，用于动态链接MSVCR80D.dll库的发行版本</td></tr><tr><td>MSVCMRt.lib</td><td>导入库，用于托管&#x2F;本机代码混合</td></tr><tr><td>MSVCURt.lib</td><td>导入库，编译成100%纯MSIL代码</td></tr></tbody></table><h2 id="拓展资料：超线程CPU"><a href="#拓展资料：超线程CPU" class="headerlink" title="拓展资料：超线程CPU"></a>拓展资料：超线程CPU</h2><p>超线程（hyper-threading）是Xeon,Pentium 4 和更新的CPU支持的一个技术。超线程其实就是同时多线程(simultaneous multi-theading)，是一项允许一个CPU执行多个控制流的技术。它的原理很简单，就是把一颗CPU当成两颗来用，将一颗具有超线程功能的物理CPU变成两颗逻辑CPU，而逻辑CPU对操作系统来说，跟物理CPU并没有什么区别。因此，操作系统会把工作线程分派给这两颗（逻辑）CPU上去执行，让（多个或单个）应用程序的多个线程，能够同时在同一颗CPU上被执行。注意：两颗逻辑CPU共享单颗物理CPU的所有执行资源。因此，我们可以认为，超线程技术就是对CPU的虚拟化。</p><p>Hyper-threading 有时叫做 simultaneous multi-threading，它可以使我们的单核CPU执行多个控制流程。这个技术会涉及到备份一些CPU硬件的一些信息，比如程序计数器和寄存器文件等，而对于比如执行浮点运算的单元它只有一个备份，可以被共享。一个传统的处理器在线程之间切换大约需要20000时钟周期，而一个具有Hyperthreading技术的处理器只需要1个时钟周期，因此这大大减小了线程之间切换的成本。hyperthreading技术的关键点就是：当我们在处理器中执行代码时，很多时候处理器并不会使用到全部的计算能力，部分计算能力会处于空闲状态，而hyperthreading技术会更大程度地“压榨”处理器。举个例子，如果一个线程必须要等到一些数据加载到缓存中以后才能继续执行，此时CPU可以切换到另一个线程去执行，而不用去处于空闲状态，等待当前线程的IO执行完毕。</p><p>Hyper-threading 使操作系统认为处理器的核心数是实际核心数的2倍，因此如果有4个核心的处理器，操作系统会认为处理器有8个核心。这项技术通常会对程序有一个性能的提升，通常提升的范围大约在15%-30%之间，对于一些程序来说它的性能甚至会小于20%, 其实性能是否提升这完全取决于具体的程序。比如，这2个逻辑核心都需要用到处理器的同一个组件，那么一个线程必须要等待。因此，Hyper-threading只是一种“欺骗”手段，对于一些程序来说，它可以更有效地利用CPU的计算能力，但是它的性能远没有真正有2个核心的处理器性能好，因此它不能替代真正有2个核心的处理器。但是同样都是2核的处理器，一个有hyper-threading技术而另一个没有，那么有这项技术的处理器在大部分情况下都要比没有的好。</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：探索Windows内核对象作业</title>
      <link href="/blogs/posts/windows/p88fd15a5c690.html"/>
      <url>/blogs/posts/windows/p88fd15a5c690.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="内核对象作业Job"><a href="#内核对象作业Job" class="headerlink" title="内核对象作业Job"></a>内核对象作业Job</h2><p>在Visual Studio中，我们有时候想在编译文件中途终止编译，调试程序中途终止调试，Visual Studio是怎么做的呢？虽然这是一个简单而常见的问题，但windows没有维护线程之间的父子关系，解决起来非常难。</p><p>Windows提供了一个<strong>作业(job)内核对象,它允许你将进程组合在一起并创建一个”沙箱”来限制进程能够做什么</strong>.最好将作业对象想象成一个进程容器.但是,即使作业中只包含一个进程,也是非常有用的,因为这样可以对进程施加平时不能施加的限制.<a href="https://learn.microsoft.com/en-us/windows/win32/procthread/job-objects">点我查看微软官方对于作业对象的介绍</a></p><p>下面的程序代码，将尝试将一个进程放到一个作业中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain()</span><br><span class="line">&#123;</span><br><span class="line">    BOOL bInJob = FALSE;</span><br><span class="line">    <span class="comment">// 判断进程是否已被放入作业中</span></span><br><span class="line">    <span class="built_in">IsProcessInJob</span>(<span class="built_in">GetCurrentProcess</span>(), <span class="literal">NULL</span>, &amp;bInJob);</span><br><span class="line">    <span class="keyword">if</span> (bInJob)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;本进程已被放入作业&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建作业内核对象</span></span><br><span class="line">    HANDLE hJob = <span class="built_in">CreateJobObject</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;MySecretJob&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置作业的基本限制事项</span></span><br><span class="line">    JOBOBJECT_BASIC_LIMIT_INFORMATION joblimit = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 设置优先级类，和设置进程的优先级类很像</span></span><br><span class="line">    joblimit.PriorityClass = IDLE_PRIORITY_CLASS;</span><br><span class="line">    <span class="comment">// 设置作业的执行时间限制，单位纳米秒</span></span><br><span class="line">    joblimit.PerProcessUserTimeLimit.QuadPart = <span class="number">10000</span>;</span><br><span class="line">    <span class="comment">// 设置作业的生效标志，不设置会导致不生效</span></span><br><span class="line">    joblimit.LimitFlags = JOB_OBJECT_LIMIT_PRIORITY_CLASS | JOB_OBJECT_LIMIT_JOB_TIME;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置作业对象的基本用户界面控制</span></span><br><span class="line">    JOBOBJECT_BASIC_UI_RESTRICTIONS jobuir;</span><br><span class="line">    <span class="comment">// 阻止作业内进程注销用户</span></span><br><span class="line">    jobuir.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_EXITWINDOWS;</span><br><span class="line">    <span class="comment">// 防止与作业内进程访问同一个作业外部进程创建的内核对象</span></span><br><span class="line">    jobuir.UIRestrictionsClass |= JOB_OBJECT_UILIMIT_HANDLES;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用SetInformationJobObject，</span></span><br><span class="line">    <span class="comment">// 依次将限制效果作用在作业对象上</span></span><br><span class="line">    <span class="built_in">SetInformationJobObject</span>(hJob, JobObjectBasicLimitInformation, &amp;joblimit, <span class="built_in">sizeof</span>(joblimit));</span><br><span class="line">    <span class="built_in">SetInformationJobObject</span>(hJob, JobObjectBasicUIRestrictions, &amp;jobuir, <span class="built_in">sizeof</span>(jobuir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建进程</span></span><br><span class="line">    STARTUPINFO si = &#123;<span class="built_in">sizeof</span>(si)&#125;;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line">    <span class="comment">// 注意：在创建进程时，这里使用了CREATE_SUSPENDED参数，这样虽然会创建新进程，</span></span><br><span class="line">    <span class="comment">// 但不允许它执行任何代码。这样就可以防止子进程“逃离”我们的沙箱</span></span><br><span class="line">    <span class="built_in">CreateProcess</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;C:\\windows\\System32\\cmd.exe&quot;</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_SUSPENDED, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将进程添加到作业，这个过程要显式设置</span></span><br><span class="line">    <span class="built_in">AssignProcessToJobObject</span>(hJob, pi.hProcess);</span><br><span class="line">    <span class="comment">// 唤醒进程的主线程</span></span><br><span class="line">    <span class="built_in">ResumeThread</span>(pi.hThread);</span><br><span class="line">    <span class="comment">// 关闭句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待进程结束或CPU时间用光</span></span><br><span class="line">    HANDLE handles[<span class="number">2</span>];</span><br><span class="line">    handles[<span class="number">0</span>] = pi.hProcess;</span><br><span class="line">    handles[<span class="number">1</span>] = hJob;</span><br><span class="line"></span><br><span class="line">    DWORD result = <span class="built_in">WaitForMultipleObjects</span>(<span class="number">2</span>, handles, FALSE, INFINITE);</span><br><span class="line">    <span class="keyword">switch</span> (result - WAIT_OBJECT_0)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;作业关联的进程已终止&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_ICONINFORMATION);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;作业分配的CPU时间用尽&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_ICONINFORMATION);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭相应句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hJob);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和所有内核对象一样，第一个参数将安全信息与新的作业对象关联。调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createjobobjecta">CreateJobObject </a>函数可创建一个内核对象。调用CloseHandle关掉作业句柄后，并不会迫使作业内所有进程终止运行，实际上只是加了一个删除标记，只有作业中所有进程都已终止运行，才会自动销毁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateJobObject</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpJobAttributes, <span class="comment">// 作业的安全描述符</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR               lpName,          <span class="comment">// 作业内核对象名称，可为NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><h2 id="给作业添加限制"><a href="#给作业添加限制" class="headerlink" title="给作业添加限制"></a>给作业添加限制</h2><p>之后，我们设置了作业的一些基本限制信息后，调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/jobapi2/nf-jobapi2-assignprocesstojobobject">AssignProcessToJobObject函数</a>，将一个进程放入作业。</p><p>关于设置作业的基本限制项，我们可以限制：</p><ul><li><p>基本限额和拓展基本限额，用于防止作业中的进程独占系统资源</p></li><li><p>基本的UI限制，用于防止作业内进程修改用户界面</p></li><li><p>安全限额，用于防止作业内进程访问安全资源（如文件，注册表等）</p></li></ul><p>在上述示例代码中，调用了<a href="https://learn.microsoft.com/en-us/windows/win32/api/jobapi2/nf-jobapi2-setinformationjobobject">SetInformationJobObject 函数</a>，来使设置的基本设置项生效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetInformationJobObject</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE             hJob,                        <span class="comment">// 作业对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">    JOBOBJECTINFOCLASS JobObjectInformationClass,   <span class="comment">// 设置的作业信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID             lpJobObjectInformation,      <span class="comment">// 相应数据结构</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD              cbJobObjectInformationLength <span class="comment">// 第三个参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>其中第二个参数，我们可以选择下面的类，当然还有其他的</p><ul><li>JOBOBJECT_BASIC_LIMIT_INFORMATION（作业基本限额）<a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/WinNT/ns-winnt-jobobject_basic_limit_information">查看详细</a></li><li>JOBOBJECT_BASIC_UI_RESTRICTIONS（作业基本UI限制）<a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/WinNT/ns-winnt-jobobject_basic_ui_restrictions">查看详细</a></li><li>JOBOBJECT_CPU_RATE_CONTROL_INFORMATION（作业CPU速率限制）<a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/WinNT/ns-winnt-jobobject_notification_limit_information">查看详细</a></li></ul><p>在上方示例代码中，我们设置了JOB_OBJECT_UILIMIT_HANDLES，这个限制意味着作业内任何进程都不能访问作业外部进程所创建的用户对象。例如在一个作业中运行Microsoft Spy++，就只能看到Spy++自己创建的窗口。</p><p>这个UI限制只是单向的，也就是说作业外部的进程可以看到作业内部进程所创建的用户对象，即使内部指定了JOB_OBJECT_UILIMIT_HANDLES</p><p>要为作业中的进程创建一个真正安全的沙箱，对UI句柄进行限制是很强大的一个能力，不过，有时仍然需要让用户内部的一个进程同作业外部的一个进程进行通信。我们可以使用窗口消息进行通信，但是如果作业中的进程不能访问UI句柄，那么这个方法就失效了。幸运的是，我们可以用<a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-userhandlegrantaccess">UserHandleGrantAccess 函数</a>来通信。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">UserHandleGrantAccess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE hUserHandle, <span class="comment">// 一个用户对象的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE hJob,        <span class="comment">// 指定的作业对象 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL   bGrant       <span class="comment">// 允许或拒绝作业内部进程访问此对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/jobapi2/nf-jobapi2-terminatejobobject">TerminateJobObject 函数 </a>，可以把作业内的所有进程都终止。</p><p>我们可调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/jobapi2/nf-jobapi2-queryinformationjobobject">QueryInformationJobObject 函数</a>来查询一个作业的相应限制信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">QueryInformationJobObject</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE             hJob,                        <span class="comment">// 作业句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    JOBOBJECTINFOCLASS JobObjectInformationClass,   <span class="comment">// 查询信息的信息类</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID             lpJobObjectInformation,      <span class="comment">// 储存查询信息的结构体</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD              cbJobObjectInformationLength,<span class="comment">// sizeof 第三个参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPDWORD            lpReturnLength               <span class="comment">// 已写入的字节，可传NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>如果第一个参数传NULL，并且执行代码的进程被放入作业中，将查询这个作业的相关信息。对于SetInformationJobObject这样调用是失败的，目的是防止进程删掉施加给自己身上的限制。</p><h2 id="作业通知"><a href="#作业通知" class="headerlink" title="作业通知"></a>作业通知</h2><p>如果我们很想知道作业中的所有进程何时终止执行，所有已分配的CPU时间是否已经到期，我们应该怎么做呢？</p><p>作业中的进程如果尚未用完已分配的CPU时间，作业对象处于未触发状态，一旦作业用完所有已分配的CPU时间，Windows就强行“杀死”作业中的所有进程，并触发作业对象。通过调用WaitForSingleObject或一个类似的函数，我们可以轻松捕获到这个事件。我们之后还可以把作业对象重置为未触发状态，只需调用SetInformationJobObject并授予更多CPU时间即可。</p><p>如果想获得更高级的作业通知，我们必须创建一个I&#x2F;O完成端口（completion port）内核对象，并将我们的作业对象与其关联，然后处理。</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：探索Windows内核对象进程 (2)</title>
      <link href="/blogs/posts/windows/pbce90bc36ce8.html"/>
      <url>/blogs/posts/windows/pbce90bc36ce8.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="再探CreateProcess函数"><a href="#再探CreateProcess函数" class="headerlink" title="再探CreateProcess函数"></a>再探CreateProcess函数</h2><p>我们用CreateProcess函数创建一个进程，<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess函数</a>的原型如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR                lpApplicationName,    <span class="comment">// 应用程序名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPTSTR                 lpCommandLine,        <span class="comment">// 命令行参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpProcessAttributes,   <span class="comment">// 默认进程的安全属性，可传NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpThreadAttributes,    <span class="comment">// 默认进程的安全属性，可传NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL                  bInheritHandles,       <span class="comment">// 当前进程内核对象能否被子进程继承</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD                 dwCreationFlags,       <span class="comment">// 创建进程的方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID                lpEnvironment,         <span class="comment">// 创建进程使用的环境变量，</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="comment">// 传NULL表示使用父进程的</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCSTR                lpCurrentDirectory,    <span class="comment">// 创建进程的驱动器和目录，</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="comment">// 传NULL表示使用父进程的</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTARTUPINFOA        lpStartupInfo,         <span class="comment">// 传递给新进程的信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPPROCESS_INFORMATION lpProcessInformation   <span class="comment">// 新进程返回的信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>下面详细探索CreateProcess的参数意义</p><h3 id="lpApplicationName和lpCommandLine"><a href="#lpApplicationName和lpCommandLine" class="headerlink" title="lpApplicationName和lpCommandLine"></a>lpApplicationName和lpCommandLine</h3><p>lpApplicationName和lpCommandLine分别指定新进程要运行的可执行文件名称和新进程的命令行字符串。<strong>注意lpCommandLine参数类型是LPTSTR，在内部CreateProcess实际上会修改我们传给他的命令行字符串，在CreateProcess函数返回前，这个字符串会被还原成原来的模样。</strong></p><p>由于Microsoft的C&#x2F;C++编译器把字符串字面量放在只读内存中，这会引起访问违规（早期版本的Microsoft的C&#x2F;C++编译器把字符串放到可读可写内存中，因此不会引起访问违规）。因此我们可以把常量字符串复制到一个临时缓冲区，然后再传入lpCommandLine位置。</p><p>如果lpApplicationName不为NULL，那么Windows将尝试打开叫lpApplicationName的可执行文件。如果lpApplicationName为NULL，Windows将解析lpCommandLine的第一个token，假定这是我们想运行的可执行文件名称，如果该可执行文件无拓展名，默认为.exe。</p><p>CreateProcess按以下顺序搜索可执行文件</p><ol><li><p>主调进程.exe文件所在目录</p></li><li><p>主调进程当前目录</p></li><li><p>Windows系统目录，即GetSystemDirectory返回的System32文件夹</p></li><li><p>Windows目录</p></li><li><p>PATH环境变量列出的目录</p></li></ol><p>相信各位小伙伴在第一次配置编程环境时，总是去修改PATH环境变量，这就是原因所在了。当然如果这个文件名是一个完整路径，系统就直接查找这个路径的文件</p><h3 id="lpProcessAttributes-lpThreadAttributes-bInheritHandles"><a href="#lpProcessAttributes-lpThreadAttributes-bInheritHandles" class="headerlink" title="lpProcessAttributes, lpThreadAttributes, bInheritHandles"></a>lpProcessAttributes, lpThreadAttributes, bInheritHandles</h3><p>lpProcessAttributes,lpThreadAttributes用于指定创建的进程的进程对象和线程对象的安全性，可以都传NULL，这样系统就为这两个内核对象指定默认安全描述符。</p><h3 id="dwCreationFlags"><a href="#dwCreationFlags" class="headerlink" title="dwCreationFlags"></a>dwCreationFlags</h3><p>dwCreationFlags参数标识了新进程的创建方式的标志，多个标志可用按位或组合起来</p><p>部分可用标志如下：</p><table><thead><tr><th>标志</th><th>作用</th></tr></thead><tbody><tr><td>DEBUG_PROCESS</td><td>父进程希望调试子进程以及子进程将来生成的所有进程。该标志想系统表明，任何一个子进程（即被调试程序，debugee）中发生的特定的事件，要通知父进程（即调试器，debuger）</td></tr><tr><td>DEBUG_ONLY_THIS_PROCESS</td><td>类似DEBUG_PROCESS，但是只有生成的这个子进程发生特定事件会通知父进程</td></tr><tr><td>CREATE_SUSPENDED</td><td>让系统在创建新进程同时挂起其主线程，这样父进程就可以修改子进程地址空间的内存等。父进程修改之后，可调用ResumeThread允许子进程执行代码</td></tr><tr><td>DETACHED_PROCESS</td><td>阻止一个CUI应用程序的进程访问父进程的控制台窗口，因为默认情况下子进程会继续使用父进程的控制台窗口</td></tr></tbody></table><p>此外我们还可以设置创建进程的优先级类，不过大部分应用程序都不这么做</p><h3 id="lpEnvironment"><a href="#lpEnvironment" class="headerlink" title="lpEnvironment"></a>lpEnvironment</h3><p>新进程使用的环境字符串，如果传入NULL，子进程将继承父进程使用的一组环境字符串</p><h3 id="lpCurrentDirectory"><a href="#lpCurrentDirectory" class="headerlink" title="lpCurrentDirectory"></a>lpCurrentDirectory</h3><p>设置子进程的当前驱动器和目录，如果为NULL，新进程的工作目录与生成新进程的应用程序一样。</p><h3 id="lpStartInfo"><a href="#lpStartInfo" class="headerlink" title="lpStartInfo"></a>lpStartInfo</h3><p>传递给新进程的信息，详细请看<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa">STARTUPINFOA (processthreadsapi.h) - Win32 apps | Microsoft Learn</a></p><h3 id="lpProcessInformation"><a href="#lpProcessInformation" class="headerlink" title="lpProcessInformation"></a>lpProcessInformation</h3><p>我们需要准备一个<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION </a>结构，CreateProcess函数返回时初始化这个结构的成员。</p><p>在创建一个内核对象时，系统会给此对象分配一个独一无二的标识符，没有别的内核对象会有相同的ID编号，对于线程对象也是一样的。然后，对象分配到的ID不可能是0，Windows任务管理器将进程ID 0 与 系统空闲进程(System Idle Process)关联，实际上没有这个东西，任务管理器创建这个虚构的进程目的是将其作为Idle线程的占位符，在没有别的线程正在运行时，系统就运行这个Idle进程，System Idle Process线程数量始终等于计算机CPU数量，始终代表未被真实进程使用的CPU使用率。</p><p><strong>如果子进程想和父进程保持通信，那么最好不应该使用对方的进程句柄，而采用别的方式（如内核对象，窗口句柄）</strong>。因为子进程创建之后，系统就认为父进程与子进程不再有父子关系，并且如果此时父进程已经死掉，其他创建的进程很可能会分配到这个死掉的父进程的ID，此时这个ID对应的就不是原来那个父进程了。一旦我们使用保存的进程ID，操作的就是新进程不再是原来那个。</p><p>可调用GetCurrentProcessId获得当前进程ID，GetCurrentThreadId获得当前运行的线程ID，GetProcessId获得与指定句柄对应的进程ID，GetThreadId获得与指定句柄对应的一个线程ID。GetProcessIdOfThread可以获得其所在进程的ID</p><h2 id="终止进程的方式"><a href="#终止进程的方式" class="headerlink" title="终止进程的方式"></a>终止进程的方式</h2><p>进程可以通过4种方式终止：</p><ul><li><p>主线程入口点函数返回（强烈推荐）</p></li><li><p>进程中一个线程调用ExitProcess函数（避免这么做）</p></li><li><p>另一个进程中的线程调用TerminateProcess函数（避免这么做）</p></li><li><p>进程中所有线程都“自然死亡”（几乎不会发生）</p></li></ul><h3 id="主线程入口点函数返回"><a href="#主线程入口点函数返回" class="headerlink" title="主线程入口点函数返回"></a>主线程入口点函数返回</h3><p>一个应用程序，应该保证只有主线程入口点函数返回之后，这个应用程序才终止。对于主线程入口点函数返回方式，可以<strong>保证任何C++对象被正确析构，操作系统正确释放线程栈使用内存，系统将进程的退出代码设为入口点函数返回值，系统递减进程内核对象的使用技术</strong>。</p><h3 id="进程中一个线程调用ExitProcess函数"><a href="#进程中一个线程调用ExitProcess函数" class="headerlink" title="进程中一个线程调用ExitProcess函数"></a>进程中一个线程调用ExitProcess函数</h3><p>在进程的任意一个线程调用<code>VOID ExitProcess(UINT fuExitCode)</code>将导致这个进程终止，并设置进程退出代码为fuExitCode，如果ExitProcess后还有别的代码，那些代码永远不会执行。</p><p>当主线程的入口点函数(WinMain,wWinMain,main,或wmain)返回时，会返回到C&#x2F;C++运行库启动代码，这样会正确清理进程使用的全部C运行时资源，然后C运行库启动代码调用ExitProcess，进程退出。这就是为什么主线程的入口点函数返回，整个进程都被终止。</p><h3 id="TerminateProcess函数"><a href="#TerminateProcess函数" class="headerlink" title="TerminateProcess函数"></a>TerminateProcess函数</h3><p>调用<code>BOOL TerminateProcess(HANDLE hProcess, UINT fuExitCode)</code>可终止一个进程，任何进程都可以通过这种方式终止。只有在无法通过其他方式强制进程退出时，才应使用此函数。被终止的进程得不到自己要被终止的通知，因为应用程序不能正确清理，也不能阻止他自己被强行终止。</p><p>操作系统保证进程终止后会进行彻底的清理，确保不会泄露任何操作系统资源，进程使用的所有内存都会被释放，所有打开的文件都会被关闭，所有内核对象的引用计数都将递减，所有用户对象和GDI对象会被销毁。进程在终止后绝对不会泄露任何东西。</p><h2 id="用户账户控制UAC"><a href="#用户账户控制UAC" class="headerlink" title="用户账户控制UAC"></a>用户账户控制UAC</h2><p>对于应用程序开发人员，影响最大的技术即为用户账户控制（User Account Control, UAC）。Microsoft注意到大多数用户都喜欢使用管理员(Administrator)账户登录Windows。这个账户用户几乎可以没有限制地访问重要系统资源。用户帐户控制  是 Microsoft 的总体安全构想的基本组件。 UAC 有助于缓解恶意软件的影响。</p><p>下图表示管理员与普通用户在登录时的不同之处。</p><p><img src="https://learn.microsoft.com/zh-cn/windows/security/identity-protection/user-account-control/images/uacwindowslogonprocess.gif"></p><p>默认情况下，标准用户和管理员在标准用户的安全上下文中访问资源并运行应用。 当用户登录到计算机时，系统会为该用户创建访问令牌。 访问令牌包含有关授予用户的访问权限级别的信息，包括特定安全标识符 (SID) 和 Windows 权限。</p><p>管理员登录时，将为用户创建两个单独的访问令牌：标准用户访问令牌和管理员访问令牌。 标准用户访问令牌包含与管理员访问令牌相同的特定于用户的信息，但会删除管理 Windows 特权和 SID。 标准用户访问令牌用于启动不执行管理任务的应用 (标准用户应用) 。 然后，标准用户访问令牌用于显示桌面 (explorer.exe) 。 Explorer.exe是所有其他用户启动的进程从中继承其访问令牌的父进程。 因此，除非用户提供许可或凭据来批准应用使用完整的管理访问令牌，否则所有应用都以标准用户身份运行。</p><p>作为管理员组成员的用户可以使用标准用户访问令牌登录、浏览 Web 和阅读电子邮件。 当管理员需要执行需要管理员访问令牌的任务时，Windows 会自动提示用户进行审批。 此提示称为提升提示，可以使用本地安全策略管理单元 (Secpol.msc) 或组策略来配置其行为。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-security-policy-settings">用户帐户控制安全策略设置</a>。</p><p>启用 UAC 后，标准用户的用户体验不同于管理员审批模式下管理员的用户体验。 建议的、更安全的运行 Windows 方法是使主要用户帐户成为标准用户帐户。 以标准用户身份运行有助于最大程度地提高托管环境的安全性。 使用内置的 UAC 提升组件，标准用户可以通过输入本地管理员帐户的有效凭据来轻松执行管理任务。 标准用户的默认内置 UAC 提升组件是凭据提示。</p><p>以标准用户身份运行的替代方法是在管理员审批模式下以管理员身份运行。 使用内置的 UAC 提升组件，本地管理员组的成员可以通过提供审批轻松执行管理任务。 管理员审批模式下管理员帐户的默认内置 UAC 提升组件称为同意提示。</p><p>如：</p><p><img src="https://learn.microsoft.com/en-us/windows/security/identity-protection/user-account-control/images/uacconsentprompt.png"></p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：探索Windows内核对象进程</title>
      <link href="/blogs/posts/windows/pf1b6fecfeb59.html"/>
      <url>/blogs/posts/windows/pf1b6fecfeb59.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="再次探索Windows应用程序"><a href="#再次探索Windows应用程序" class="headerlink" title="再次探索Windows应用程序"></a>再次探索Windows应用程序</h2><p>进程由以下两部分构成：</p><ul><li><p>一个内核对象，操作系统用于管理进程</p></li><li><p>一个地址空间，包含所有可执行文件或DLL模块的代码和数据，以及动态内存分配。</p></li></ul><p>进程是有惰性的，进程要做的事情，必须让一个线程在他的上下文中运行，该线程负责执行进程空间包含的代码。一个进程可以有多个线程，所有线程都在进程的地址空间“同时”执行代码。为此，<strong>每个线程都有他自己的一组CPU寄存器和它自己的堆栈，每个进程至少有一个线程执行进程地址空间包含的代码。当系统创建一个进程的时候，会自动为进程创建第一个线程，这即为主线程(main thread)。</strong> 如果没有线程要执行进程地址空间包含的代码，进程失去了继续存在的理由，这是系统就会自动销毁进程及其地址空间。</p><p>对于所有要运行的线程，<strong>操作系统会轮流给每个线程调度一些CPU时间，采用循环（round-robin，轮询或轮流）方式，为每个线程分配时间片（quantum，称为“量”或“量程”），从而营造出所有线程都在同时运行的假象。</strong> 如果计算机配备了多个CPU，操作系统会采用更复杂的算法为线程分配CPU时间，Microsoft Windows可以同时让不同的CPU执行不同的线程，使得多个线程可以真正并发运行，此时Windows内核负责线程所有管理和调度任务。当然，为了更好的利用这些CPU，我们需要在算法上多下功夫。</p><h3 id="Windows应用程序类型再认识"><a href="#Windows应用程序类型再认识" class="headerlink" title="Windows应用程序类型再认识"></a>Windows应用程序类型再认识</h3><p><strong>Windows支持两种类型的应用程序：GUI(Graphical User Interface，图形用户界面)，和CUI(Console User Interface，控制台用户界面)。</strong> 我们现在常用的程序都是GUI程序，是图形化的，有窗口，有菜单，有对话框。而控制台程序是基于文本的，一般不会创建窗口或进程消息（当然可以创建窗口），虽然CUI程序是在屏幕中的一个窗口运行的，但这个窗口只有文本，例如命令提示符(CMD.EXE)。</p><p>用Microsoft Visual Studio创建应用程序时，这个IDE会设置链接器开关，使源代码可以正确生成可执行文件中。对于CUI程序，这个链接器开关为&#x2F;SUBSYSTEM:CONSOLE，对于GUI程序，则为&#x2F;SUBSYSTEM:WINDOWS。用户在运行应用程序时，操作系统的加载程序(loader)会检查执行文件影响的文件头，并获得这个子系统值，如果此值表明为CUI程序，加载程序会确保有一个控制台可以使用，若有必要会创建一个；如果表明为GUI程序，则只会加载程序。</p><h3 id="Windows应用程序深刻解读"><a href="#Windows应用程序深刻解读" class="headerlink" title="Windows应用程序深刻解读"></a>Windows应用程序深刻解读</h3><p>Windows应用程序必须有一个入口点函数，可以选择下列两种之一的入口函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INT WINAPI _tWinMain(</span><br><span class="line">    HINSTANCE hInstance,      <span class="comment">// 当前实例句柄</span></span><br><span class="line">    HINSTANCE hPrevInstance,  <span class="comment">// 上一个实例句柄，现在已废弃</span></span><br><span class="line">    PTSTR lpCmdLine,         <span class="comment">// 命令行参数</span></span><br><span class="line">    <span class="type">int</span> nCmdShow              <span class="comment">// 窗口显示方式</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(</span><br><span class="line">    <span class="type">int</span> argc,          <span class="comment">// 命令行参数个数</span></span><br><span class="line">    TCHAR *argv[],     <span class="comment">// 命令行参数数组</span></span><br><span class="line">    TCHAR *envp[]      <span class="comment">// 环境变量</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>实际上操作系统并不调用我们所写的入口点函数，而是会调用C&#x2F;C++运行库实现并在链接时使用-entry:命令行选择C&#x2F;C++运行时的启动函数，此函数初始化C&#x2F;C++运行时库，还确保了我们任何全局或竟然变量会被正确初始化。</p><p>_tWinMain和_tmain实际上是宏定义，将会在编译时替换为正确的函数。</p><table><thead><tr><th>应用程序类型</th><th>入口点函数（入口）</th><th>嵌入可执行文件的启动函数</th></tr></thead><tbody><tr><td>多字节版本的GUI程序</td><td>_tWinMain(WinMain)</td><td>WinMainCRTStartup</td></tr><tr><td>Unicode版本的GUI程序</td><td>_tWinMain(WinMain)</td><td>wWinMainCRTStartup</td></tr><tr><td>多字节版本的GUI程序</td><td>_tmain(main)</td><td>mainCRTStartup</td></tr><tr><td>Unicode版本的GUI程序</td><td>_tmain(wmain)</td><td>wmainCRTStartup</td></tr></tbody></table><p>在链接可执行文件时，链接器会选择正确的C&#x2F;C++运行时库启动函数。开发者通常想制作一个GUI程序，后因为用Visual Studio创建项目时操作有误，导致报错unresolved external symbol(无法解析的外部符号)错误，提示找不到main函数。就是因为链接器开关为&#x2F;SUBSYSTEM:CONSOLE，即目的是控制台程序，这样的原因。</p><p>我们只需在项目属性（之前的探索过程中介绍过如何打开这个窗口），修改SubSystem为WINDOWS即可。当然也可以通过这种方式改回来。</p><p><img src="https://s1.ax1x.com/2023/04/05/pp5wmV0.png"></p><p>所有C&#x2F;C++运行时库启动函数工作基本都是一样的。在Visual C++自带C运行库源代码，可在crtexe.c文件中看到四个启动函数源代码，主要做下列工作：</p><ul><li><p>获得指向新进程完整命令行的指针</p></li><li><p>获取指向新进程环境变量的指针</p></li><li><p>初始化C&#x2F;C++运行库全局变量</p></li><li><p>初始化C运行库内存分配函数和其他底层I&#x2F;O例程使用的堆</p></li><li><p>调用所有全局和静态C++类对象构造函数</p></li></ul><p>各位小伙伴可能不知道例程是什么意思，实际上例程，过程，子程序都是函数的不同称呼，本质上还是函数。</p><table><thead><tr><th>变量名</th><th>类型</th><th>描述和推荐使用的Windows函数</th></tr></thead><tbody><tr><td>_osver</td><td>unsigned int</td><td>操作系统的构建版本号，例如Windows Vista RTM为build 60000，则_osver值为6000，请换用<a href="https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getversion">GetVersionEx函数</a></td></tr><tr><td>_winmajor</td><td>unsigned int</td><td>以16进制表示的Windows系统主版本号，请换用<a href="https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getversion">GetVersionEx函数</a></td></tr><tr><td>_winminor</td><td>unsigned int</td><td>以16进制表示的Windows系统次版本号，请换用<a href="https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getversion">GetVersionEx函数</a></td></tr><tr><td>_winver</td><td>unsigned int</td><td>(_winmajor &lt;&lt; 8) + _winminor，请换用<a href="https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getversion">GetVersionEx函数</a></td></tr><tr><td>__argc</td><td>unsigned int</td><td>命令行参数个数，请换用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getcommandlinea">GetCommandLine</a></td></tr><tr><td>__argv    __wargv</td><td>char*[]</td><td>长度为__argc的一个数组，其中数组每个元素指向命令行参数。如果定义了_UNICODE，__argv&#x3D;NULL，否则__wargv&#x3D;NULL。请换用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getcommandlinea">GetCommandLine</a></td></tr><tr><td>_environ  _wenviron</td><td>char*[]</td><td>一个指针数组，数组每一项都指向一个环境字符串。如果定义了_UNICODE，_environ&#x3D;NULL，否则__wenviron&#x3D;NULL。请换用<a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getenvironmentvariable">GetEnvironmentVariable函数</a>或<a href="https://learn.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getenvironmentstrings">GetEnvironmentStrings函数</a></td></tr><tr><td>_pgmptr  _wpgmptr</td><td>char[]</td><td>正在运行的程序名称及其完整路径。如果已经定义 _UNICODE，_pgmptr&#x3D;NULL，否则_wpgmptr&#x3D;NULL。请换用<a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea">GetModuleFileName函数</a></td></tr></tbody></table><p>完成初始化工作之后，C&#x2F;C++启动函数就会调用应用程序入口点函数，假如入口函数为WinMain，那么调用过程为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GetStartupInfo</span>(&amp;StartupInfo);</span><br><span class="line"><span class="type">int</span> nMainRetVal = <span class="built_in">WinMain</span>(</span><br><span class="line">    (HINSTANCE)&amp;__ImageBase, </span><br><span class="line">    <span class="literal">NULL</span>, pszCommandLineAnsi, </span><br><span class="line">    (StartupInfo.dwFlags &amp; STARTF_USESHOWWINDOW ? </span><br><span class="line">     StartupInfo.wSHowWindow : SW_SHOWEDFAULT);</span><br></pre></td></tr></table></figure><p>__ImageBase是链接器定义的伪变量，表明可执行文件被映射到应用程序内存中的位置，即进程实例句柄。</p><p>入口函数返回后，启动函数将调用C运行时库函数exit，向其传递返回值nMainRetVal，exit函数将：</p><ul><li><p>调用_onexit函数调用所注册的任何一个函数</p></li><li><p>调用所有全局和静态C++类对象的析构函数</p></li><li><p>在DEBUG模式下，如果设置了__CRTDBG_LEAK_CHECK_DF标志，则调用_CrtDumpMemoryLeaks函数生成内存泄露报告</p></li><li><p>调用操作系统ExitProcess函数，向其传入nMainRetVal，这会导致操作系统杀掉我们的进程，并设置退出代码。</p></li></ul><p>下面对_tWinMain函数的四个参数进行更深一步的探索</p><h3 id="进程实例句柄hInstance"><a href="#进程实例句柄hInstance" class="headerlink" title="进程实例句柄hInstance"></a>进程实例句柄hInstance</h3><p>_tWinMain的hInstance参数实际值实际上是一个内存基地址，系统将可执行文件的映像加载到进程空间的这个位置，如操作系统打开可执行文件并决定加载到地址0x00400000，那么hInstance值为0x00400000，</p><p><strong>可执行文件映像具体加载到哪个基地址，由链接器决定，不同的链接器使用不同的默认基地址。</strong> 由于历史原因，VisualStudio链接器(LINK.EXE)使用默认基地址是0x00400000，这是运行Windows 98时，可执行文件的映像能加载到的最低的一个地址。使用LINK.EXE命令&#x2F;BASE:address，可修改加载的基地址位置。</p><p>我们可以调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle函数</a>或者调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandleexa">GetModuleHandleEx函数</a>得到可执行文件或DLL文件加载到底进程空间地址的位置。下方对GetModuleHandle函数的调用方式进行演示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMODULE <span class="title">GetModuleHandle</span><span class="params">(PCTSTR pszModule)</span></span>;</span><br><span class="line"><span class="comment">// pszModule为已加载的可执行文件或DLL文件名称</span></span><br><span class="line"><span class="comment">// 如果系统找到了pszModule，就会返回它加载的基地址，否则返回NULL</span></span><br><span class="line"><span class="comment">// 给pszModule传入NULL，可返回主调进程可执行文件基地址，</span></span><br><span class="line"><span class="comment">// 当然也可以用伪变量 __ImageBase 获取主调进程可执行文件基地址</span></span><br></pre></td></tr></table></figure><p>加载到进程地址空间的每一个可执行文件或DLL都被赋予了独一无二的实例句柄。在需要加载资源的函数调用中，一般我们都提供此句柄的值。因此我们一般使用一个全局变量保存下来，这样方便加载资源。</p><p>此外，<strong>GetModuleHandle函数只会检查主调进程的地址空间</strong>，也就是说主调进程如果没有调用任何对话框函数，一旦调用GetModuleHandle，并传递ComDlg32就会返回NULL，即使ComDlg32.dll已经加载到其他进程。<strong>调用GetModuleHandle函数并向其传递NULL值，会返回进程的地址空间中的可执行文件的基地址</strong>，就算是调用GetModuleHandle(NULL)的代码在一个DLL中，返回值仍是可执行文件的基地址，而不是DLL的基地址。</p><p>另外，<strong>HMODULE和HINSTANCE实际上完全是一回事，我们可以在需要HMODULE时传入一个HINSTANCE，反之亦然。</strong> 之所以有两种数据类型，是因为在16位Windows中他两表示不同类型数据，但现在表示的都相同了。</p><h3 id="进程上一个实例的句柄hPrevInstance"><a href="#进程上一个实例的句柄hPrevInstance" class="headerlink" title="进程上一个实例的句柄hPrevInstance"></a>进程上一个实例的句柄hPrevInstance</h3><p>_tWinMain函数的第二个参数hPrevInstance是用于16位Windows程序的，现在为了兼容保留下来，因而这个参数总是为NULL。</p><blockquote><p>编程小技巧：对于未使用的参数，在Visual Studio我们可使用UNREFERENCED_PARAMETER 宏来消除警告，就像Qt程序可使用Q_UNUSED宏一样</p></blockquote><h3 id="进程的命令行lpCmdLine"><a href="#进程的命令行lpCmdLine" class="headerlink" title="进程的命令行lpCmdLine"></a>进程的命令行lpCmdLine</h3><p>系统在创建一个新进程时，会传一个命令行给他。命令行几乎是非空的，至少命令行的第一个参数即为可执行文件的名称。</p><p><strong>进程仅能接收只由一个字符构成的命令行，因而我们不应该通过解析lpCmdLine参数来分析命令行</strong>，而是使用<code>PTSTR GetCommandLine()</code>函数，这个函数返回一个缓冲区指针，包含完整的命令行（包括可执行文件完整路径），并且总是返回同一个缓冲区的地址。因此，为了防止误修改命令行，我们通常把这个数据拷贝到本地的缓冲区，然后再解析命令行。</p><p>许多应用程序都倾向于将命令行分割成一个一个单独的标记，但是Microsoft反对继续使用全局变量__argc和__argv，但应用程序仍然可以使用他们。我们可以利用ShellAPI.h头文件中声明并由Shell32.dll导出的函数<a href="https://learn.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-commandlinetoargvw">CommandLineToArgvW 函数</a>即可将任何Unicode字符串分割成单独的标记。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPWSTR* <span class="title">CommandLineToArgvW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCWSTR lpCmdLine, <span class="comment">// 指向命令行的字符串，通常为GetCommandLineW返回值</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> *pNumArgs      <span class="comment">// 用于接收命令行中实参数目的地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数返回一个LPWSTR*数组的数据。CommandLineToArgvW在内部分配内存，因此我们可以不释放这块内存，由操作系统在进程终止时释放。如果想自己释放，应该调用HeapFree</p><h3 id="进程的环境变量"><a href="#进程的环境变量" class="headerlink" title="进程的环境变量"></a>进程的环境变量</h3><p>每个进程都有一个与它关联的环境块(environment block)，这是在进程地址空间分配的一块内存，其中包含的字符串和下面类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=::=::\ ...</span><br><span class="line">Var1=Value1\0</span><br><span class="line">Var2=Value2\0</span><br><span class="line">Var3=Value3\0</span><br><span class="line">VarN=ValueN\0</span><br><span class="line">\0</span><br></pre></td></tr></table></figure><p><strong>每个字符串的第一部分是一个环境变量的名称，后跟一个等号，等号后是环境变量的值（如果有空格，包括空格部分）</strong>。除了第一个<code>=::=::\</code>字符串，可能还有其他字符串以等号开头，但这种字符串不作为环境变量使用。我们可以使用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getenvironmentstrings">GetEnvironmentStrings 函数</a>获得这种完整的环境块，得到的环境块的格式与本段描述的完全一致。</p><p>下面的一段代码展示了如何遍历输出所有的环境变量的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取环境变量字符串</span></span><br><span class="line">    LPTSTR lpEnvVars = <span class="built_in">GetEnvironmentStrings</span>();</span><br><span class="line">    LPTSTR lpCurVar = lpEnvVars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lpCurVar != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每一个环境变量字符串都以NULL结尾</span></span><br><span class="line">        <span class="keyword">while</span> (*lpCurVar)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这一条判断是为了忽略=开头的字符串</span></span><br><span class="line">            <span class="keyword">if</span> (*lpCurVar != <span class="built_in">TEXT</span>(<span class="string">&#x27;=&#x27;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                _tprintf(<span class="built_in">TEXT</span>(<span class="string">&quot;%s\n&quot;</span>), lpCurVar);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移动指针到下一个字符串开头</span></span><br><span class="line">            lpCurVar += <span class="built_in">lstrlen</span>(lpCurVar) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放字符串缓冲区</span></span><br><span class="line">    <span class="built_in">FreeEnvironmentStrings</span>(lpEnvVars);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，对于描述环境变量的字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VAR1=WINDOWS</span><br><span class="line">VAR2= WINDOWS</span><br></pre></td></tr></table></figure><p>VAR1和VAR2会被认为是不同的环境变量</p><p>用户在登录Windows时，系统创建外壳(shell)进程，系统通过检查注册表中的两个注册表项来获得初始的环境的字符串。</p><p>第一个包含系统所有环境变量列表</p><p>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager</p><p>第二个注册表项包含当前登录用户所有环境变量列表</p><p>HKEY_CURRNET_USER\Environment</p><p>用户可以自由修改。应用程序还可以使用各种注册表函数来修改这些注册表项，为了使改动对所有应用程序生效，用户必须注销并重新登陆，有些应用程序可以在其主窗口接收到WM_SETTINGCHANGE消息，用新的注册表项更新他们的环境块。如果我们在更新了注册表项后希望应用程序马上更新他们的环境块，可以进行如下调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SendMessage</span>(HWND_BROADCAST, WM_SETTINGCHANGE, <span class="number">0</span>, </span><br><span class="line">            (LPARAM)<span class="built_in">TEXT</span>(<span class="string">&quot;Environment&quot;</span>));</span><br></pre></td></tr></table></figure><p>上面还提到过，对于修改环境变量，可以使用<a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getenvironmentvariable">GetEnvironmentVariable函数</a>来获取环境变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetEnvironmentVariable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpName,    <span class="comment">// 环境变量的名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPTSTR  lpBuffer,  <span class="comment">// 接收环境变量的缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD   nSize      <span class="comment">// 缓冲区大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>如果lpBuffer为NULL，这个函数的返回值为需要的缓冲区大小。</p><p>调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setenvironmentvariable">SetEnvironmentVariable函数</a>可以修改某个环境变量的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetEnvironmentVariable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpName,  <span class="comment">// 环境变量的名称 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpValue  <span class="comment">// 修改成的环境变量的值，</span></span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="comment">// 如果为NULL将删掉这个环境变量</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>在很多字符串的内部，都包含了“可替换字符串”，类似<code>%环境变量名%</code>的子串，即为可替换字符串，</p><p>例如<code>PATH=%PATH%</code>，这个<code>%PATH%</code>即为可替换字符串</p><p>我们可调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-expandenvironmentstringsa">ExpandEnvironmentStrings函数</a>来将一个带有可替换字符串的的字符串，用环境变量值的实际内容替换相应位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">ExpandEnvironmentStrings</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpSrc,  <span class="comment">// 包含可替换字符串的字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPTSTR  lpDst,  <span class="comment">// 接收替换结果的缓冲区，</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="comment">// 如为NULL该函数返回值为需要的缓冲区大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  nSize    <span class="comment">// 缓冲区大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>例如下列调用代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LPTSTR lpBuffer = <span class="keyword">new</span> TCHAR[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">ExpandEnvironmentStrings</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;你的电脑环境变量OS的值：%OS%&quot;</span>), </span><br><span class="line">                         lpBuffer, <span class="number">256</span>);</span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, lpBuffer, <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line"><span class="keyword">delete</span>[] lpBuffer;</span><br></pre></td></tr></table></figure><p>在我的电脑环境变量OS的值为<code>WINDOWS_NT</code>，故lpBuffer的内容为<code>你的电脑环境变量OS的值：WINDOWS_NT</code></p><h2 id="进程的其他特性"><a href="#进程的其他特性" class="headerlink" title="进程的其他特性"></a>进程的其他特性</h2><p>下面探索进程的其他特性</p><h3 id="进程的关联性和进程的错误模式"><a href="#进程的关联性和进程的错误模式" class="headerlink" title="进程的关联性和进程的错误模式"></a>进程的关联性和进程的错误模式</h3><p>进程中的线程可以在主机任何CPU上运行，也可以强迫线程在可用CPU的一个子集上运行，这称为处理器关联性(processor affinity)，子进程继承其父进程的关联性。</p><p>每个进程对于错误关联了一组标志，为了让系统知道进程如何响应严重错误。进程可调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-seterrormode">SetErrorMode函数</a>来告诉系统如何处理这些错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">SetErrorMode</span><span class="params">(UINT fuErrorMode)</span></span>;</span><br></pre></td></tr></table></figure><p>fuErrorMode参数可以为下列及其按位的共同效果。</p><table><thead><tr><th>标志</th><th>效果</th></tr></thead><tbody><tr><td>SEM_FAILCRITICALERRORS</td><td>系统不显示严重错误处理程序（critical-error-handler）消息框，并将错误返回主调进程</td></tr><tr><td>SEM_NOGPFAULTERRORBOX</td><td>系统不显示常规保护错误(general-protection-fault)消息框。此标志只应该由调试程序设置。该调试程序用一个异常处理程序来自行处理常规保护错误（general protection），即GP错误</td></tr><tr><td>SEM_NOOPENFILERRORBOX</td><td>系统查找文件失败时，不显示消息框</td></tr><tr><td>SEM_NOALIGNMENTFAULTEXCEPT</td><td>系统自动修复内存对其错误，并使应用程序看不到这些错误，对x86&#x2F;x64处理器无效。</td></tr></tbody></table><p>默认情况下，子进程会继承父进程的错误模式标志，当然子进程不知道这一点，上文已经提到过很多东西子进程都不知道他自己继承下来的东西。</p><h3 id="进程当前所在的驱动器和目录"><a href="#进程当前所在的驱动器和目录" class="headerlink" title="进程当前所在的驱动器和目录"></a>进程当前所在的驱动器和目录</h3><p>如果不提供完整路径名，Windows函数会在当前驱动器的当前目录查找文件和目录。例如调用CreateFile打开一个未指定完整路径名的文件，系统将在当前驱动器和目录查找相应文件。</p><p>系统在内部跟踪记录这一个进程的当前驱动器和目录。这种信息是以进程为单位来维护的，因而假如进程中的一个线程修改了当前驱动器或目录，对于该进程的所有线程来说，此信息被更改了。</p><p>一个线程可以调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getcurrentdirectory">GetCurrentDirectory函数</a>来获得进程当前所在的驱动器和目录。调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setcurrentdirectory">SetCurrentDirectory函数</a>修改之。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetCurrentDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  nBufferLength,   <span class="comment">// 缓冲区长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPTSTR lpBuffer         <span class="comment">// 缓冲区地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetCurrentDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpPathName  <span class="comment">// 修改的路径</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>如果缓冲区不够大，GetCurrentDirectory函数返回所需要的字符数。在头文件<code>WinDef.h</code>头文件的<code>MAX_PATH</code>宏（定义为260）定义了目录文件或名称的最大字符数，因而我们通常准备一个有MAX_PATH大小的缓冲区来储存此数据。</p><p>系统跟踪记录着进程当前驱动器和目录，但没有记录每个驱动器的当前目录。不过，Microsoft Windows的支持，可以处理多个驱动器的当前目录。这个支持是通过进程的环境字符串来提供的。如一个进程可以有如下的两个环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=C:=C:\Codes</span><br><span class="line">=D:=D:\Program Files</span><br></pre></td></tr></table></figure><p>上述变量指出进程在C驱动器的当前目录为\Codes，D驱动器当前目录为\Program Files。如果调用一个函数，并且传入的路径名限定的是当前驱动器以外的驱动器，系统会在进程的环境块中查找与指定驱动器号（也称盘符）相关的变量。如果找到了，系统就将变量的值当做当前目录使用，如果没找到，系统就假定指定驱动器的当前目录为它的根目录。</p><p>如假定进程当前目录为C:&#x2F;Codes，我们调用CreateFile函数打开<code>D:README.md</code>文件，那么系统会查找环境变量<code>=D:</code>，由于在现在假设的情况该变量存在，则系统尝试在<code>D:\Program Files\</code>目录打开README.md文件，如果&#x3D;D:变量不存在，则系统尝试在D盘根目录打开README.md文件</p><p>子进程的当前目录默认为每个驱动器的根目录，如果希望子进程继承父进程的当前目录，父进程必须在生成子进程之前，创建这些驱动器号环境变量，并添加到环境块中。父进程可调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfullpathnamea">GetFullPathName函数</a>获取。</p><h3 id="进程的系统版本"><a href="#进程的系统版本" class="headerlink" title="进程的系统版本"></a>进程的系统版本</h3><p>很多时候，我们需要判断用户的Windows版本。在很长的时间内，Windows API仅提供了一个<code>DWORD GetVersion()</code>函数。这个函数具有悠久的历史，最初是为16位Windows系统设计的，此函数返回值高字节返回MS-DOS版本号，低字节返回Windows版本号。在每个字中，高位字节表示主版本号，低位字节表示次版本号。</p><p>遗憾的是，写代码的程序员犯了一个错误，导致windows版本号顺序颠倒了。由于历史原因，微软没有废除这个函数，并添加了新的函数<a href="https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getversionexa">GetVersionExA</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetVersionEx</span><span class="params">(POSVERSIONINFOEX pVersionInformation)</span></span>;</span><br></pre></td></tr></table></figure><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-osversioninfoa">OSVERSIONINFOEX结构体</a>的定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_OSVERSIONINFOEX</span> &#123;</span><br><span class="line">  DWORD dwOSVersionInfoSize;  <span class="comment">// 这个结构体的size</span></span><br><span class="line">  DWORD dwMajorVersion;       <span class="comment">// 主版本号</span></span><br><span class="line">  DWORD dwMinorVersion;       <span class="comment">// 次版本号</span></span><br><span class="line">  DWORD dwBuildNumber;        <span class="comment">// 系统构件号</span></span><br><span class="line">  DWORD dwPlatformId;         <span class="comment">// 系统支持的平台</span></span><br><span class="line">  TCHAR szCSDVersion[<span class="number">128</span>];    <span class="comment">// 系统补丁包名称</span></span><br><span class="line">  WORD  wServicePackMajor;    <span class="comment">// 系统补丁包主版本</span></span><br><span class="line">  WORD  wServicePackMinor;    <span class="comment">// 系统补丁包次版本</span></span><br><span class="line">  WORD  wSuiteMask;           <span class="comment">// 标识系统上的程序组</span></span><br><span class="line">  BYTE  wProductType;         <span class="comment">// 标识系统类型</span></span><br><span class="line">  BYTE  wReserved;            <span class="comment">// 保留的参数</span></span><br><span class="line">&#125; OSVERSIONINFOEX, *POSVERSIONINFOEX, *LPOSVERSIONINFOEX;</span><br></pre></td></tr></table></figure><p>我们需要自己初始化一个OSVERSIONINFOEX结构体，然后作为GetVersionEx的参数，这样就可以获取了。</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：Windows内核对象初步探讨</title>
      <link href="/blogs/posts/windows/p19349a29417d.html"/>
      <url>/blogs/posts/windows/p19349a29417d.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="Windows内核对象初步认识"><a href="#Windows内核对象初步认识" class="headerlink" title="Windows内核对象初步认识"></a>Windows内核对象初步认识</h2><p>Windows中有很多像访问令牌(access token)对象、事件(event)对象、进程(process)对象、线程(thread)对象、文件(file)对象、文件映射（filemapping)、可等待计时器（waitable timer)对象等等这样的对象，我们称之为Windows内核对象。内核对象是系统地址空间中的一个内存块，由系统创建并维护，这个内存对象是一个数据结构，维护着与对象相关的信息。微软提供了一些可以操作内核对象的API，可以使我们以适当的方式操作内核对象。<a href="https://learn.microsoft.com/en-us/windows/win32/sysinfo/kernel-objects">关于内核对象的参考内容。</a></p><p><strong>内核对象的所有者是操作系统，而非进程。如果我们的进程创建了一个内核对象，我们的进程终止之后，内核对象不一定被销毁，</strong> 因为可能别的进程使用我们的内核对象（如在下文中提到子进程继承父进程内核对象句柄，此时父进程终止之后，内核对象不一定被销毁）。</p><p><strong>操作系统当然知道有多少进程使用同一个内核对象，因为每个内核对象都有一个叫引用计数(usage count)的共有数据成员。</strong> 初次创建一个内核对象时，他的引用计数为1，当一个内核对象的引用计数为0时，会被操作系统销毁，这样可以保证没有不被任何进程引用的内核对象。</p><p><strong>内核对象用一个为安全描述符(security descriptor, SD)来保护。安全描述符描述了谁拥有对象，谁可以访问或使用对象，谁不可以访问对象。</strong> 在创建内核对象时，几乎所有的API都有一个指向<a href="https://learn.microsoft.com/en-us/windows/win32/api/wtypesbase/ns-wtypesbase-security_attributes">SECURITY_ATTRIBUTES结构体</a>的指针形参，这个结构体为安全描述符。默认情况下我们对于此参数都是传NULL，这样创建的内核对象有默认的安全性，具体包括哪些安全性，取决于当前进程的安全令牌(security token)。</p><p>许多老版本windows应用程序在visita之后不能正常工作，都在于不使用安全性。<br>例如，注册表操作 调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regopenkeyexa">RegOpenKeyExA函数时</a> ，正确做法是传入KEY_QUERY_VALUE,从而指定查询子项数据的权限。传入KEY_ALL_ACCESS，就忽略了安全性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_SECURITY_ATTRIBUTES</span> &#123;</span><br><span class="line">    DWORD nLength;               <span class="comment">//结构体的大小，可用SIZEOF取得</span></span><br><span class="line">    LPVOID lpSecurityDescriptor; <span class="comment">//安全描述符</span></span><br><span class="line">    BOOL bInheritHandle ;        <span class="comment">//安全描述的对象能否被新创建的进程继承</span></span><br><span class="line">&#125; SECURITY_ATTRIBUTES，* PSECURITY_ATTRIBUTES;</span><br></pre></td></tr></table></figure><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga">有关CreateFileMapping的内容</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateFileMappingA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE                hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD                 flProtect,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD                 dwMaximumSizeHigh,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD                 dwMaximumSizeLow,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCSTR                lpName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>**一个进程在初始化时，操作系统给他分配一个句柄表(handle table)**。创建任何内核对象，都会返回一个与进程相关的句柄。如果创建一个内核对象失败，返回的句柄值通常为NULL。注意是通常，也就是说有返回其他的表示失败，这取决于文档说明。失败原因可能是系统内存不足，或遇到了安全问题。</p><p>句柄表的结构类似这个样子：</p><table><thead><tr><th>索引</th><th>指向内核对象地址的指针</th><th>访问掩码（包含一个DWORD的ID）</th><th>可继承标志</th></tr></thead><tbody><tr><td>1</td><td>0x????????</td><td>0x????????</td><td>0x????????</td></tr><tr><td>2</td><td>0x????????</td><td>0x????????</td><td>0x????????</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>我们使用<a href="https://learn.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">ClsoeHandle函数</a>来关闭一个内核对象。在CloaseHandle返回之前，她会清除进程句柄表中对应的记录项，无论内核对象是否当前销毁，这个过程均发生。</p><p>忘记了关闭内核对象会怎么样？ <strong>在进程运行期间，进程可能会发生资源泄露的情况，但是进程结束之后操作系统保证该进程使用的所有资源都被释放。</strong> 系统会保证我们的进程不留下任何东西。</p><p>我们可以使用Windows任务管理器查看每个进程的内核对象数。具体我们需要先打开Windows任务管理器(taskmgr.exe)，然后点击Process（进程），点击菜单上的View(查看)，然后点击Select Columns(选择列)菜单项。</p><p><img src="https://s1.ax1x.com/2023/04/01/ppWWF5q.png" alt="https://s1.ax1x.com/2023/04/01/ppWWF5q.png"></p><p><img src="https://s1.ax1x.com/2023/04/01/ppWWAP0.png"></p><p>这样我们就可以查看进程的句柄数了。</p><p>很多时候不同进程中运行的进程需要共享内核对象。 例如：</p><ul><li>利用文件映射对象，可以在同一机器上运行两个不同进程之间的共享数据块。</li><li>借助邮件槽和命名管道，在网络中的不同计算机运行的进程可以相互发送数据块。</li><li>互斥量，和信号量和事件允许不同进程中的进程同步执行。</li></ul><p>我们可以使用下面这三种机制来允许进程之间共享内核对象：使用对象句柄继承，为对象命名，复制对象句柄。</p><h2 id="共享内核对象：使用对象句柄继承"><a href="#共享内核对象：使用对象句柄继承" class="headerlink" title="共享内核对象：使用对象句柄继承"></a>共享内核对象：使用对象句柄继承</h2><p><strong>当且仅当进程之间存在父子关系时，才可以使用对象句柄继承。对象句柄继承，继承的是对象的句柄，并不是继承父进程的内核对象。</strong> 为了使子进程能继承父进程的句柄，我们首先需要在创建内核对象时，分配并初始化一个<a href="https://learn.microsoft.com/en-us/windows/win32/api/wtypesbase/ns-wtypesbase-security_attributes">SECURITY_ATTRIBUTES结构体</a>。这个结构体是安全描述符，是我们自定义的。之后在调用创建内核对象的API时，传入其形参 PSECURITY_ATTRIBUTES位置；如果传NULL，表明这个句柄无法被继承。</p><p>当一个句柄可被继承时，它在句柄表位置的标志位被设为1，否则被设为0。标志位设为1的句柄才能被子进程继承，即“可被继承的对象句柄”<br>最后调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess函数</a>，并且使得bInheritHandles实参为TRUE，这样创建子进程。这种情况下，<strong>子进程就可以继承父线程中所有“可被继承的内核句柄”了</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR                lpApplicationName,    <span class="comment">// 应用程序名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPTSTR                 lpCommandLine,        <span class="comment">// 命令行参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpProcessAttributes,   <span class="comment">// 默认进程的安全属性，可传NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpThreadAttributes,    <span class="comment">// 默认进程的安全属性，可传NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL                  bInheritHandles,       <span class="comment">// 当前进程内核对象能否被子进程继承</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD                 dwCreationFlags,       <span class="comment">// 创建进程的方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID                lpEnvironment,         <span class="comment">// 创建进程使用的环境变量，</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="comment">// 传NULL表示使用父进程的</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCSTR                lpCurrentDirectory,    <span class="comment">// 创建进程的驱动器和目录，</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="comment">// 传NULL表示使用父进程的</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTARTUPINFOA        lpStartupInfo,         <span class="comment">// 传递给新进程的信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPPROCESS_INFORMATION lpProcessInformation   <span class="comment">// 新进程返回的信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>操作系统仍然会为子进程创建新的句柄表，只不过此时她多做一件事：<strong>遍历父进程的句柄表，对父进程所有任何有效的“可被继承的内核句柄”的句柄项，复制到子进程去，且和父进程的句柄表位置一模一样。 内核对象，访问掩码，标志这三个项的值完全一样</strong>。 这样就意味着，在父进程和子进程，对一个内核对象的标识的句柄值完全一样。除此之外，系统还会增加内核对象的引用计数。</p><p><strong>对象句柄的继承只会发生在生成子进程那一刻发生，之后父进程后来又新建了其他内核对象且都可被继承，子进程是不会继承这些句柄的。子进程也不知道任何继承的句柄，这点非常重要。</strong> 因此，有必要在子进程的文档中表明打算继承哪些句柄。</p><p>为了使得子进程得到它想要的一个内核对象的句柄值，最常用的方式是将句柄值作为命令行参数传到子进程去，然后子进程的初始化代码解析命令行来提取句柄值，之后子进程就可以访问这个内核对象了。当然也可以通过父进程等待子进程完成初始化，父进程向子进程添加一个环境变量等。<strong>内核对象句柄的继承之所以会实现，原因是共享的内核对象的句柄值在父进程和子进程那都是一样的。</strong></p><p>通过父进程等待子进程完成初始化，通常使用<a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-waitforinputidle">WaitForInputIdle函数</a>，然后父进程发送一条消息到子进程的一个线程创建的窗口中。而通过父进程向子进程添加环境变量的方式，把句柄值写入进去，在子进程创建时会继承父进程的环境变量，就可以通过<a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getenvironmentvariable">GetEnvironmentVariable</a>得到环境变量。</p><p>如果在创建内核对象之后想修改它的可继承或其他属性，调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-sethandleinformation">SetHandleInformation function函数</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetHandleInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE hObject,   <span class="comment">// 要修改内核对象的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  dwMask,    <span class="comment">// 修改的属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  dwFlags    <span class="comment">// 修改的内容</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HANDLE hObject; <span class="comment">// 一个句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目前有下面常用用法 </span></span><br><span class="line"><span class="comment">// 设置句柄值可继承：</span></span><br><span class="line"><span class="built_in">SetHandleInformation</span>(hObject, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT);</span><br><span class="line"><span class="comment">// 设置句柄不可继承：</span></span><br><span class="line"><span class="built_in">SetHandleInformation</span>(hObject, HANDLE_FLAG_INHERIT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 设置句柄值不可关闭，受保护：</span></span><br><span class="line"><span class="built_in">SetHandleInformation</span>(hObject, HANDLE_FLAG_PROJECT_FROM_CLOSE, HANDLE_FLAG_PROJECT_FROM_CLOSE);</span><br><span class="line"><span class="comment">// 设置句柄值可关闭，不受保护：</span></span><br><span class="line"><span class="built_in">SetHandleInformation</span>(hObject, HANDLE_FLAG_PROJECT_FROM_CLOSE, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="共享内核对象：为对象命名"><a href="#共享内核对象：为对象命名" class="headerlink" title="共享内核对象：为对象命名"></a>共享内核对象：为对象命名</h2><p>有一些内核对象在创建时需要传一个pszName参数，表明内核对象的名称（注意是有一些，并不是所有都是），我们可以传NULL表明这个内核对象是匿名的。如果不传NULL，这个字符串要求以0结尾，且字符长度最大为MAX_PATH(定义为260)。Microsoft没有任何机制保证这个内核对象的命名是唯一的，且所有内核对象共享一个命名空间，即使类型并不相同。例如创建一个Mutex命名为A，创建一个Semaphore也命名为A，这样会报错，并且我们也不能知道已经存在了叫A的内核对象。</p><p><strong>当创建一个未命名的内核对象时，可以通过使用继承性或者DuplicateHandle函数（下面提到）来共享跨越进程的对象。当创建一个有名字的内核对象时，我们一般使用Create*的创建内核对象函数来获得这些</strong>对象。 Create*函数和Open*函数的主要差别： 如果对象不存在，Create*函数将创建该对象， 而Open*函数则运行失败。使用 GetLastError函数来获取函数运行的结果。<strong>使用为对象命名共享内核对象，最大优势即是共享内核对象的进程不一定就是创建内核对象的子进程。</strong></p><p>因此，在一个窗口程序中，我们通常通过CreateMutex创建互斥量内核对象来保证同一个应用程序只有一个实例运行。为了确保名字的独立性，我们一般生成一个GUID字符串作为创建互斥量的名称。还有其他方式保证名字的独立性。例如下面这个win32程序入口。如果要限定程序同时可运行n个实例用信号量（Semaphore）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hMutex = <span class="built_in">CreateMutex</span>(<span class="literal">NULL</span>, FALSE, <span class="built_in">TEXT</span>(<span class="string">&quot;MyApplication&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (hMutex == <span class="literal">NULL</span> || ERROR_ALREADY_EXISTS == ::<span class="built_in">GetLastError</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;静止多开！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;警告&quot;</span>), MB_ICONWARNING);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;成功运行&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;提示&quot;</span>), MB_ICONINFORMATION);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于使用这些方式创造的内核对象，命名是在全局的。那么，如果其他应用程序也使用这个名字创建内核对象，我们无法防止发生“劫持”现象。任何进程，都可以创造任何名字的内核对象。以前面这个防止多开的例子为例，如果另外一个应用程序防多开也是用这套代码，“单实例”的程序很可能永远都开不了，因为它可能错误地认为有别的实例在同时运行。这即为大家熟知的DoS攻击，一种拒绝服务攻击。</p><p>未命名的内核对象不会遭受DoS攻击，并且不给内核对象命名是很普遍的。<strong>如果我们想确保我们的内核对象命名永远不会与其他的发生冲突，可以定义一个前缀作为自己专有命名空间使用。</strong> 负责创建内核对象的服务器将创建一个边界描述符（boundrary desciptor）对命名空间的名称进行保护。</p><p>创建专有命名空间步骤：</p><ol><li><p>如何创建一个边界</p></li><li><p>如何将对应于本地管理员（Local Administrators）的一个安全描述符（security identifier, SID）和它关联起来</p></li><li><p>如何创建或者打开其名称被用途互斥量内核对象前缀的一个专有命名空间。</p></li></ol><p>看下方代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边界句柄，这个句柄不需要被CloseHandle</span></span><br><span class="line">HANDLE   g_hBoundary = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//名字空间句柄</span></span><br><span class="line">HANDLE   g_hNamespace = <span class="literal">NULL</span>;　</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为边界和名字空间取名</span></span><br><span class="line">PCTSTR   g_szBoundary = <span class="built_in">TEXT</span>(<span class="string">&quot;3-Boundary&quot;</span>);</span><br><span class="line">PCTSTR   g_szNamespace = <span class="built_in">TEXT</span>(<span class="string">&quot;3-Namespace&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1. 创建边界，获得返回的边界句柄</span></span><br><span class="line">    <span class="comment">// 实际上这个是伪句柄，不是内核对象句柄</span></span><br><span class="line">    g_hBoundary = <span class="built_in">CreateBoundaryDescriptor</span>(g_szBoundary, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建指向本地Administrators的用户描述符</span></span><br><span class="line">    <span class="comment">// 也可以用AllocateAndInitializeSID函数来获得SID值</span></span><br><span class="line">    BYTE localAdminSID[SECURITY_MAX_SID_SIZE];</span><br><span class="line">    PSID pLocalAdminSID = &amp;localAdminSID;</span><br><span class="line">    DWORD cbSID = <span class="built_in">sizeof</span>(localAdminSID);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CreateWellKnownSid</span>(</span><br><span class="line">       WinBuiltinAdministratorsSid, <span class="literal">NULL</span>, pLocalAdminSID, &amp;cbSID)) </span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// 创建指向本地Administrators的用户描述符失败时，将执行此块代码</span></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 将一个特权用户组的SID与边界描述符关联起来</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AddSIDToBoundaryDescriptor</span>(&amp;g_hBoundary, pLocalAdminSID)) </span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// 失败时，将执行此块代码</span></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SECURITY_ATTRIBUTES sa;</span><br><span class="line">    sa.nLength = <span class="built_in">sizeof</span>(sa);</span><br><span class="line">    sa.bInheritHandle = FALSE;</span><br><span class="line">    <span class="comment">// 指定SID中谁能进入边界并创建命名空间 </span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ConvertStringSecurityDescriptorToSecurityDescriptor</span>(</span><br><span class="line">       <span class="built_in">TEXT</span>(<span class="string">&quot;D:(A;;GA;;;BA)&quot;</span>),</span><br><span class="line">       SDDL_REVISION_1, &amp;sa.lpSecurityDescriptor, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">       <span class="built_in">GetLastError</span>();</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建命名空间,如果已存在这个命名空间，GetLastError返回ERROR_ALREADY_EXISTS</span></span><br><span class="line">    g_hNamespace = <span class="built_in">CreatePrivateNamespace</span>(&amp;sa, g_hBoundary, g_szNamespace);</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">LocalFree</span>(sa.lpSecurityDescriptor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在可以使用“3-Namespace\yourName”之类的命名空间了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成后释放资源</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放命名空间时，我们可以给第二个参数传PRIVATE_NAMESPACE_FLAG_DESTROY </span></span><br><span class="line">    <span class="comment">// 这样就可以使其关闭后不可见</span></span><br><span class="line">    <span class="built_in">ClosePrivateNamespace</span>(g_hNamespace, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 释放边界资源用的是DeleteBoundaryDescriptor</span></span><br><span class="line">    <span class="built_in">DeleteBoundaryDescriptor</span>(g_hBoundary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以使用<a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-openprivatenamespacea">OpenPrivateNamespace函数</a>，来打开这个命名空间了。创建对象时，使用<code>命名空间/对象名字</code>的形式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenPrivateNamespaceA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpBoundaryDescriptor,  <span class="comment">// 命名空间隔离方式的描述符</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCSTR lpAliasPrefix          <span class="comment">// 命名空间的前缀</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>值得一提的是，在终端服务有多个命名空间，其中一个是全局命名空间。远程桌面和快速用户切换也是利用终端服务对话实现的。</p><h2 id="共享内核对象：复制对象句柄"><a href="#共享内核对象：复制对象句柄" class="headerlink" title="共享内核对象：复制对象句柄"></a>共享内核对象：复制对象句柄</h2><p>我们使用<a href="https://learn.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-duplicatehandle">DuplicateHandle函数</a>进行复制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DuplicateHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE hSourceProcessHandle,  <span class="comment">// 拥有源内核对象句柄的进程</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE hSourceHandle,         <span class="comment">// 源内核对象的句柄，也就是欲共享的内核对象的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE hTargetProcessHandle,  <span class="comment">// 目的进程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    PHANDLE phTargetHandle,       <span class="comment">// 复制到目的进程句柄表中的内核对象句柄的地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwDesiredAccess,        <span class="comment">// 新句柄要求的安全访问级别。</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="comment">// 若dwOptions已指定了DUPLICATE_SAME_ACCESS，</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="comment">// 那么忽略这里的设置</span></span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL bInheritHandle,          <span class="comment">// 新句柄是否能hTargetProcessHandle的子进程继承</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwOptions               <span class="comment">// 复制方式，以下两种方式的任意组合：</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// 如果值为DUPLICATE_SAME_ACCESS，新句柄拥有与原始句柄相同安全访问特征</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// 如果值为DUPLICATE_CLOSE_SOURCE，关闭源进程中的句柄，</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// 该标识可以将一个内核对象传递给另外一个进程，即该内核对象的使用计数不会发生变化</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>可调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getcurrentprocess">GetCurrentProcess函数</a>获得当前进程句柄</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：Windows错误处理和字符串处理</title>
      <link href="/blogs/posts/windows/pc190bf13eb0d.html"/>
      <url>/blogs/posts/windows/pc190bf13eb0d.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="Windows错误处理"><a href="#Windows错误处理" class="headerlink" title="Windows错误处理"></a>Windows错误处理</h2><p>在Windows API 调用时，Windows会验证我们传入的参数是否有效，然后才会执行任务。下表为Windows大部分API函数返回值的意义。</p><table><thead><tr><th>返回值类型</th><th>返回值意义</th></tr></thead><tbody><tr><td>VOID</td><td>此函数不会调用失败，但只有极少数 Windows函数返回值类型为 VOID</td></tr><tr><td>BOOL</td><td>如果函数失败返回0，否则返回一个非零值。因此在判断API是否调用成功时，不应该判断返回值是否为 TRUE，而是判读是否为FALSE</td></tr><tr><td>HANDLE</td><td>如果函数调用失败，返回NULL或INVALID_HANDLE_VALUE，这取决于文档说明。否则返回一个可以操纵的对象</td></tr><tr><td>PVOID</td><td>失败返回NULL，否则返回一块内存地址</td></tr></tbody></table><p>Windows API是通过返回值来表明函数的调用成功情况的。当Windows返回错误代码时，我们就可以知道为什么函数调用失败。当Widnows检测到错误时，他会使用线程本地存储区(thread-local storage)的机制将发出调用的线程(calling thread)关联在一起，这种机制使得我们在不同的线程调用<a href="https://learn.microsoft.com/zh-CN/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError函数</a>时，都会得到相应的近期发生的错误结果，并且不会互相干扰。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetLastError</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>此函数返回上一个函数调用时设置的线程的32位错误代码。关于这32位的错误代码，我们可以在<code>WinError.h</code>头文件找到定义的相关错误代码列表。例如 ERROR_SUCCESS (调用成功时返回的错误码)，ERROR_INVALID_FUNCTION，ERROR_ACCESS_DENIED</p><p>在调用函数失败之后，应马上调用GetLastError，因为假如又调用了另一个Windows函数，这个值很可能会被改写，例如，成功调用Windows API的函数可能会用ERROR_SUCCESS改写。</p><p>我们可使用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-formatmessagew">FormatMessage函数</a> ，将错误代码格式化成一个字符串。</p><p>此外，我们可以使用Visual Studio的调试工具，在Watch窗口监测 <code>$err,hr</code>的值，可以看到调试过程中WindowsAPI的调用情况</p><p><img src="https://s1.ax1x.com/2023/03/05/ppEDtG6.png"></p><p>Visual Studio还提供了很多小工具。其中Error Lookup，它可以将错误代码转成相应文本描述</p><p>Error Lookup工具界面</p><p><img src="https://s1.ax1x.com/2023/03/05/ppEDYPx.png"></p><p>在这里可以找到这些小工具</p><p><img src="https://s1.ax1x.com/2023/03/05/ppEDNRK.png"></p><p>我们可以调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError函数</a> ，来设置错误信息。然后使自己的函数返回FALSE,NULL或其他值来表示错误。这样我们就可以封装自己的类似Windows风格的API</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">SetLastError</span><span class="params">(DWORD dwErrCode)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Windows字符串处理"><a href="#Windows字符串处理" class="headerlink" title="Windows字符串处理"></a>Windows字符串处理</h2><p>字符串处理是编程中必然会遇到的问题。随着Microsoft Windows在世界各地的流行，微软已逐步将眼光投入国际市场。缓冲区溢出错误（这是处理字符串的典型错误），已成为针对应用程序乃至整个操作系统组件发起攻击的媒介，微软不断从内部和外部主动出击，提高Windows的安全水平。</p><p>我们知道，C&#x2F;C++用char数据类型来表示一个8位的ANSI字符（不一定是ASCII字符）。微软的编译器早期定义了一个内建的数据类型wchar_t（早期被定义为unsigned short，现在已成为基本数据类型），现在wchar_t用来表示UNICODE字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明ANSI字符和ANSI字符串方式如下</span></span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cstr = <span class="string">&quot;ccc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明Unicode字符和字符串方式如下：</span></span><br><span class="line"><span class="type">wchar_t</span> wc = <span class="string">L&#x27;c&#x27;</span>; <span class="comment">// 注意，使用了前缀L</span></span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* wcstr = <span class="string">L&quot;ccc&quot;</span>;</span><br></pre></td></tr></table></figure><p>前缀L表示此字符或字符串应该被编译成Unicode字符。为了与C语言进行区分，Windows开发团队在WinNT.h中定义了该数据类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> CHAR; <span class="comment">// An 8-bit character</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">wchar_t</span> WCHAR; <span class="comment">// A 16-bit character</span></span><br></pre></td></tr></table></figure><p>因而，在Windows开发时，我们应多使用Windows基本数据类型。</p><p>在之前的探索中我们知道，在CreateWindowEx函数调用过程中，会根据当前程序使用的字符集，来选择调用的版本是CreateWindowExA还是CreateWindowExW。我们那个时候是直接使用TEXT宏来让编译器自动帮我们把字符串转成调用相应版本时的字符串相应类型。</p><p>自Windows NT起，Windows所有版本都使用Unicode构建。也就是说，所有核心函数都使用Unicode字符串，不使用ANSI字符串。因而，Windows的API在处理ANSI字符串时，都会将其转成Unicode字符串，因此使用ANSI字符串时，应用程序会需要更多内存，运行速度较慢。为了更高效的应用程序，我们可一开始就使用Unicode字符串。</p><p>C运行库中，有很多处理Unicode字符和ANSI字符的函数。例如使用strlen获得ANSI字符串的长度，wstrlen获得Unicode字符串的长度，_tcslen获得tchar类型的字符串长度。这些函数都存在一个特点，没有提供缓冲区的长度，导致他们并不知道会不会破坏内存。上文已经提到过相关内容，因而现在使用Visual C++时，微软的编译器都会告诉你要使用安全版本的C运行库字符串处理函数（带_s后缀的），这些函数都会带一个缓冲区大小的参数。<strong>在调用这些安全的函数时我们应该使用 _countof（stdlib.h中定义此宏） 来计算缓冲区大小，而不是使用sizeof。</strong> 我们可包含strsafe.h头文件，获得更多的字符串处理函数，包含strsafe.h会自动包含string.h</p><p>此外，C运行库中新添加了一些函数，用于在执行字符串处理中获得更多控制。如<a href="https://learn.microsoft.com/en-us/windows/win32/api/strsafe/nf-strsafe-stringcchcata">StringCchCat</a>, <a href="https://learn.microsoft.com/en-us/windows/win32/api/strsafe/nf-strsafe-stringcbcopya">StringCchCopy</a>, <a href="https://learn.microsoft.com/en-us/windows/win32/api/strsafe/nf-strsafe-stringcbprintf_la">StringCchPrintf</a>。Cch的意思是count of character(字符个数),使用_countof计算此值。所有这些函数的返回值返回HRESULT，当返回S_OK时，函数成功执行；返回STRSAFE_E_INVALID_PARAMETER时，函数执行失败，原因是传参数NULL；返回STRSAFE_E_INSUFFICIENT_BUFFER时，函数执行失败，原因是缓冲区不够大。</p><p>Windows也提供了各种字符串处理函数，在ShlwApi.h提供了大量好用的字符串处理函数。<br>如<a href="https://learn.microsoft.com/en-us/windows/win32/api/winnls/nf-winnls-comparestring">CompareString</a>此函数用来按语言习惯来比较字符串，<a href="https://learn.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-comparestringordinal">CompareStringOridinal</a>不按语言习惯比较字符串，但是更快</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CompareString</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   LCID    Locale,         <span class="comment">// 区域设置ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">   DWORD   dwCmpFlags,     <span class="comment">// 比较字符串方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">   LPCTSTR lpString1,      <span class="comment">// 比较的字符串1</span></span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">int</span>     cchCount1,      <span class="comment">// 字符串1长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">   LPCTSTR lpString2,      <span class="comment">// 比较的字符串2</span></span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">int</span>     cchCount2       <span class="comment">// 字符串2长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>我们可通过<a href="https://learn.microsoft.com/en-us/windows/win32/api/winnls/nf-winnls-getthreadlocale">GetThreadId 函数得到当前线程的LCID</a>。</p><p>这两个函数返回值与C语言的字符串处理函数有所不同，返回0表示失败，返回CSTR_LESS_THAN（定义为1）指示lpString1小于lpString2，返回CSTR_EQUAL（定义为2）指示lpString1与lpString2相等，返回CSTR_GREATER_THAN（定义为3）指示lpString1大于lpString2。为了稍微方便些，如果函数成功，可以用返回值减去2，来使结果与C运行期库函数的返回值一致（-1，0和+1）。</p><p>我们使用<a href="https://learn.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-multibytetowidechar">MultiByteToWideChar</a>将多字节字符串转换成宽字节字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MultiByteToWideChar</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT   uCodePage,        <span class="comment">// 字符转换方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  dwFlags,          <span class="comment">// 对无效字符的处理方式等，一般传0</span></span></span></span><br><span class="line"><span class="params"><span class="function">    PCSTR  pMultiByteStr,    <span class="comment">// 要转换的字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>    cbMultiByte,      <span class="comment">// 要转换的字符串长度，传-1表示全部都转换</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPWSTR lpWideCharStr,    <span class="comment">// 存放转换后的字符串的缓冲区，</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="comment">// 如果为NULL表示只计算转换后字符串的长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="comment">// 此时返回的长度包括字符串终止符</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>    cchWideChar       <span class="comment">// 缓冲区大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>因而，我们一般先调用一次MultiByteToWideChar函数计算转换后的字符串长度，然后分配足够的缓冲区存放转换后的字符串，缓冲区大小为调用此函数的返回值*sizeof(wchar_t)，然后再调用一次MultiByteToWideChar来存放字符串。</p><p>与之对应的是<a href="https://learn.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-widechartomultibyte">WideByteToMultiByte</a>将宽字节字符串转换为多字节字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WideCharToMultiByte</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT   uCodePage,         <span class="comment">// 字符转换方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  dwFlags,           <span class="comment">// 对无效字符的处理方式等，一般传0</span></span></span></span><br><span class="line"><span class="params"><span class="function">    PCWSTR lpWideCharStr,     <span class="comment">// 要转换的字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>    cchWideChar,       <span class="comment">// 要转换的字符串长度，传-1表示全部都转换</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR  lpMultiByteStr,    <span class="comment">// 存放转换后的字符串的缓冲区，</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="comment">// 为NULL表示计算钻换后字符串长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>    cbMultiByte,       <span class="comment">// 缓冲区大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCCH  lpDefaultChar,     <span class="comment">// 当遇到字符不能转换时，使用它指向的字符串，</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="comment">// 如为NULL使用系统默认的，系统默认一般为问号</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPBOOL lpUsedDefaultChar  <span class="comment">// 如果每个字符都能转换，它指向的BOOL变量值为FALSE，</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="comment">// 否则为TRUE，通常我们传NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以使用<a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-istextunicode">IsTextUnicode函数</a>来猜测目标文本是否是Unicode字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">IsTextUnicode</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> VOID *lpv,      <span class="comment">// 存放目标文本的缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span>        iSize,     <span class="comment">// 缓冲区大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPINT      lpiResult  <span class="comment">// 猜测方式，一般传NULL，它将尝试可以的每一个预测</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>当然此结果不一定准确。</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的简单使用</title>
      <link href="/blogs/posts/web/vue/pe9819f82c9f9.html"/>
      <url>/blogs/posts/web/vue/pe9819f82c9f9.html</url>
      
        <content type="html"><![CDATA[<p>Vue (发音为 &#x2F;vjuː&#x2F;，类似 view) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。</p><p>Vue 的特色</p><ul><li><p>易学易用<br>基于标准 HTML、CSS 和 JavaScript 构建，提供容易上手的 API 和一流的文档。</p></li><li><p>性能出色<br>经过编译器优化、完全响应式的渲染系统，几乎不需要手动优化。</p></li><li><p>灵活多变<br>丰富的、可渐进式集成的生态系统，可以根据应用规模在库和框架间切换自如。</p></li></ul><h2 id="书写第一个vue程序"><a href="#书写第一个vue程序" class="headerlink" title="书写第一个vue程序"></a>书写第一个vue程序</h2><p>为了使用vue，我们可以选择下载vue.js文件，然后用script标签引入，也可以使用现成的CDN</p><p>vue目前有Vue2，和Vue3两个大版本。vue2与vue3基本没有什么太大的变化，可放心使用。</p><blockquote><p>Vue2</p><p><a href="https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js">https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js</a></p><p><a href="https://cdn.staticfile.org/vue/2.2.2/vue.min.js">https://cdn.staticfile.org/vue/2.2.2/vue.min.js</a></p><p><a href="https://unpkg.com/vue@2.6.14/dist/vue.min.js">https://unpkg.com/vue@2.6.14/dist/vue.min.js</a></p><p>Vue3</p><p><a href="https://cdn.staticfile.org/vue/3.0.5/vue.global.js">https://cdn.staticfile.org/vue/3.0.5/vue.global.js</a></p><p><a href="https://unpkg.com/vue@next">https://unpkg.com/vue@next</a></p><p><a href="https://cdnjs.cloudflare.com/ajax/libs/vue/3.0.5/vue.global.js">https://cdnjs.cloudflare.com/ajax/libs/vue/3.0.5/vue.global.js</a></p></blockquote><p>本文使用Vue3</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> programming </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象知识点总结</title>
      <link href="/blogs/posts/cplusplus/p46f9f8da9911.html"/>
      <url>/blogs/posts/cplusplus/p46f9f8da9911.html</url>
      
        <content type="html"><![CDATA[<p>本文记录了C++面向对象的相关知识点。</p><h2 id="面向对象初识"><a href="#面向对象初识" class="headerlink" title="面向对象初识"></a>面向对象初识</h2><h3 id="何为面向对象"><a href="#何为面向对象" class="headerlink" title="何为面向对象"></a>何为面向对象</h3><p>面向过程(Procedure Oriented)：在解决一个问题时，<strong>将过程拆分为解决事情的步骤，然后按一定的顺序执行这些步骤</strong>，然后解决问题。优点是性能相对面向对象高，因为对象需要构建，开销比较大。缺点是不易维护。</p><p>面向对象(Object Oriented)：在解决一个问题时，<strong>面向对象会将事物抽象成对象的概念，看此问题有哪些对象，这些对象会有什么行为，什么属性，让每个对象执行自己的行为</strong>，然后解决问题。优点是易维护易复用易拓展，缺点是性能比面向过程低，但也不会非常低。<strong>对象的行为和属性称为对象的成员</strong>。</p><p>什么是对象，例如人，手机，是对象<br>什么是行为，例如走路，跑步，转身<br>什么是属性，例如人的年龄，手机的电量，人的身高</p><p><strong>具有相同行为，属性的对象组成的集合叫做类</strong>。</p><blockquote><p>参考案例：用圆规画圆<br>面向过程：拿出圆规，修改圆规半径，旋转圆规，结束<br>面向对象：圆规创建，圆规.调整自身大小行为，圆规.旋转行为，结束。</p></blockquote><blockquote><p>参考案例：洗衣服<br>面向过程：把衣服放入洗衣机，设置洗衣时间，设置洗衣模式，开启洗衣机，结束<br>面向对象：构造圆规，洗衣机.放入衣服， 洗衣机.设置时间， 洗衣机.设置模式， 洗衣机.运行， 结束</p></blockquote><p>在C++，面向对象世界有三大特征：<strong>封装，继承，多态</strong>。</p><h3 id="C-面向对象的基本使用"><a href="#C-面向对象的基本使用" class="headerlink" title="C++面向对象的基本使用"></a>C++面向对象的基本使用</h3><p>要创建一个对象，我们需要先实现一个类，武器 吗，。在C++类我们可以使用<code>class</code>关键字声明。注意是<strong>可以</strong>，也就是说，可以使用别的关键字声明。在文章后面的内容讲述了用union,class,struct定义类时的效果细微差别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 声明对象行为和属性的代码 */</span></span><br><span class="line">&#125;;  <span class="comment">// 注意需要分号结尾</span></span><br></pre></td></tr></table></figure><p>如下列示例代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明对象的行为如 展示自己的名字</span></span><br><span class="line">    <span class="comment">// 对象的行为写法就如函数的写法一样</span></span><br><span class="line">    <span class="comment">// 因此这被称作 成员函数 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show_name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我叫&quot;</span> &lt;&lt; m_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明对象拥有的属性如 名字name, 年龄age</span></span><br><span class="line">    <span class="comment">// 对象的属性被称为 成员变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p; <span class="comment">// 创建对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给对象相应属性赋值， 用 对象.属性 的方式改值</span></span><br><span class="line">    p.m_name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    p.m_age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让对象执行对象的行为，用 对象.行为()  </span></span><br><span class="line">    p.<span class="built_in">show_name</span>();</span><br><span class="line">    <span class="comment">// 访问对象的年龄</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;我的年龄&quot;</span> &lt;&lt; p.m_age &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果:<br>我叫张三<br>我的年龄18</p></blockquote><p><strong>创建一个对象的过程叫做实例化，一个对象为该类的一个实例</strong>。</p><h2 id="面向对象：封装"><a href="#面向对象：封装" class="headerlink" title="面向对象：封装"></a>面向对象：封装</h2><p>我们可以使用访问权限控制符来限制对象行为和属性是否能被外界访问。我么可以使用 <code>public</code>, <code>protected</code>, <code>private</code> 三个关键字来限制访问权限。如不使用这些关键字，在用class声明的类里默认使用private</p><p><code>public</code> 表示外界可以访问<br><code>protected</code> 和 <code>private</code>都表示外界不可以访问，但是<code>protected</code> 属性在被继承后，仍可以被子类访问，但<code>private</code> 修饰的，就不行。</p><p>但无论用哪种修饰符，类内都可以正常访问这些行为。可以多次使用这些修饰符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我已经&quot;</span> &lt;&lt; m_age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用private限制外界访问</span></span><br><span class="line">    <span class="type">double</span> m_eyesight;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//p.m_name = &quot;张三&quot;; // 错误，外界不可以访问private修饰的属性</span></span><br><span class="line">    p.m_eyesight = <span class="number">5.0</span>; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">show_age</span>(); </span><br><span class="line">    <span class="comment">// 正确，但结果不确定</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们尽量给对象的属性设置非public的权限防止用户直接修改我们类的属性，避免异常。然后，提供public属性的其他成员函数来替代操作对象的属性。这即为封装的意义</p><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><p>生活中，不用的东西我们都会尽量消除与自己个人信息相关的地方，也就是保护隐私。例如扔硬盘时，我们会尽量粉碎硬盘，删除相关的个人信息。公司的一些文件，销毁时使用碎纸机，尽量销毁相关信息。</p><p>因而构造函数和析构函数是帮助我们处理构造对象和销毁对象的相关工作。<strong>在栈区的对象，其构造和析构的工作由编译器保证正常完成。</strong></p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>语法如下（注：成员函数也是可以重载的）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">    类名(<span class="comment">/*参数列表*/</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 构造对象的相关工作 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~类名()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 销毁对象的相关工作 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>构造函数和析构函数没有返回值，但是不写void，函数名与类名同名，但不能使用const, virtual修饰函数。<br>析构函数不能有参数，因而析构函数不可以重载，但是构造函数可以重载，但不能使用const修饰函数。</p><p>构造函数和析构函数将分别在构造对象和销毁对象的时候自动执行，编译器保证肯定会执行。当对象生命周期结束时，对象会被析构。但是构造函数和析构函数应使用public的访问权限，要不然编译器无法构造和析构对象。在单例模式中我们将了解到限制实例化对象的方式。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Object</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;对象被析构\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;对象被构建\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Object o1;</span><br><span class="line">    Object o2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>对象被构建<br>对象被构建<br>对象被析构<br>对象被析构</p></blockquote><h4 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h4><p>对于任何类型的对象，离开自己的作用域后，就会被析构掉。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g_a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l_a;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时局部变量a已被析构掉</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test函数返回后，test函数的所有局部变量都会被析构掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l_a;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main函数返回后，main函数的所有局部变量都会被析构掉</span></span><br></pre></td></tr></table></figure><h4 id="构造函数的分类"><a href="#构造函数的分类" class="headerlink" title="构造函数的分类"></a>构造函数的分类</h4><p>根据构造函数是否有参数，可分为：无参构造函数，有参构造函数<br>根据构造函数的意义，可分为：默认构造函数（没有参数的构造函数，也可称作缺省构造函数），复制构造函数（对象拷贝的构造函数，也可称作拷贝构造函数），移动构造函数（对象资源移动所有权时的构造函数，这是C++11语法）</p><p>下面是一些示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Object</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;对象被析构\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现默认构造函数</span></span><br><span class="line">    <span class="built_in">Object</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_val = <span class="number">0</span>;  <span class="comment">// 在构造函数中，给成员属性赋值</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;默认构造函数\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现有参构造函数</span></span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">int</span> val)</span><br><span class="line">    &#123;</span><br><span class="line">        m_val = val;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;有参构造函数\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现拷贝构造函数</span></span><br><span class="line">    <span class="comment">// 拷贝构造函数的参数类型是 const 类型名&amp;</span></span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">const</span> Object&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        m_val = obj.m_val;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;拷贝构造函数\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show_val</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;val: &quot;</span> &lt;&lt; m_val &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Object o1;</span><br><span class="line">    <span class="function">Object <span class="title">o2</span><span class="params">(<span class="number">3</span>)</span></span>;  <span class="comment">// 调用有参构造函数</span></span><br><span class="line">    <span class="function">Object <span class="title">o3</span><span class="params">(o1)</span></span>; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Object 对象(参数) 来调用构造函数</span></span><br><span class="line">    <span class="comment">// Object 对象;  调用的是默认构造函数，</span></span><br><span class="line">    <span class="comment">// 不使用Object xxx()  来调用默认函数初始化对象</span></span><br><span class="line">    <span class="comment">// 因为这会被当做函数的声明：返回值类型 Object， 函数名 xxx ，参数列表 (void)</span></span><br><span class="line"></span><br><span class="line">    o1.<span class="built_in">show_val</span>();</span><br><span class="line">    o2.<span class="built_in">show_val</span>();</span><br><span class="line">    o3.<span class="built_in">show_val</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>默认构造函数<br>有参构造函数<br>拷贝构造函数<br>val: 0<br>val: 3<br>val: 0<br>对象被析构<br>对象被析构<br>对象被析构</p></blockquote><h4 id="默认提供的构造函数"><a href="#默认提供的构造函数" class="headerlink" title="默认提供的构造函数"></a>默认提供的构造函数</h4><p>如果你不实现构造函数，编译器会实现默认的。如果你实现了默认构造函数，那么编译器还会提供默认实现的拷贝构造函数。如果你实现了一个带参数的构造函数，但不是拷贝构造函数，编译器不提供默认构造函数，但仍会提供默认的拷贝构造函数。如果你实现了一个拷贝构造函数，那么编译器不再提供默认实现的构造函数。</p><p>默认提供的拷贝构造函数，会将自身的每个属性从一遍逐个字节拷贝到另一个对象。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_val;</span><br><span class="line">    <span class="type">int</span>* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">int</span> val, <span class="type">int</span>* ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        m_val = val;</span><br><span class="line">        m_ptr = ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;val: &quot;</span> &lt;&lt; m_val &lt;&lt; <span class="string">&quot;ptr: &quot;</span> &lt;&lt; m_ptr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="function">Object <span class="title">o1</span><span class="params">(<span class="number">5</span>, p)</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">o2</span><span class="params">(<span class="number">5</span>, p)</span></span>;</span><br><span class="line">    o1.<span class="built_in">show</span>();</span><br><span class="line">    o2.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行此段代码，可以看到打印o1,o2的值完全一致。</p><p>但是如果我们改成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 想法：Object对象将管控堆区的数据，对象析构时将销毁相应数据</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Object</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 释放堆区的数据</span></span><br><span class="line">        <span class="keyword">if</span> (m_ptr != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_ptr;</span><br><span class="line">            m_ptr = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">int</span>* ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ptr = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">o1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">o2</span><span class="params">(o1)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，会发现出错，原因是重复释放堆区的内存。o2被析构时，o2的m_ptr指向的堆区内存被释放。o1析构时，由于o1和o2的m_ptr都指向同一块堆区内存，因为这是默认提供的构造函数造成的，o1又释放了一遍，因此代码出错了。</p><p>编译器默认提供的拷贝构造函数叫做浅拷贝，<strong>浅拷贝会会将自身的每个属性从一遍逐个字节拷贝到另一个对象</strong>。为了避免浅拷贝的危害，对于储存堆区数据的类，我们需要实现深拷贝。<strong>深拷贝即为，再开辟一块新的内存空间，拷贝原先数据到新的数据那里，而不是直接拷贝。</strong></p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Object</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 释放堆区的数据</span></span><br><span class="line">        <span class="keyword">if</span> (m_ptr != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_ptr;</span><br><span class="line">            m_ptr = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">int</span>* ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ptr = ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝的示例</span></span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">const</span> Object&amp; left)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 分配一个新的内存空间，然后再拷贝</span></span><br><span class="line">        m_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(*left.m_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">o1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">o2</span><span class="params">(o1)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>我们使用初始化列表，可以更高效地初始化类的相关属性</p><p>语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">    类名() : 属性值<span class="number">1</span>(构造需要的参数列表<span class="number">1</span>), 属性值<span class="number">2</span>(构造需要的参数列表<span class="number">2</span>) ... </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">O</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val1;</span><br><span class="line">    <span class="type">int</span> val2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">O</span>(<span class="type">int</span> val) : <span class="built_in">val2</span>(), <span class="built_in">val1</span>(val)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于初始化列表的成员初始化顺序，并不是按初始化列表书写顺序初始化的</span></span><br><span class="line">    <span class="comment">// 例如上面这个案例，并不是先初始化val2，然后初始val1</span></span><br><span class="line">    <span class="comment">// 而是按照类的成员的声明顺序初始化，</span></span><br><span class="line">    <span class="comment">// 例如这个案列，val1在val2之前声明，因此先初始化val1，然后val2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用初始化列表初始化对象，对象的属性会被正确的初始化，写起来比较直观。对于类内的引用类型，const类型的非静态成员变量，只能使用初始化列表来初始化这些对象。</p><h4 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h4><p>使用 <code>对象名(参数)</code> 可以构造一个匿名对象，匿名对象由于没有名字，构造之后会被马上销毁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">O</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">O</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;析构函数调用\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">O</span>(<span class="type">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;构造函数调用\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">O</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>构造函数调用<br>析构函数调用</p></blockquote><p>匿名对象在之后的swap函数实现非常有用。</p><p>总之，对象的构建顺序是，先分配内存给对象，然后对象调用构造函数，对象的析构顺序是，先调用析构函数，再回收对象占用的内存空间。</p><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>一个类的所有实例都能共享的成员变量或成员函数，称为静态成员。</p><p>静态成员变量特征：所有实例共享，编译阶段分配内存，类内声明类外初始化。</p><p>静态成员函数特征：静态成员函数只能访问静态成员变量，原因是静态成员函数没有this指针（下方内容提到了this指针的概念）</p><p>访问静态成员的方式：</p><ol><li>类名::静态成员</li><li>先创建一个对象，然后 对象.静态成员 来访问</li></ol><p>静态成员在某种意义上可以看成是只属于这个类的全局函数或全局变量，但是可以通过访问权限来限制外界访问这个静态成员。因此只有静态成员声明为public时，外界可以访问。</p><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;do_something\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须要对静态成员变量初始化，</span></span><br><span class="line"><span class="comment">// 因为编译器要编译阶段给他分配内存</span></span><br><span class="line"><span class="comment">// 如果不初始化，编译器没有办法给他分配默认值</span></span><br><span class="line"><span class="comment">// 这个步骤因此是必须要做的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方式   类型名 类名::静态成员变量名 = 值;</span></span><br><span class="line"><span class="type">int</span> MyClass::value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问静态成员变量的一种方式</span></span><br><span class="line">    MyClass::value;  </span><br><span class="line">    <span class="comment">// 第二种方式，一般用第一种</span></span><br><span class="line">    c.value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-对象模型初步探索和this指针"><a href="#C-对象模型初步探索和this指针" class="headerlink" title="C++对象模型初步探索和this指针"></a>C++对象模型初步探索和this指针</h3><p>C++在设计类时，经过了努力有了现在的对象模型。最终，C++标准规定，一个类如果什么成员变量都没有，即空类占1字节。只有成员变量储存在对象身上，其他的成员函数不储存在对象身上。</p><p>那么现在出现了一个问题，所有对象都调用同一个成员函数。成员函数是如何区分是哪个对象调用的成员函数呢？C++通过使用特殊的指针，this指针来解决这个问题。在调用成员函数时，编译器会隐含传入this指针，哪个对象调用的成员函数，this指针就指向谁。<strong>this指针不需要自己声明</strong>，因为编译器在默默帮助你。</p><p>this指针的用途：</p><ol><li>使用this指针解决冲突。当函数形参或局部变量与类成员变量重名时，会产生名字冲突。</li><li>返回指向自身的地址或引用。再之后的高深技术学习中，我们可以运用this指针防止自己给自己赋值，实现累加操作等。</li></ol><p>this指针的实质是指针常量，指针的指向是不可修改的。相当于<code>类名 const * this;</code></p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">int</span> val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//val = val; </span></span><br><span class="line">        <span class="comment">// 上面的val会被认为是函数形参val，而不是成员变量val</span></span><br><span class="line">        <span class="comment">// 自己给自己赋值是没什么意义的</span></span><br><span class="line">        <span class="comment">// 要想解决这个问题，使用this指针，如下：</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">        <span class="comment">// 这样即可成功赋值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">talk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 默认情况下，这都会被看成是 this-&gt;val，因为这个类有名为val的成员</span></span><br><span class="line">        <span class="comment">// 因此，不需要频繁的使用this指针</span></span><br><span class="line">        <span class="comment">// 一般推荐在属性名前使用 m_ 前缀来表明此变量为成员变量</span></span><br><span class="line">        val; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//this = NULL;</span></span><br><span class="line">        <span class="comment">// 错误，this指针的指向是不可修改的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object&amp; <span class="title">add_val</span><span class="params">(<span class="type">const</span> Object&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val += obj.val; </span><br><span class="line">        <span class="comment">// 返回自身引用</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">o1</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">o2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过不断返回自身引用，就可以一直调用add_val</span></span><br><span class="line">    <span class="comment">// 这种编程思想称为链式编程</span></span><br><span class="line">    o1.<span class="built_in">add_val</span>(o2).<span class="built_in">add_val</span>(o1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空指针或野指针调用成员函数"><a href="#空指针或野指针调用成员函数" class="headerlink" title="空指针或野指针调用成员函数"></a>空指针或野指针调用成员函数</h3><p>空指针或野指针也是可以调用成员函数的，因为编译器不限制。这种方式调用时，在运行时，可能会出错，也可能不会。出错的时候，可能是因为使用了this指针.</p><p>空指针：指向地址0的指针<br>野指针：指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show_class</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show_val</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Object *p = <span class="literal">NULL</span>;</span><br><span class="line">    p.<span class="built_in">show_class</span>(); <span class="comment">// 成功调用</span></span><br><span class="line">    p.<span class="built_in">show_val</span>();   <span class="comment">// 调用出错，原因是this为空指针，尝试访问空指针是非法的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们为了使show_val成员函数仍正常输出，使用如下措施保证其不报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改show_val函数保证正常输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_val</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 仅能预防空指针调用时的报错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>我们可以重载一些运算符，使他们为我们所用。我们可以重载大多数C++运算符。<br>特别地，对于像++运算符，有前置和后置两种形式，对于前置的++运算符，我们重载时需要添加一个int类型的站位参数来区分。</p><p>在类内部使用运算符重载方式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数返回值  <span class="keyword">operator</span>运算符 (参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    MyClass <span class="keyword">operator</span>+(<span class="type">const</span> MyClass &amp;left)</span><br><span class="line">    &#123;</span><br><span class="line">        MyClass ret;</span><br><span class="line">        ret.val = val + left.val;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">// 也可以以这种形式重载operator +运算符，效果完全相同</span></span><br><span class="line"><span class="comment">MyClass operator+(const MyClass &amp;p1, cosnt MyClass &amp;p2)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    MyClass ret;</span></span><br><span class="line"><span class="comment">    ret.val = p1.val + p2.val;</span></span><br><span class="line"><span class="comment">    return ret;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass c1;</span><br><span class="line">    MyClass c2;</span><br><span class="line">    c1.val = <span class="number">1</span>;</span><br><span class="line">    c2.val = <span class="number">2</span>;</span><br><span class="line">    std::cout &lt;&lt; (c1 + c2).val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际上，调用运算符也是在调用函数，因此我们也可以像这样的形式调用运算符</span></span><br><span class="line">    c1.<span class="keyword">operator</span>+(c2);   <span class="comment">// 这表示调用 + 运算符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个类重载了小括号运算符时，这个类通常被称为仿函数，因为小括号和函数调用运算符很像，并且也有类似的行为。</p><p>如果我们想要自己的类型可以任意的转换，我们可以定义类型转换函数，下面是在类内部定义类型转换函数方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> 将转换的类型()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">/*...*/</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPointer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* m_src;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyPointer</span>(<span class="type">void</span>* src) : <span class="built_in">m_src</span>(src)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_src != <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyPointer p1 = (<span class="type">void</span>*)<span class="literal">NULL</span>;</span><br><span class="line">    MyPointer p2 = (<span class="type">void</span>*)&amp;p1;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; (<span class="type">bool</span>)p1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (<span class="type">bool</span>)p2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果: false true</p><h3 id="成员常量和常函数"><a href="#成员常量和常函数" class="headerlink" title="成员常量和常函数"></a>成员常量和常函数</h3><p>成员常量是不可修改的，如果想要初始化成员常量，<strong>需要用初始化列表初始化</strong>。</p><p>成员函数用const修饰之后被称作常函数，常函数不可以修改成员属性，但是如果给成员属性用mutable关键字，常函数中仍可以修改</p><p>声明对象时用const，此对象被称为常对象，常对象只能调常函数，此时this指针的意义即为 <code>const 类型名 const * this;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> prize;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> id; <span class="comment">// 成员常量</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">const</span> <span class="type">int</span> age; <span class="comment">// 声明可以被常函数改值的成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">id</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">not_const_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常函数的const写在这个位置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">const_func</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//prize = 6; // 错误，不可以改这个值</span></span><br><span class="line">        <span class="comment">//id = 5; // 也不可以改</span></span><br><span class="line">        age = <span class="number">-6</span>; <span class="comment">// 可以改，因为用mutable修饰</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass c1;</span><br><span class="line">    <span class="type">const</span> MyClass c2;  <span class="comment">// 常对象</span></span><br><span class="line"></span><br><span class="line">    c2.<span class="built_in">const_func</span>(); <span class="comment">// 成功调用</span></span><br><span class="line">    <span class="comment">//c2.not_const_func(); // 调用失败，尽管not_const_func成员函数没有使用任何成员变量和成员常量，由于他不用const修饰，也是不可以调用成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>有时我们希望全局函数，其他类，或其他类的成员函数也可以访问我们的非public权限的成员，我们应该怎么做呢？答案是使用友元。友元，使用friend关键字，friend即朋友的意思。</p><p>友元的三种方式：</p><ul><li>全局函数做友元</li><li>成员函数做友元</li><li>类做友元</li></ul><p>友元案例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MidClass</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_val;</span><br><span class="line">    <span class="comment">// 1. 全局函数做友元</span></span><br><span class="line">    <span class="comment">// 声明全局函数的友元，声明全局函数 friend_func可以访问MyClass的私有成员</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">friend_func</span><span class="params">(MyClass*)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成为友元的全局函数可以在类内实现，也可以在类外实现，类内实现，只需像下方被注释的代码一样</span></span><br><span class="line">    <span class="comment">// friend void friend_func(MyClass* p)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     p-&gt;val = 0;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 成员函数做友元</span></span><br><span class="line">    <span class="comment">// 声明 void MidClass::read_some函数为友元，此函数就可以访问MyClass的私有属性，但MidClass的其他成员函数仍然不可以访问</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">MidClass::read_some</span><span class="params">(MyClass*)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 类做友元</span></span><br><span class="line">    <span class="comment">// 声明 FriendClass 作为友元， FriendClass 可以访问MyClass类的所有属性，相比成员函数做友元，这个权限更高</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">FriendClass</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局友元函数类外实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">friend_func</span><span class="params">(MyClass* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;val = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MidClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read_all</span><span class="params">(MyClass* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//p-&gt;val = 6; // 错误，此成员函数不是MyClass的友元</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">real_some</span><span class="params">(MyClass* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p-&gt;val = <span class="number">0</span>; <span class="comment">// 正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 正确的代码，FriendClass是MyClass的友元</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read_all</span><span class="params">(MyClass* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p-&gt;val = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">real_some</span><span class="params">(MyClass* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p-&gt;val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向对象：继承"><a href="#面向对象：继承" class="headerlink" title="面向对象：继承"></a>面向对象：继承</h2><h3 id="继承初步"><a href="#继承初步" class="headerlink" title="继承初步"></a>继承初步</h3><p>看这个网页<a href="%E7%82%B9%E6%88%91%E6%9F%A5%E7%9C%8B">https://ustarry.github.io/</a>，我们可以看到，在这个网页的 首页，领地，工具这些页面中，都有相同的标题栏，但是网页的内容不同。</p><p><img src="https://s1.ax1x.com/2023/02/26/pppwGvV.png"><br><img src="https://s1.ax1x.com/2023/02/26/pppcUhD.png"><br><img src="https://s1.ax1x.com/2023/02/26/pppwNbF.png"></p><p>像这样，我们可以通过<strong>继承的方式，让一个类继承一个类，继承后的类拥有原先类的所有行为，但可以有自己独特的行为</strong>，这样可以减少代码量，这就是继承的优势</p><p>如果类B继承类A，那么B叫做子类，A叫做基类。继承语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 子类名 : 继承方式 基类</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 子类的代码 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>继承方式有<code>public</code>, <code>protected</code>, <code>private</code>三种，如果不指定继承方式，在继承用class声明的类时默认使用private。使用public方式，父类的public属性的仍然在子类表现为public，protected也表现为public，private属性不可以访问<br>用protected方式，父类的public属性在子类表现为protected，protected属性表现为private，private属性的直接不可访问<br>用private方式，父类的public属性变为private，父类的其他属性再也不可以访问</p><p>例如上面的案例，我们就可以通过继承来减少代码：<br>这是不用继承的实现方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;星光工作室的网页&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;首页&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZonePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;星光工作室的网页&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;领域&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ToolPage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;星光工作室的网页&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;工具&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用继承之后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;星光工作室的网页&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomePage</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;首页&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZonePage</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;领域&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ToolPage</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;工具&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种代码效果等价，但是很明显第二种代码更少。这即为继承的优势</p><h3 id="继承的父类子类构造顺序和多继承"><a href="#继承的父类子类构造顺序和多继承" class="headerlink" title="继承的父类子类构造顺序和多继承"></a>继承的父类子类构造顺序和多继承</h3><p>继承之后，是先构建父类还是先构建子类呢？直接说结论，先构建父类，再构建子类。析构的时候，先析构子类，再析构父类。</p><p>C++允许一个类继承多个类，多继承语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 子类: 继承方式<span class="number">1</span> 父类<span class="number">1</span>， 继承方式<span class="number">2</span> 父类<span class="number">2</span> ...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 代码 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果父类和子类在某些成员上重名了，那么默认使用子类的属性，如果一定要使用父类的成员，使用 :: （作用域运算符） 强制使用父类的成员。</p><p>如，类Son是类Base的子类，这些类都定义了val属性。假设我们已经有了子类的一个实例叫做<code>obj</code>。如果我们想在子类访问子类的val属性，直接 <code>obj.val</code>，或使用作用域运算符<code>obj.Son::val</code>。用父类的属性，则必须<code>obj.Base::val</code></p><p>当然，作者不建议使用多继承。</p><h3 id="菱形继承和虚继承"><a href="#菱形继承和虚继承" class="headerlink" title="菱形继承和虚继承"></a>菱形继承和虚继承</h3><p>如果有类AA，BB，CC，DD，类AA有long long的，m_data1, m_data2，m_special属性。这时我们使BB继承了AA，CC继承AA，DD多继承BB和CC。像这样的继承，如果我们画出继承图像，图像看起来像菱形，因此这种继承方式被称为菱形继承，也称为钻石继承。我们来尝试输出D占的字节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_data1;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_data2;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_special;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> : <span class="keyword">public</span> AA&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CC</span> : <span class="keyword">public</span> AA&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DD</span> : <span class="keyword">public</span> BB, <span class="keyword">public</span> CC&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(DD) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们期望应该只占三个long long的和。然而，在作者的计算机处运行，结果居然占了48字节！</p><p><img src="https://s1.ax1x.com/2023/02/26/pppRtA0.png"></p><p>这是为什么呢？在这里我们可以使用MSVC的工具集来看一下这个类D在内存中的布局。</p><p>进入到存放此代码的目录，调出命令行，输入下方指令( <strong>注意是 d1不是 dl</strong>  )</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /d1 reportSingleClassLayoutDD test.cpp</span><br></pre></td></tr></table></figure><p>这段指令将查看test.cpp文件中类DD的内存布局模型，如果你想查看666.cpp文件中类Monster的内存布局模型，输入<code>cl /dl reportSingleClassLayoutMonster test.cpp</code></p><p>作者看到DD类的内存布局如下：</p><p><img src="https://s1.ax1x.com/2023/02/26/pppRUhT.png"></p><p>可以看到，如果像这种方式继承，我们浪费了很多字节。因为m_data1，m_data2，m_special本来就要一份就好，现在有这么多份。我们应该怎么做避免浪费呢？使用虚继承就可以了！看下列改进的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_data1;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_data2;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_special;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> AA&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CC</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> AA&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DD</span> : <span class="keyword">public</span> BB, <span class="keyword">public</span> CC&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(DD) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下这种状况下的内存布局，发现占用更少了！</p><p><img src="https://s1.ax1x.com/2023/02/26/pppRNNV.png"></p><p>原理到底是什么呢？原来，使用虚继承后，就<strong>改成继承 vbptr（virtual base pointer，虚基类指针）</strong>，而不是直接继承m_data1, m_data2, m_special。然后vbptr指向叫 <strong>vbtable(virtual base table虚基类表)</strong> 的东西，每一个进行虚继承的类，都会生成一个叫vbtable的表，这个表储存的是偏移量，这样就可以导致m_data1, m_data2, m_special只需要储存一份，BB,CC类使用vbptr指向的偏移量，偏移到储存m_data1, m_data2, m_special的位置就可以读取数据了，这样就形成了数据的共享，减少了占用。</p><p>当然并不推荐进行多继承，了解一下原理也是不错的。</p><h2 id="面向对象：多态"><a href="#面向对象：多态" class="headerlink" title="面向对象：多态"></a>面向对象：多态</h2><h3 id="多态认识"><a href="#多态认识" class="headerlink" title="多态认识"></a>多态认识</h3><p>多态，顾名思义，即为多种形态。多态可以分为静态多态和动态多态。</p><ul><li><p>静态多态：编译阶段确定调用函数的类型，即地址早绑定。例如函数的重载，运算符重载，模板(如CRTP技术)</p></li><li><p>动态多态：运行时才确定函数的类型，即地址晚绑定</p></li></ul><p>来看下列代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base\n&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Son1\n&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Son2\n&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_say</span><span class="params">(Base* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;<span class="built_in">say</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base s1;</span><br><span class="line">    Son1 s2;</span><br><span class="line">    Son2 s3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在存在一个问题，下面将调用的是son1::say函数还是base::say函数，</span></span><br><span class="line">    <span class="comment">// 还是son2::say函数，还是都有？</span></span><br><span class="line">    <span class="built_in">to_say</span>(&amp;s1);</span><br><span class="line">    <span class="built_in">to_say</span>(&amp;s2);</span><br><span class="line">    <span class="built_in">to_say</span>(&amp;s3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题似乎非常难解决。但是我们应该考虑到，但凭一个地址没有办法分辨是哪个类型的对象调用的say函数，<code>void to_say(Base*)</code>函数定义参数类型为Base*，因而，都调用的是<code>Base::say</code>函数。</p><p>但是，如果我们想传入哪个类型的对象，to_say就执行哪种类型的say函数。那么应该如何做呢？使用virtual关键字定义虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义虚函数，加virtual关键字即可</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base\n&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这时，下面的代码意义即为重写父类的虚函数</span></span><br><span class="line">    <span class="comment">// virtual 关键字可加可不加，意义都一样</span></span><br><span class="line">    <span class="comment">// virtual void say()</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Son1\n&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Son2\n&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_say</span><span class="params">(Base* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;<span class="built_in">say</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base s1;</span><br><span class="line">    Son1 s2;</span><br><span class="line">    Son2 s3;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">to_say</span>(&amp;s1);</span><br><span class="line">    <span class="built_in">to_say</span>(&amp;s2);</span><br><span class="line">    <span class="built_in">to_say</span>(&amp;s3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样之后，我们想传入哪个类型的对象，to_say就执行哪种类型的say函数。不信可试一下。使用虚函数，这样就可以使得这种想法实现了。</p><p>动态多态满足的条件：子类继承父类，并重写虚函数，并且传参数时传指针或者引用。</p><p>关于重写和重载的认识</p><ul><li>重写：函数返回值类型，函数名，函数参数列表完全一致</li><li>重载：函数名一致，但函数参数列表不同</li></ul><h3 id="虚函数原理"><a href="#虚函数原理" class="headerlink" title="虚函数原理"></a>虚函数原理</h3><p>我们使用MSVC的开发者工具分别查看上方未使用虚函数时，和使用虚函数时的类Son1内存布局。</p><p>之前</p><p><img src="https://s1.ax1x.com/2023/02/26/ppphJHA.png"></p><p>之后</p><p><img src="https://s1.ax1x.com/2023/02/26/ppphNNt.png"></p><p>我们可以清晰地看到，之后类Son1中多了**vfptr(virtual function pointer，虚函数指针)，虚函数指针指向vftable(virtual function table，虚函数表)**。每个类都有自己的虚函数表，虚函数表储存了类的所有虚函数的地址。如果本类重写了某名称的虚函数，那么本类的虚函数表的该名称的虚函数地址将使用为自己重写的函数的地址，否则就用父类的虚函数地址。函数调用时，通过读到对象的vfptr获得相应要调用的成员函数的地址，然后跳转到该地址执行代码。 每个子类都有不同的虚函数表，因此，传每个子类的实例上去，都会调用相应的函数，这就是虚函数原理了。</p><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>有时，我们的父类的虚函数不需要写任何代码，但是父类调用又没有任何意义，我们想强迫子类必须重写父类的虚函数。这时，我们就可以使用纯虚函数了。语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 直接使函数等于0</span></span><br><span class="line">    <span class="keyword">virtual</span> 返回值 函数名(<span class="comment">/*参数列表*/</span>) = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有一个及以上纯虚函数的类叫做虚基类，虚基类不可以实例化对象，因为如果要调用虚函数，虚基类可没有办法实现。这时，必须要子类继承，并重写父类的所有纯虚函数，如果没有重写完，子类也不可以实例化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doit</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Base b; // 错误，不可以实例化虚基类对象</span></span><br><span class="line">    Son s; <span class="comment">// 合法的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更进一步的面向对象编程"><a href="#更进一步的面向对象编程" class="headerlink" title="更进一步的面向对象编程"></a>更进一步的面向对象编程</h2><h3 id="union-class-struct定义类的区别"><a href="#union-class-struct定义类的区别" class="headerlink" title="union,class,struct定义类的区别"></a>union,class,struct定义类的区别</h3><p>在C++，union,class,struct都可以定义类，区别如下：</p><p>union 所有的成员对象共享同一内存，他们的起始地址是相同的。<strong>一个union可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当我们给union的某个成员赋值之后，该union的其它成员就变成未定义的状态了。分配给一个union对象的存储空间至少要能容纳它的最大的数据成员</strong>。union的成员默认访问权限是public，可以设置其他的访问权限，可以有静态成员，非静态成员函数，自定义的构造函数和析构函数，不能有虚函数。但是union的成员必须是POD类型。union也不能被继承。</p><p>class和struct仅存在默认访问权限和默认被继承方式不同。对于class，默认访问权限和默认被继承方式都是private，而对于struct，默认访问权限和默认被继承方式都为public。</p><h3 id="C-11下统一的方式给对象初始化"><a href="#C-11下统一的方式给对象初始化" class="headerlink" title="C++11下统一的方式给对象初始化"></a>C++11下统一的方式给对象初始化</h3><p>对于给对象初始化，有三种形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a1 = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> a3&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p>这三种方式都可以正确的给变量初始化为0，但是第三种是C++11特有的初始化方式。对于给一个对象初始化，如果可能，我们可以使用小括号，或者花括号。<strong>使用花括号时，这种初始化方式为统一初始化</strong>。</p><p>统一初始化可以<strong>初始化聚合体类型，也可以初始化非聚合体类型</strong>。在初始化聚合体类型数据时，要按聚合体成员声明顺序顺序初始化聚合体的非静态类型成员变量。当然，统一初始化是不可以给静态成员初始化的。</p><p><strong>什么是聚合体？普通数组，或者满足下方所有条件的类都是聚合体。</strong></p><ul><li>没有用户自定义的构造函数</li><li>没有用protected或private修饰的非静态成员变量</li><li>没有基类</li><li>没有虚函数</li></ul><p><strong>注意，聚合体的定义并不是递归的。</strong>换句话说，就是A如果是一个聚合体，他的成员变量可以不是聚合体，只需A自己满足聚合体的条件即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyType t&#123;<span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 使用统一初始化方式初始化聚合体类型</span></span><br></pre></td></tr></table></figure><p>对于非聚合体，我们只需定义构造函数，来进行非聚合体的初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyType</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">a</span>(a), <span class="built_in">b</span>(b)&#123;&#125;</span><br><span class="line">    <span class="built_in">MyType</span>(<span class="type">int</span> a) : <span class="built_in">a</span>(a), <span class="built_in">b</span>(a)&#123;&#125;</span><br><span class="line">    <span class="built_in">MyType</span>() : <span class="built_in">a</span>(), <span class="built_in">b</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyType t1&#123;<span class="number">1</span>&#125;;   <span class="comment">// 调用MyType(int a)初始化</span></span><br><span class="line">MyType t2&#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 调用MyType(int a, int b)初始化</span></span><br><span class="line">MyType t3&#123;&#125;;    <span class="comment">// 调用MyType()初始化，这样就不会有MyType t3();这样调用，会认为t3是一个函数</span></span><br></pre></td></tr></table></figure><p>但是如果一个类中有了以<strong>std::initializer_list</strong>类型为形参的构造函数，那么只要使用统一初始化，都只能调用带std::initializer_list类型的构造函数。</p><h3 id="C-11的关键字final"><a href="#C-11的关键字final" class="headerlink" title="C++11的关键字final"></a>C++11的关键字final</h3><p>我们可以使用<code>final</code>关键字阻止子类重写虚函数，或者使某个类无法被继承</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AAA</span> <span class="keyword">final</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//class BBB : AAA &#123;&#125;;</span></span><br><span class="line"><span class="comment">// 错误，final 修饰的类不可以被继承</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">final</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCaller</span> ： <span class="keyword">public</span> Caller</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 错误，不能重写final修饰的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-11的关键字override"><a href="#C-11的关键字override" class="headerlink" title="C++11的关键字override"></a>C++11的关键字override</h3><p><code>override</code>关键字保证函数必须重写了父类函数，如果没有重写，就会报错</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 报错，因为父类没有叫funx的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funx</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-11的委托构造函数"><a href="#C-11的委托构造函数" class="headerlink" title="C++11的委托构造函数"></a>C++11的委托构造函数</h3><p>如果我们想在构造对象时，委托另一构造函数执行部分工作，在C++11前没有办法做到，必须使用成员函数，现在我们可以直接委托构造函数进行构造的部分工作了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 委托Factory的其他构造函数完成构造的相关工作</span></span><br><span class="line">    <span class="built_in">Factory</span>() : <span class="built_in">Factory</span>(<span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;开工！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Factory</span>(<span class="type">int</span> people)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;开工人数&quot;</span> &lt;&lt; people &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-11的继承构造函数"><a href="#C-11的继承构造函数" class="headerlink" title="C++11的继承构造函数"></a>C++11的继承构造函数</h3><p>有时我们可以一步到位，直接继承完父类的所有构造函数，而不复制粘贴一遍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> Base&amp;) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">double</span> a, <span class="type">double</span> b) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> <span class="type">char</span>* c, <span class="type">char</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一句话，继承父类Base的所有构造函数</span></span><br><span class="line">    <span class="comment">// 父类有的所有构造函数，子类全部都有</span></span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-11的-x3D-default-amp-x3D-delete"><a href="#C-11的-x3D-default-amp-x3D-delete" class="headerlink" title="C++11的&#x3D;default &amp; &#x3D; delete"></a>C++11的&#x3D;default &amp; &#x3D; delete</h3><p>有的时候，我们想显示指定编译器生成默认的构造函数，我们就可以使用&#x3D;default</p><p>有的时候，有些类我们不想让他有拷贝构造函数，但是又想有默认构造函数，我们就可以使用&#x3D;delete</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使编译器生成默认的默认构函数</span></span><br><span class="line">    <span class="built_in">Base</span>() = <span class="keyword">default</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使编译器禁用拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Base</span>() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =delete还可以用来禁用析构函数，</span></span><br><span class="line">    <span class="comment">// 阻止隐式类型转换等</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">short</span>)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span>)</span> </span>= <span class="keyword">delete</span>; </span><br><span class="line">    <span class="comment">// 阻止Base类型的对象，在调用test成员函数时，参数类型是int</span></span><br><span class="line">    <span class="comment">// 换句话说，也就是阻止调用test函数时int类型的自动类型转换</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cplusplus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星光心灵 - 如何安慰他人</title>
      <link href="/blogs/posts/psychology/p951ad8dc218a.html"/>
      <url>/blogs/posts/psychology/p951ad8dc218a.html</url>
      
        <content type="html"><![CDATA[<p>Life is like a wave, which will go up and down. We cannot avoid suffering. Thus, we all need others’ comfort. The following informations show the useful tips to comfort people.</p><p>人生就像波浪，会起起落落。我们无法避免痛苦。因此，我们都需要别人的安慰。以下信息显示了安慰人们的有用技巧。</p><p>Better not to…</p><p>最好不要…</p><ol><li><p>Tell him or her that your situation is worse 跟他比惨<br>When someone turns to you, it is clear he or she wants your comfort. Telling “Mine is worse” always means “I can afford the worse situation than yours. So why can’t you?”. Although our thoughts are reasonable and these words sound motivating, the one will still assume you never care about his feelings, for you did not mention something about him.<br>当有人想你求助时时，很明显他想要你的安慰。说“我的情况更糟糕”总是意味着“我能承受比你更糟糕的情况。那你为什么不能呢？”虽然我们的想法是合理的，这些话听起来很激励人心，但那个人仍然会认为你从不在乎他的感受，因为你没有提到有关他的事情。</p></li><li><p>Tell words like “I already told you…” 说出诸如“我已经告诉过你了……”之类的话<br>Never tell words like “I already told you…”, “Were I you, it would not …”, “Have you thunk of my words?” When we talk like this, we do wish that the bad would have not happened if the one would follow our suggestios. However, in the occasion when the one need comfort, these words may always bring extra meanings like “You made you bed, now lie on it”, “You do your math”, “Put the stone and hit your legs”. It cannot be like your helping him out.<br>永远不要说“我已经告诉过你……”，“如果我是你，就不会……”，“你把我的话扔掉了吗？”当我们这样说话时，我们确实希望如果一个人听从我们的建议，坏事就不会发生。然而，在需要安慰的场合，这些话可能总会带来额外的含义，比如“你自作自受”，“你自己解决”，“搬石头砸自己的脚”。这不可能像是你在帮助他。</p></li><li><p>Give advice immediately 立即提供建议<br>As the saying goes, “When in Rome, do as the Romans do”. To comfort us is the same thing. Therefore, do not give advice to the one immediately. It is not the time. When doing this, the one who longs for the comfort may have to think  “Am so stupid I that I need to be given lessons by you?” Things are in a wrong way!<br>常言道：“入乡随俗”。安慰我们也是一样的。因此，不要立即给建议给他们。时机还未到！这么做的时候，那些渴望安慰的人可能不得不认为“我是傻到需要被你教训？”事情在朝坏的方向发展！</p></li></ol><p>As a consequent, what can we do to have it not happen?<br>因此，我们能做些什么来避免它发生？</p><ol><li><p>Think what he thinks 想他所想<br>Everyone was born in different backgrounds, so their personalities, lifestyles, hobbies and minds are quite different. The most important part is to think what he thinks. We cannot force all to be like us. Only in this way can we shine in the sky together.<br>每个人出生在不同的背景中，所以他们的个性、生活方式、爱好和思想都大不相同。最重要的是想他所想。我们不能强迫所有人都像我们一样做事。只有这样，我们才能一起在天空中发光。</p></li><li><p>Have the one speak out the pain 让那个人说出痛苦<br>The one has been in disappointment and in blue for a long time. So just have the one speak out, in order to clear his mind, open his cheats, meet the better himself. Also, we need to listen to him carefully and patiently. You can cut in to further the process if you are good at it. Anyway, you should be like “Whatever, wherever, however, you can turn to me and I’ll always help you out. I’ll be your lighthouse forever”. Even if you say nothing, a hug can warm him much.<br>那个人已经失望和抑郁很长时间了。所以只要让那个人说出来，才能理清思路，敞开胸襟，遇见更好的自己。此外，我们需要仔细和耐心地倾听。如果你擅长，你可以插话以进一步推进该过程。无论如何，你应该像是“无论如何，无论在哪里，无论怎么样，你可以求助于我，我都会帮助你。我会永远是你的灯塔”。即使你一句不算，一个拥抱也能温暖他的内心。</p></li><li><p>Offer ideas if necessary 必要时提供想法<br>One can not always downhill any longer. So we have to find way out. But no offering ideas immediately until he is getting happier.<br>一个人不能再总是下坡了。所以我们必须找到出路。但是在他开心之前，不要立即提出想法。</p></li></ol><p>That is it! Drama will come to an end but our life will not. We just do hope we can live, happy and joyful!<br>就是这样！戏会落幕，但我们的人生不会。我们希望我们能快乐生活！</p>]]></content>
      
      
      <categories>
          
          <category> psychology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> psychology </tag>
            
            <tag> philosophy </tag>
            
            <tag> art </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星光心灵 - 倾听是否重要</title>
      <link href="/blogs/posts/psychology/p320b63238c75.html"/>
      <url>/blogs/posts/psychology/p320b63238c75.html</url>
      
        <content type="html"><![CDATA[<p>We all like to tell our thoughts to others when in an informal conversation. As you can see, sometimes someone has not ended up talking, others can’t help cutting in. Who masters speaking is welcomed, but a man who is good at listening is also attractive.</p><p>我们都喜欢在非正式对话中向他人讲述我们的想法。如你所见，有时有人没有结束说话，其他人会忍不住插话。谁精通说话是受欢迎的，但善于倾听的人也很有吸引力。</p><p>In he occasion when a man listens to you, you will feel like you are respected, trusted, not ignored. It is the man who understands you! He does still listen to your words! A kind of entertaining feeling spreads through your mind. Thus, you can talk to him to your heart’s content.</p><p>当一个人听你说话时，你会觉得你受到尊重，被信任，没被忽视。他理解你！他听你的话！一种愉快的感觉弥漫在脑海。因此，你可以尽情地与他交谈。</p><p>One Mid-Autumn night, a man flew back to his home. The plane was suddenly about to crash down during the flight.Owing to the captain’s calm and professional moves, all the passengers were out of death, appreciated for life. However, as the man talked about this with his wife,  he was much excited and joyful, even he would screamed and shouted in the intriguing part, hopeing to share the unforgetable memory to her. The wife was just only in the joy of the festival, had no reacton with this. The huge contrast from words had the man downhill. Months later he broke up with her.</p><p>一个中秋的夜晚，一个男人乘飞机飞回家。飞机在飞行过程中突然要坠毁。由于机长的冷静和专业的操作，所有乘客都摆脱了死亡，感谢生命的美好。然而，当男人和妻子谈论这件事时，他非常兴奋和高兴，甚至他会在耐人寻味的部分尖叫和喊叫，希望将难忘的回忆分享给她。妻子只是在节日的喜悦中，对此没有任何反应。言语的巨大反差让男人十分低落。几个月后，他和她分手了。</p><p>In that case, that his wife did not reply to him ended up their marriage, although emotion between them before was so passionate and heated. Only in one day did they become passers-by.</p><p>在这种情况下，他的妻子没有回复他，终结了他们的婚姻。尽管他们之间的感情之前是如此情意绵绵，如此热情。仅仅一天，他们就成了路人。</p><p>Also, to listen can have we know more about someone. Hearing what patients talk about theirselves more has doctors heal them better. Hearing what students ask has teachers  process the lessons more quickly. Hearing what customers long for has the company offers splendiferous products more. The Panasonic Company’s manager often listens to its workers’ views. That is why it can success.</p><p>此外，倾听可以让我们更多地了解某人。听到病人更多地谈论他们的自我，医生可以更好地治愈他们。倾听学生的问题可以让老师更快地处理课程。听到客户渴望什么，公司提供了更多精彩的产品。松下公司的经理经常听取工人的意见。这就是为什么它可以成功。</p><p>What’s more, listening can further our knowledge. Listening to different people, we can receive a wide range of ideas. Animal-lovers’ words show how to protect animals. Well-known basketball players’ words give us the ecperience of practicing the basketball. World-famous writers’ words represent the tricks of writting. No matter who he is, we can learn a lot from it.</p><p>更重要的是，倾听可以增进我们的知识。倾听不同的人，我们可以收到各种各样的想法。动物爱好者的话说明了如何保护动物。知名篮球运动员的话，给了我们练习篮球的经验。世界著名作家的话，象征了写作的技巧。不管他是谁，我们都可以从中学到很多东西。</p><p>All in all, there is no denying that listening is useful.We cannot emphasize the importance of listening too much. The more you listen, the more you will be brilliant!</p><p>总而言之，不可否认，倾听是有用的。我们再怎么强调倾听的重要性也不为过。你听得越多，你就会越闪耀！</p>]]></content>
      
      
      <categories>
          
          <category> psychology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> psychology </tag>
            
            <tag> philosophy </tag>
            
            <tag> art </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：探索绘图编程和对话框</title>
      <link href="/blogs/posts/windows/pff3fd6e98f0e.html"/>
      <url>/blogs/posts/windows/pff3fd6e98f0e.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="探索绘图编程"><a href="#探索绘图编程" class="headerlink" title="探索绘图编程"></a>探索绘图编程</h2><p>GDI,Graphic Device Interface，Windows提供了大量API供我们绘制各种各样的图形。</p><p>Windows每个窗口都是绘制出来的，当窗口需要绘制的时候，产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/gdi/wm-paint">WM_PAINT消息</a>，进而我们可以绘制窗口。</p><p>HDC，即为设备上下文句柄，DC是设备windows特有的一个概念，我们需要使用他来绘图。</p><p>下面是简单的绘图代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyWindowApplication/resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;kernel32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;星光探索者&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hInstance = hInstance; </span><br><span class="line">    wc.lpfnWndProc = WinProc; </span><br><span class="line">    wc.lpszClassName = CLASSNAME; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>, CLASSNAME, TITLE,WS_OVERLAPPEDWINDOW, </span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT,  CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">NULL</span>,  <span class="literal">NULL</span>,  hInstance, <span class="literal">NULL</span> </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 定义绘图结构体，用来绘图</span></span><br><span class="line">        PAINTSTRUCT ps;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始绘画，得到DC</span></span><br><span class="line">        HDC hdc = <span class="built_in">BeginPaint</span>(hwnd, &amp;ps);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制图标</span></span><br><span class="line">        <span class="built_in">DrawIcon</span>(hdc, <span class="number">50</span>, <span class="number">50</span>, <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, <span class="built_in">LPCTSTR</span>(IDI_MYICON)));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i != <span class="number">40</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">10</span>; j != <span class="number">40</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 绘制一个点</span></span><br><span class="line">                <span class="built_in">SetPixel</span>(hdc, i, j, <span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束绘画</span></span><br><span class="line">        <span class="built_in">EndPaint</span>(hwnd, &amp;ps);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以简单的绘图了。只需BeginPaint获得HDC，然后调用相关的API（API直接查<a href="https://learn.microsoft.com/zh-cn/windows/win32/gdi/windows-gdi">官网相关资源</a>），然后再EndPaint，就可以了。但是并不是什么时候都可以绘图的，<strong>只有绘图消息和计时器消息发生时，绘图才会成功</strong>。</p><h2 id="使用对话框"><a href="#使用对话框" class="headerlink" title="使用对话框"></a>使用对话框</h2><p>对话框是一种窗口，他主要用于向用户显示信息或等待用户输入时的一个小弹窗。如果我们快速制作一个Win32程序，使用对话框是一种便捷方法。</p><p>同样是这个熟悉的界面，右键项目，添加(Add)，资源(Resource)</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8odt1.png"></p><p>点击对话框(Dialog)，之后VS显示了一个可视化的设计器。我们可以直接拖拽控件快速布局。大部分小伙伴都对很喜欢这种形式吧！</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8og7d.png"></p><p>为了示范，星光探索者之后就直接写代码了。</p><p>对话框根据显示后是否阻止与其他窗口交互，可分为模态对话框和非模态对话框。</p><ul><li><p>模态对话框：显示后阻止你创建的其他窗口交互</p></li><li><p>非模态对话框：显示后不阻止你创建的其他窗口交互</p></li></ul><p>模态对话框的创建方式，调用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-dialogboxw">DialogBox函数</a>。这个函数是阻塞函数，返回值为对话框销毁时的返回值。参数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT_PTR <span class="title">DialogBox</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,   <span class="comment">// 实例句柄，如果传NULL将使用当前的</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpTemplate,    <span class="comment">// 创建的资源模板，在资源文件</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWndParent,       <span class="comment">// 对话框的父窗口</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DLGPROC lpDialogFunc   <span class="comment">// 对话框消息过程处理函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>非模态对话框创建方式，调用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-createdialogw">CreateDialog函数</a>，参数如下，意义和上方相同，不多叙述。这个函数不是阻塞函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateDialog</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE  hInstance,     </span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR    lpName,</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND       hWndParent,</span></span></span><br><span class="line"><span class="params"><span class="function">    DLGPROC    lpDialogFunc</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>DLGPROC是对话框过程函数的类型，为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">INT_PTR</span> <span class="params">(CALLBACK* DLGPROC)</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br></pre></td></tr></table></figure><p>实际上和窗口消息过程函数是一模一样的。但是这个对话框过程函数的返回值如果为FALSE，表明还需要默认处理函数处理，否则不调用默认处理函数处理。</p><p>当对话框开始创建未显示时，产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/dlgbox/wm-initdialog">WM_INITDIALOG消息 </a>，不产生WM_CREATE消息。因此，对话框过程函数不应该处理WM_CREATE消息。各位感兴趣的小伙伴可验证一下。</p><p>模态对话框和非模态对话框的处理函数写法要求大不同。模态对话框销毁时使用<a href="https://learn.microsoft.com/zh-CN/windows/win32/api/Winuser/nf-winuser-enddialog">EndDialog 函数</a>，不可以使用DestroyWindow等函数；而非模态对话框销毁时使用<a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winuser/nf-winuser-destroywindow">DestroyWindow 函数</a>。</p><p>要想处理对话框内部的控件的操作，需要处理<a href="https://learn.microsoft.com/zh-cn/windows/win32/menurc/wm-command"> WM_COMMAND消息</a>。控件被点击时，lParam为控制窗口的句柄，wParam的高字节为控件的消息，低字节为控件ID标识符</p><p>下面是一个模态对话框的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;kernel32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;星光探索者&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(WHITE_BRUSH);</span><br><span class="line">    wc.hInstance = hInstance; </span><br><span class="line">    wc.lpfnWndProc = WinProc; </span><br><span class="line">    wc.lpszClassName = CLASSNAME; </span><br><span class="line">    wc.style = CS_HREDRAW | CS_VREDRAW; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>,CLASSNAME, TITLE, WS_OVERLAPPEDWINDOW, </span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span> </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">        <span class="comment">// 处理对话框被创建的消息</span></span><br><span class="line">        <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;对话框被创建&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;探索对话框&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="comment">// 处理对话框被点击的消息</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// IDOK和IDCANCEL都是定义好的，分别代表OK和CANCEL按钮</span></span><br><span class="line">        <span class="keyword">case</span> IDOK:</span><br><span class="line">            <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;我也觉得OK&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;来自对话框的信息&quot;</span>), MB_OK);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        <span class="keyword">case</span> IDCANCEL:</span><br><span class="line">            <span class="built_in">EndDialog</span>(hwnd, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_RBUTTONDOWN:</span><br><span class="line">        <span class="built_in">DialogBox</span>(<span class="literal">NULL</span>, (LPCTSTR)IDD_DIALOG1, hwnd, DialogProc);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个实例，当我们鼠标右键的时候，弹出一个消息框后弹出对话框。点击OK按钮，将显示“我也觉得OK啊“；点击CANCEL按钮，将关闭对话框。</p><h2 id="使用系统定义好的控件"><a href="#使用系统定义好的控件" class="headerlink" title="使用系统定义好的控件"></a>使用系统定义好的控件</h2><p>对话框里能拖出这么多控件，实际上系统已经提前定义好了一些控件。</p><p>包含头文件<code>CommCtrl.h</code>，这个头文件定义了很多<a href="https://learn.microsoft.com/zh-cn/windows/win32/controls/common-control-window-classes">定义好的系统窗口类 </a>。但是你需要在<code>#include &lt;windows.h&gt;</code>头文件后再<code>#include &lt;CommCtrl.h&gt;</code>，因为你微软居然要用windows.h头文件，居然不包含，导致编译的时候提示有很多标识符未定义，不这么做会报错。</p><p>系统已经定义好的控件包括WC_BUTTON(按钮)，WC_EDIT(文本编辑框)，WC_STATIC(不可改文本控件)，WC_TREEVIEW(树状图)，ANIMATE_CLASS(动画)等。</p><p>窗口控件的消息，是通过<a href="https://learn.microsoft.com/zh-cn/windows/win32/menurc/wm-command">WM_COMMAND消息</a>间接传上来的。 <strong>控件被点击时，lParam为控制窗口的句柄，wParam的高字节为控件的消息，低字节为控件ID标识符。</strong> 这个在对话框消息过程函数已经提及。</p><p>看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;CommCtrl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;kernel32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;星光探索者&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(WHITE_BRUSH);</span><br><span class="line">    wc.hInstance = hInstance; </span><br><span class="line">    wc.lpfnWndProc = WinProc; </span><br><span class="line">    wc.lpszClassName = CLASSNAME; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>,CLASSNAME, TITLE, WS_OVERLAPPEDWINDOW, </span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span> </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// GetModuleHandle用于获得程序的hInstance，</span></span><br><span class="line">        <span class="comment">// 就是WinMain函数那里的hInstnace</span></span><br><span class="line">        HINSTANCE hInstance = <span class="built_in">GetModuleHandle</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// WC_BUTTON是按钮类，BS_PUSHBUTTON是按钮的风格</span></span><br><span class="line">        <span class="comment">// 下方的代码创建了一个按钮</span></span><br><span class="line">        <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">            <span class="number">0</span>, WC_BUTTON, <span class="built_in">TEXT</span>(<span class="string">&quot;BUTTON&quot;</span>), </span><br><span class="line">             WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, </span><br><span class="line">            <span class="number">5</span>, <span class="number">5</span>, <span class="number">100</span>, <span class="number">100</span>, hwnd, </span><br><span class="line">            <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="comment">// 控件的消息通过wParam间接传递</span></span><br><span class="line">        <span class="comment">// BN_CLICKED是按钮被点击时产生的消息</span></span><br><span class="line">        <span class="comment">// 点击下方链接查看按钮的部分相关内容 </span></span><br><span class="line">        <span class="comment">// https://zhuanlan.zhihu.com/p/353558221</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">HIWORD</span>(wParam) == BN_CLICKED)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;按钮被点击！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;你好！&quot;</span>), MB_OK);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行本程序，可以看到成功创建了一个按钮，并且点击之后会弹出“按钮被点击”的消息框。</p><h2 id="阶段小结"><a href="#阶段小结" class="headerlink" title="阶段小结"></a>阶段小结</h2><p>经过了好几篇文章的探索，想必你对Win32程序设计有了更深一步的了解，可以继续探索Windows了。转眼间春节就要到了，星光探索者祝各位春节快乐！</p><p>本期到此结束！感谢各位小伙伴的阅读！</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：使用计时器和菜单，图标，光标等资源文件</title>
      <link href="/blogs/posts/windows/p71040f0575db.html"/>
      <url>/blogs/posts/windows/p71040f0575db.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="使用计时器"><a href="#使用计时器" class="headerlink" title="使用计时器"></a>使用计时器</h2><p>计时器是Windows的一种资源。定时器每隔一段时间，会产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/winmsg/wm-timer">WM_TIMER消息 </a>。WM_TIMER附带的两个信息wParam, lParam分别是计时器的id, 计时器到点的处理函数。定时器的精度是毫秒，但是准确度不好。也就是说如果设置间隔1000ms，不一定会在1000ms后刚好产生消息。但是误差不会这么大，最多也就几毫秒。</p><p>要使用计时器，需要用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-settimer">SetTimer函数</a>创建定时器。SetTimer的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT_PTR <span class="title">SetTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND      hWnd,       <span class="comment">// 计时器关联的窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT_PTR  nIDEvent,   <span class="comment">// 计时器的ID，自己随意定，但不能为0</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT      uElapse,    <span class="comment">// 计时器的间隔，单位毫秒</span></span></span></span><br><span class="line"><span class="params"><span class="function">    TIMERPROC lpTimerFunc <span class="comment">// 计时器到点的处理函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数返回创建的计时器ID，如果创建失败了返回0。如果<code>lpTimerFunc</code>传的是NULL，计时器的时间到了，就将发送WM_TIMER消息通知关联的窗口过程函数处理，否则就不发WM_TIMER消息，直接调用<code>lpTimerFunc</code>处理。计时器依赖于消息循环，也就是要使用计时器，就需要消息循环。</p><p><a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winuser/nc-winuser-timerproc">TIMERPROC </a>是计时器回调函数的类型，因此计时器回调函数lpTimeProc因定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> CALLBACK <span class="title">lpTimerProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HWND hWnd,         <span class="comment">// 与计时器关联</span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT nMsg,         <span class="comment">// 消息类型(WM_TIMER)</span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT_PTR uTImerid, <span class="comment">// 计时器ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwTime       <span class="comment">// 时间延迟</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>计时器是系统资源，销毁计时器使用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-killtimer">KillTimer 函数 </a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">KillTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND     hWnd,    <span class="comment">// 销毁计时器的关联窗口</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT_PTR uIDEvent</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>示例代码：创建两个计时器，时间间隔分别为1000毫秒和2000毫秒，每调一次将打印一些字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 各位如果用Visual Studio开发工具，可能会出现某些函数VS觉得不安全不给用</span></span><br><span class="line"><span class="comment">// 如果还是想用，加上这句语句</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;kernel32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;window&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(DKGRAY_BRUSH);</span><br><span class="line">    wc.hIcon = <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, IDI_APPLICATION);</span><br><span class="line">    wc.hCursor = <span class="built_in">LoadCursor</span>(<span class="literal">NULL</span>, IDC_ARROW);  </span><br><span class="line">    wc.hInstance = hInstance; </span><br><span class="line">    wc.lpfnWndProc = WinProc; </span><br><span class="line">    wc.lpszClassName = CLASSNAME; </span><br><span class="line">    wc.lpszMenuName = <span class="literal">NULL</span>; </span><br><span class="line">    wc.style = CS_HREDRAW | CS_VREDRAW; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>,CLASSNAME, TITLE, WS_OVERLAPPEDWINDOW, </span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>,  hInstance, <span class="literal">NULL</span> </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> UINT_PTR timer1, timer2;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">FreeConsole</span>();</span><br><span class="line">        <span class="comment">// 销毁定时器</span></span><br><span class="line">        <span class="built_in">KillTimer</span>(hwnd, timer1);</span><br><span class="line">        <span class="built_in">KillTimer</span>(hwnd, timer2);</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">        <span class="built_in">AllocConsole</span>();</span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;CONOUT$&quot;</span>, <span class="string">&quot;w+t&quot;</span>, stdout);</span><br><span class="line">        <span class="comment">// 创建定时器</span></span><br><span class="line">        timer1 = <span class="built_in">SetTimer</span>(hwnd, <span class="number">1</span>,</span><br><span class="line"> <span class="number">1000</span>, <span class="literal">NULL</span>);</span><br><span class="line">        timer2 = <span class="built_in">SetTimer</span>(hwnd, <span class="number">2</span>, <span class="number">2000</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">case</span> WM_TIMER: </span><br><span class="line">        <span class="comment">// 处理计时器消息</span></span><br><span class="line">        <span class="keyword">if</span> (wParam == timer1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;timer1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wParam == timer2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;timer2\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用菜单资源"><a href="#使用菜单资源" class="headerlink" title="使用菜单资源"></a>使用菜单资源</h2><p>我们创建窗口时很想让这个窗口显示自己的东西，那么我们应该怎么做呢？</p><p>星光探索者前面的说过有个资源编译器rc.exe，可以编译资源文件。首先我们先探索一下如何添加资源吧！</p><p>对准想添加资源的项目右键，弹出下面的菜单。依次点击添加(Add)，资源(Resource)即可。</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oN79.png"></p><p>然后弹出这样的对话框，选择菜单(Menu)，然后点击新建（New）</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8odt1.png"><br>然后将会在Visual Studio弹出可视化的编辑器。相信不用星光探索者多说，各位小伙伴都会摸索的出来如何添加菜单项吧。</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oc0H.png"></p><p>之后在你的项目管理器会添加一个resource.h（可以改名）头文件，和拓展名为.rc的资源文件。资源文件是一种用脚本语言书写的代码文件，当然如果小伙伴乐意，可手写资源文件。在编译过程中，资源文件会被资源编译器(在VC++是rc.exe)编译成.rsc的目标文件，进而通过链接器(在VC++是link.exe)编译成最终文件。</p><p>资源创建了，如何使用呢？刚才添加的resource.h文件定义了那些ID标识符。在打开的资源管理器(Resource View)中，选中添加的菜单，然后右键，点击(Resource Symbol)即可查看添加的资源的id。星光探索者这里创建的菜单ID为IDC_MENU1。当然也可以直接查看resource.h头文件</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8ot0J.png"></p><p>还记得创建窗口类时的WNDCLASS结构体吗？那里有一个lpszMenuName属性，给他赋值就可以使用我们添加的菜单资源了。lpszMenuName需要LPCTSTR的类型，资源文件定义的ID都是数值，我们只需进行强制转换即可。或者CreateWindowEx的第10个参数也是叫传菜单句柄的，也可以选择在那里使用菜单资源。</p><p>既然有了菜单，我们就应该处理菜单的相关消息。处理菜单消息应该处理<a href="https://learn.microsoft.com/zh-cn/windows/win32/menurc/wm-command">WM_COMMAND消息</a>。当窗口内的控件（如按钮，文本等）被点击时，或菜单项被点击时，或窗口标题栏那些按钮（如最小化）被点击时产生此消息。当菜单项被点击时，wParam的高字节为0，低字节为点击的菜单项ID，菜单项ID之前已探索过如何找到。</p><p>于是我们写出像下面这样的代码来使用菜单资源：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;kernel32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;window&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(DKGRAY_BRUSH);</span><br><span class="line">    wc.hIcon = <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, IDI_APPLICATION);</span><br><span class="line">    wc.hCursor = <span class="built_in">LoadCursor</span>(<span class="literal">NULL</span>, IDC_ARROW);  </span><br><span class="line">    wc.hInstance = hInstance; </span><br><span class="line">    wc.lpfnWndProc = WinProc; </span><br><span class="line">    wc.lpszClassName = CLASSNAME; </span><br><span class="line">    <span class="comment">// 强制转换即可使用，星光探索者这里的菜单资源为 IDR_MENU1</span></span><br><span class="line">    wc.lpszMenuName = (LPCWSTR)IDR_MENU1; </span><br><span class="line">    wc.style = CS_HREDRAW | CS_VREDRAW; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>,CLASSNAME, TITLE, WS_OVERLAPPEDWINDOW, </span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="comment">// CreateWindowEx的第10个参数也是叫传菜单句柄的</span></span><br><span class="line">        <span class="comment">// 也可以使用LoadMenu来加载菜单资源</span></span><br><span class="line">        <span class="comment">//LoadMenu(NULL, LPCTSTR(IDR_MENU1)), </span></span><br><span class="line">        <span class="literal">NULL</span>, </span><br><span class="line">        hInstance, <span class="literal">NULL</span> </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="comment">// 处理菜单项被点击，需要处理WM_COMMAND消息</span></span><br><span class="line">        <span class="comment">// wParam的低字节为被点击的菜单项ID，用LOWORD进行获取</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 星光探索者已经改过这些菜单项的名字了</span></span><br><span class="line">        <span class="keyword">case</span> ID_NEW:</span><br><span class="line">            <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;点击新建选项&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;星光探索者&quot;</span>), MB_OK);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ID_OPEN:</span><br><span class="line">            <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;点击打开选项&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;星光探索者&quot;</span>), MB_OK);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，点击菜单的新建选项，将出现这样的效果：</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oYm4.png"></p><h2 id="右键菜单实现"><a href="#右键菜单实现" class="headerlink" title="右键菜单实现"></a>右键菜单实现</h2><p>用过办公软件和浏览器的小伙伴都会体验过，鼠标右键会弹出一个菜单。那么我们应该如何实现呢？</p><p>直接说结论：我们使用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-trackpopupmenu">TrackPopupMenu 函数</a>可以弹出一个快捷菜单，这就是我们期望的。TrackPopupMenu是阻塞函数，直到菜单消失才会返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">TrackPopupMenu</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HMENU      hMenu,        <span class="comment">// 菜单句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT       uFlags,       <span class="comment">// 菜单弹出方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>        x,            <span class="comment">// 菜单的x坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>        y,            <span class="comment">// 菜单的y坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>        nReserved,    <span class="comment">// 预留参数，传NULL即可</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HWND       hWnd,         <span class="comment">// 拥有快捷菜单的窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> RECT *prcRect      <span class="comment">// 此参数被忽略，传NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>然后什么时候弹出呢？我们可以通过处理WM_RBUTTONDOWN（鼠标右键按下）消息来实现，可以是可以。但是事实告诉我们微软提供了<a href="https://learn.microsoft.com/zh-cn/windows/win32/menurc/wm-contextmenu">WM_CONTEXTMENU消息</a>，这样更便捷，这是上下文菜单的消息。正好可以使用右键菜单。</p><p>此消息附带的两个参数如下：</p><ul><li><p><code>wParam</code> 用户右键点击鼠标的窗口句柄</p></li><li><p><code>lParam</code> 低字节表示鼠标光标的x坐标，高字节表示y坐标，这是相对屏幕而言的</p></li></ul><h2 id="添加图标和光标资源"><a href="#添加图标和光标资源" class="headerlink" title="添加图标和光标资源"></a>添加图标和光标资源</h2><p>和前面添加菜单资源一样，但是如果我们有现成的，在弹出这个对话框时，就可以点击导入(Import)使用现有资源。这个步骤相信各位摸索都可以摸索出来。</p><p>然后再调用LoadIcon，LoadCursor即可。</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8odt1.png"></p><p>本期到此结束，下期看星光探索者探索Windows绘图编程和对话框</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：处理常用的消息和自定义消息</title>
      <link href="/blogs/posts/windows/p8cad54b0e5bf.html"/>
      <url>/blogs/posts/windows/p8cad54b0e5bf.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><p>下发假设您自己的窗口类的窗口过程函数均为WndProc，且您正确的按流程写了自定义的窗口程序</p><p>下方均是提供的一种处理方式的代码，并不是必须要这么做。</p><h2 id="处理WM-CLOSE消息"><a href="#处理WM-CLOSE消息" class="headerlink" title="处理WM_CLOSE消息"></a>处理WM_CLOSE消息</h2><p>WM_CLOSE消息在窗口即将终止时产生。</p><p>此消息附带的两个信息</p><ul><li><p><code>wParam</code> 未使用</p></li><li><p><code>lParam</code> 未使用</p></li></ul><p>处理窗口过程函数一个例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="comment">// 应调用此函数，这样会发送WM_QUIT消息</span></span><br><span class="line">        <span class="comment">// 使GetMessage返回0，这样进程才会正确退出</span></span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);  </span><br><span class="line">        <span class="comment">// 不要让默认处理函数处理，否则可能会出错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，WM_DESTROY和WM_QUIT也有退出的意思，这三个消息有什么区别呢？</p><p>WM_DESTROY在窗口销毁时产生，附带的两个信息和WM_CLOSE相同。但在WM_CLOSE可以选择决定是否销毁窗口。WM_QUIT消息在调用PostQuitMessage产生，使得GetMessage返回0。</p><h2 id="处理WM-CREATE消息"><a href="#处理WM-CREATE消息" class="headerlink" title="处理WM_CREATE消息"></a>处理WM_CREATE消息</h2><p>WM_CREATE消息在窗口被创建时产生，在<strong>CreateWindow函数返回之前且窗口未显示之前</strong>产生。如果这个消息返回0，窗口将会被创建，返回-1将销毁创建的窗口。通常处理此消息时，我们初始化一些数据。</p><p>此事件附带的参数</p><ul><li><p><code>wParam</code> 未使用</p></li><li><p><code>lParam</code> 指向 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/ns-winuser-createstructa"><strong>CREATESTRUCT</strong></a>结构的指针，可以获得CreateWindow的全部参数</p></li></ul><p>处理窗口过程函数一个示例如下（运行本示例，您应该能看到先弹出一个消息框，再显示窗口）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="comment">// 大部分小伙伴刚掌握时还不太熟练Windows基本数据类型</span></span><br><span class="line">            <span class="comment">// LPCTSTR = const TCHAR*</span></span><br><span class="line">            <span class="comment">// CREATESTRUE结构可以获得CreateWindow传的所有参数</span></span><br><span class="line">            <span class="comment">// lpszClassName是其中之一</span></span><br><span class="line">            <span class="comment">// reinterpret_cast是C++的类型转换使用的，</span></span><br><span class="line">            LPCTSTR lpClassName = <span class="built_in">reinterpret_cast</span>&lt;CREATESTRUCT*&gt;(lParam)-&gt;lpszClass;</span><br><span class="line">            <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;窗口创建了！&quot;</span>), lpClassName, MB_OK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理WM-SIZE消息"><a href="#处理WM-SIZE消息" class="headerlink" title="处理WM_SIZE消息"></a>处理WM_SIZE消息</h2><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/winmsg/wm-size">WM_SIZE消息</a>将在窗口被调整大小结束后产生。窗口在第一次创建的时候理所当然会调整大小，所以至少会触发一次</p><p>此消息附带的两个信息</p><ul><li><p><code>wParam</code> 调整大小的方式</p></li><li><p><code>lParam</code> 调整后的新范围。低字节为调整后的新宽度，高字节为调整后的新高度</p></li></ul><p>处理此事件的一个示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;iostream&gt; // 使用std::cout包含了这个头文件</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 销毁分配的控制台</span></span><br><span class="line">        <span class="built_in">FreeConsole</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">        <span class="comment">// 给此窗口分配控制台，控制台会由系统处理</span></span><br><span class="line">        <span class="built_in">AllocConsole</span>();</span><br><span class="line">        <span class="comment">// 重定向标准输出流，使得printf可以在控制台输出</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;CONOUT$&quot;</span>,<span class="string">&quot;w+t&quot;</span>, stdout);</span><br><span class="line">    <span class="keyword">case</span> WM_SIZE:</span><br><span class="line">        <span class="comment">// 可用 LOWORD 获取低字节内容 HIWORD 获取高字节内容</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;宽度&quot;</span> &lt;&lt; <span class="built_in">LOWORD</span>(lParam) &lt;&lt; <span class="string">&quot;高度&quot;</span> &lt;&lt; <span class="built_in">HIWORD</span>(lParam) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行此程序，可能的结果如下：</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8or6O.png"></p><h2 id="处理常见鼠标消息"><a href="#处理常见鼠标消息" class="headerlink" title="处理常见鼠标消息"></a>处理常见鼠标消息</h2><p>鼠标移动，按下，松开，会产生鼠标消息。一般情况下，只有在你自己的窗口产生的鼠标消息，才会接收到，要想鼠标在哪个窗口都能处理到鼠标消息，请使用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setcapture">SetCapture 函数 </a>。</p><p>鼠标在窗口移动时，产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-mousemove">WM_MOUSEMOVE消息</a>消息，根据移动的快慢，产生WM_MOUSEMOVE的消息频率是不同的</p><p>鼠标左键按下时，产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-lbuttondown">WM_LBUTTONDOWN消息 </a>，松开时产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-lbuttonup">WM_LBUTTONUP消息</a>。鼠标右键按下时，产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-rbuttondown">WM_RBUTTONDOWN消息</a>，松开时产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-rbuttonup">WM_RBUTTONUP消息 </a></p><p>消息产生均附带的两个信息</p><ul><li><p><code>wParam</code> 产生消息时，其他按键的情况（例如Ctrl,Shift键有没有按下）</p></li><li><p><code>lParam</code> 产生消息时，低字节为鼠标的x坐标，高字节为鼠标的y坐标，是相对窗口而言的</p></li></ul><p>处理消息的一种示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">FreeConsole</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">        <span class="built_in">AllocConsole</span>();</span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;CONOUT$&quot;</span>,<span class="string">&quot;w+t&quot;</span>, stdout);</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;鼠标左键按下 x:%d y: %d\n&quot;</span>, <span class="built_in">LOWORD</span>(lParam), <span class="built_in">HIWORD</span>(lParam));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONUP:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;鼠标左键松开 x:%d y: %d\n&quot;</span>, <span class="built_in">LOWORD</span>(lParam), <span class="built_in">HIWORD</span>(lParam));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_MOUSEMOVE:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;鼠标移动消息 x:%d y: %d\n&quot;</span>, <span class="built_in">LOWORD</span>(lParam), <span class="built_in">HIWORD</span>(lParam));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="鼠标双击消息"><a href="#鼠标双击消息" class="headerlink" title="鼠标双击消息"></a>鼠标双击消息</h2><p>当鼠标左键或右键或中键双击时，并且创建窗口时使用CS_DBCLICK风格，才会产生产生鼠标双击消息。很多小伙伴可能疑惑鼠标中键在哪。实际上鼠标的那个滚轮是可以按下去的，那个就是鼠标中键了。并不是鼠标双击消息产生时，就不会产生鼠标单击消息。</p><p>以鼠标左键双击消息(<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-lbuttondblclk">WM_LBUTTONDBLCLK</a>)，产生消息的顺序是：</p><p>WM_LBUTTONDOWN, WM_LBUTTONUP, WM_LBUTTONDBLCLK, WM_LBUTTONUP</p><p>消息产生均附带的两个信息</p><ul><li><p><code>wParam</code> 产生消息时，其他按键的情况（例如Ctrl,Shift键有没有按下）</p></li><li><p><code>lParam</code> 产生消息时，低字节为鼠标的x坐标，高字节为鼠标的y坐标，是相对窗口而言的</p></li></ul><h2 id="键盘消息"><a href="#键盘消息" class="headerlink" title="键盘消息"></a>键盘消息</h2><p>当键盘的案件被按下或松开时，产生键盘事件。如<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-keydown">WM_KEYDOWN 消息</a>，<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-keyup">WM_KEYUP 消息</a>等。</p><p>消息产生均附带的两个信息</p><ul><li><p><code>wParam</code> 按下按键的VirtualKey（虚拟键代码）</p></li><li><p><code>lParam</code> 按键的参数（如点击了几次）</p></li></ul><p>按下按键只会表明按下的是哪个按键，例如在输入大写字母A和小写字母a时，都是按下了a键，产生WM_KEYDOWN或WM_KEYUP等时没法区分。如果要得到按下按键时的ASCII值，使用<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-char">WM_CHAR 消息 </a>更加方便。</p><h2 id="自定义消息"><a href="#自定义消息" class="headerlink" title="自定义消息"></a>自定义消息</h2><p>有的时候，我们想有自定义消息，那么我们可以使用<a href="https://learn.microsoft.com/zh-CN/windows/win32/winmsg/wm-user">WM_USER</a>宏。自定义消息的格式为WM_USER + x。</p><p>以下是消息编号的范围。</p><table><thead><tr><th>范围</th><th>含义</th></tr></thead><tbody><tr><td>0 到 <strong>WM_USER</strong> –1</td><td>保留供系统使用的消息。</td></tr><tr><td>通过 0x7FFF <strong>进行WM_USER</strong></td><td>用于专用窗口类的整数消息。</td></tr><tr><td>通过0xBFFF <a href="https://learn.microsoft.com/zh-CN/windows/win32/winmsg/wm-app"><strong>WM_APP (0x8000)</strong></a></td><td>可供应用程序使用的消息。</td></tr><tr><td>通过 0xFFFF 进行0xC000</td><td>应用程序使用的字符串消息。</td></tr><tr><td>大于 0xFFFF</td><td>系统保留。</td></tr></tbody></table><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">// 定义自己的消息</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_MESSAGE WM_USER + 2</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;window&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(DKGRAY_BRUSH); <span class="comment">// background color</span></span><br><span class="line">    wc.hIcon = <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, IDI_APPLICATION);              <span class="comment">// window&#x27;s icon</span></span><br><span class="line">    wc.hCursor = <span class="built_in">LoadCursor</span>(<span class="literal">NULL</span>, IDC_ARROW);                <span class="comment">// window&#x27;s cursor</span></span><br><span class="line">    wc.hInstance = hInstance;                                <span class="comment">// window&#x27;s instance</span></span><br><span class="line">    wc.lpfnWndProc = WinProc;                                <span class="comment">// window process callback</span></span><br><span class="line">    wc.lpszClassName = CLASSNAME;                            <span class="comment">// name of the window class</span></span><br><span class="line">    wc.lpszMenuName = <span class="literal">NULL</span>;                                  <span class="comment">// name of the menu</span></span><br><span class="line">    wc.style = CS_HREDRAW | CS_VREDRAW;                      <span class="comment">// window style</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>,                   <span class="comment">// optional window style</span></span><br><span class="line">        CLASSNAME,           <span class="comment">// window class</span></span><br><span class="line">        TITLE,               <span class="comment">// window title</span></span><br><span class="line">        WS_OVERLAPPEDWINDOW, <span class="comment">//window style</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// width and height</span></span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT, </span><br><span class="line">        <span class="comment">// x y</span></span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line"></span><br><span class="line">        <span class="literal">NULL</span>,                <span class="comment">// parent window</span></span><br><span class="line">        <span class="literal">NULL</span>,                <span class="comment">// menu</span></span><br><span class="line">        hInstance,           <span class="comment">// instance handle</span></span><br><span class="line">        <span class="literal">NULL</span>                 <span class="comment">// additional application data</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (hwnd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在鼠标左键时发送消息处理，并获得处理结果</span></span><br><span class="line">        LRESULT nRet = <span class="built_in">SendMessage</span>(hwnd, MY_MESSAGE, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (nRet == <span class="number">114514</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;好臭的处理方式!&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;差评&quot;</span>), MB_ICONWARNING);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理自定义消息</span></span><br><span class="line">    <span class="keyword">case</span> MY_MESSAGE:</span><br><span class="line">        <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;处理我自己的消息！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;MY_MESSAGE&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">114514</span>; <span class="comment">// 返回处理结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行此代码，应该在鼠标左键时弹出一个消息框显示”处理我自己的消息！”，然后显示”好臭的处理方式!”。</p><p>本期到此结束，下期看星光探索者探索使用计时器和菜单，图标，光标等资源文件</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：创建自己的窗口和探索消息机制</title>
      <link href="/blogs/posts/windows/p94939f4d9192.html"/>
      <url>/blogs/posts/windows/p94939f4d9192.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="创建自己的窗口"><a href="#创建自己的窗口" class="headerlink" title="创建自己的窗口"></a>创建自己的窗口</h2><p>前两期的探索内容并没有创建属于自己的窗口，那么我们应该如何创建属于自己的窗口呢？</p><p>一提到窗口，你很可能会想到下面的画面</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oRAA.png"></p><p>没错，这就是一个窗口！实际上，这个应用程序的所有按钮，文本编辑框，菜单都是窗口。有的时候，我们在使用办公软件（如WPS，微软办公套件等），或浏览器时，我们通过点击一下鼠标右键，就弹出了一个菜单，俗称右键菜单。这个右键菜单也可以是窗口，当右键菜单没显示的时候，我们按了一下右键，他就显示了。这样看来，<strong>窗口既可以是显示的，也可以是不显示的</strong>。</p><p>因而，我们可以认为窗口是：</p><ul><li>占据屏幕的某些部分。</li><li>在给定时刻可能看不到或可能不可见。</li><li>了解如何绘制自身。</li><li>响应用户或操作系统的事件。</li></ul><p>说了这么多，让我们一起探索如何创造自己的窗口吧！</p><p>一个完整的窗口程序需要这些步骤：注册窗口类、创建窗口、处理消息。话不多说，看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果报错unresolved symbol无法解析的外部符号错误，就手动链接下面的库</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明窗口处理函数，用于处理窗口消息</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;window&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WNDCLASS 是窗口类结构体</span></span><br><span class="line">    <span class="comment">// 窗口类结构体至少要给 lpfnWndProc，hInstance, lpszClassName</span></span><br><span class="line">    <span class="comment">// 这些属性赋值，否则创建窗口不会成功</span></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(DKGRAY_BRUSH); <span class="comment">// 窗口的背景颜色</span></span><br><span class="line">    wc.hIcon = <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, IDI_APPLICATION);              <span class="comment">// 标题栏图标样式</span></span><br><span class="line">    wc.hCursor = <span class="built_in">LoadCursor</span>(<span class="literal">NULL</span>, IDC_ARROW);                <span class="comment">// 鼠标样式</span></span><br><span class="line">    wc.hInstance = hInstance;                                <span class="comment">// 实例句柄</span></span><br><span class="line">    wc.lpfnWndProc = WinProc;                                <span class="comment">// 窗口过程函数</span></span><br><span class="line">    wc.lpszClassName = CLASSNAME;                            <span class="comment">// 窗口类名称</span></span><br><span class="line">    wc.lpszMenuName = <span class="literal">NULL</span>;                                  <span class="comment">// 窗口菜单名称</span></span><br><span class="line">    wc.style = CS_HREDRAW | CS_VREDRAW;                      <span class="comment">// 窗口风格</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步：注册窗口类</span></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：创建窗口</span></span><br><span class="line">    <span class="comment">// 调这个函数，返回窗口句柄，如果创建窗口失败，返回NULL</span></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>,                   <span class="comment">// 窗口的其他风格</span></span><br><span class="line">        CLASSNAME,           <span class="comment">// 窗口类名</span></span><br><span class="line">        TITLE,               <span class="comment">// 窗口标题栏文字</span></span><br><span class="line">        WS_OVERLAPPEDWINDOW, <span class="comment">// 窗口风格</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// CW_USEDEFAULT 表示使用默认值</span></span><br><span class="line">        <span class="comment">// 窗口初始宽度和高度</span></span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT, </span><br><span class="line">        <span class="comment">// 窗口初始x坐标和y坐标</span></span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line"></span><br><span class="line">        <span class="literal">NULL</span>,                <span class="comment">// 父窗口</span></span><br><span class="line">        <span class="literal">NULL</span>,                <span class="comment">// 菜单</span></span><br><span class="line">        hInstance,           <span class="comment">// 当前实例句柄</span></span><br><span class="line">        <span class="literal">NULL</span>                 <span class="comment">// 附加的内存</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 判断窗口是否创建成功</span></span><br><span class="line">    <span class="keyword">if</span> (hwnd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建窗口失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 展示窗口（第一个参数为要展示的窗口句柄，第二个参数为显示的方式）</span></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="comment">// 更新窗口</span></span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行消息循环</span></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// GetMessage函数用于抓取窗口的消息，这样才能操作窗口</span></span><br><span class="line">    <span class="comment">// 如果抓不到消息，GetMessage返回0，也就是说应用程序该结束了</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 翻译消息（非必要步骤），如果要处理键盘事件，需要翻译消息</span></span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="comment">// 分发消息（必要步骤，否则窗口无法得到消息）</span></span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口处理函数</span></span><br><span class="line"><span class="comment">// @param hwnd 窗口的句柄</span></span><br><span class="line"><span class="comment">// @param uMsg 消息类型</span></span><br><span class="line"><span class="comment">// @param wParam, lParam 窗口消息的两个附加信息，不同的消息，值是不同的</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 处理窗口摧毁消息</span></span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>); <span class="comment">// 发送退出消息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认的窗口消息处理函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译此段代码，可以看到下面的结果：</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oD1K.png"></p><p>成功创建出窗口了！</p><h2 id="过程解析"><a href="#过程解析" class="headerlink" title="过程解析"></a>过程解析</h2><p>首先是WNDCLASS结构体，示例代码已经大部分标的很清楚了。官网上介绍的比星光探索者探索到的还要详细，<a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winuser/ns-winuser-wndclassa">点击查看官网介绍WNDCLASS窗口类结构体</a>！</p><p>在示例代码中，调用了LoadIcon,LoadCursor来加载图标资源，原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HICON <span class="title">LoadIcon</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,  <span class="comment">// 加载资源的实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpIconName    <span class="comment">// 图标名称字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">HCURSOR <span class="title">LoadCursor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance, <span class="comment">// 加载资源的实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpCursorName <span class="comment">// 加载光标名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>Windows的数据类型，如果以<code>H</code>开头，大多都是…的句柄的意思。</p><p>接下来是<a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindoww">RegisterWindow函数</a>，<a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winuser/nf-winuser-createwindoww">CreateWindow函数</a>，这些都是宏定义，都是根据程序使用的字符集来选择调用哪个版本的。例如CreateWindow如果是多字节字符集，将调用CreateWindowA版本，如果是Unicode字符集，将调用CreateWindowW版本，很多皆是如此。</p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-showwindow">ShowWindow 函数</a>和<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-updatewindow">UpdateWindow 函数</a>参数都很简单。</p><p><strong>(重点内容)</strong> 窗口过程函数，是处理窗口消息的函数。Windows是基于消息系统的，当鼠标点击窗口或键盘输入时，将发送相应消息给窗口。因而窗口过程函数即为重要。窗口过程函数写法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WinProc是窗口处理函数的名称，可以随便改</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hwnd,     <span class="comment">// 处理消息的窗口句柄 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT uMsg,     <span class="comment">// 窗口消息</span></span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam, <span class="comment">// 窗口消息附带的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam  <span class="comment">// 窗口消息附带的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>此函数的返回值为窗口消息的处理结果，int类型可以转换成HRESULT类型，大多数情况下返回0表示正常处理。</p><p>如果不处理消息，可交给默认的过程函数DefWinProc处理。但是如果不正确处理相关消息，可能会导致窗口关不了，窗口没了进程还在的情况。</p><h2 id="Windows消息机制"><a href="#Windows消息机制" class="headerlink" title="Windows消息机制"></a>Windows消息机制</h2><p>Windows是以消息为基础的操作系统。消息(MSG类型)组成如下：</p><ul><li><p>窗口句柄</p></li><li><p>消息ID</p></li><li><p>消息的两个附带信息</p></li><li><p>消息产生时间</p></li><li><p>消息产生时的鼠标位置</p></li></ul><p><strong>当系统通知窗口工作时，采用消息的方式派发给窗口</strong>。(本段落以下内容引用自微软官网)如果顶级窗口停止响应消息超过几秒钟，系统将认为窗口不会响应。 在这种情况下，系统会隐藏窗口，并将其替换为具有相同 Z 顺序、位置、大小和视觉属性的幽灵窗口。 这样，用户就可以移动它、调整大小，甚至关闭应用程序。 但是，这些操作是唯一可用的操作，因为应用程序实际上没有响应。 在调试器模式下，系统不会生成虚影窗口。</p><p>消息队列，顾名思义就是储存消息的队列，<strong>队列具有先进先出(First in first out, FIFO)</strong> 的特性。操作系统本身就维护有消息队列，每个应用程序也会有他自己的消息队列。</p><p>但是，并不是所有的消息都会进消息队列，有的消息是直接让窗口处理不进消息队列的。因此，根据消息进不进消息队列，我们可将消息分为<strong>队列消息和非队列消息</strong>。</p><ul><li><p>队列消息：消息发送时，首先进入队列，然后通过消息循环，从队列当中获取。常见的队列消息有WM_PAINT，键盘消息，鼠标消息，定时器消息等</p></li><li><p>非队列消息：消息发送时，直接找到消息接收窗口的窗口过程函数，直接调用此函数完成消息。常见的非队列消息有WM_CREATE，WM_SIZE等</p></li></ul><p>上面说的都是常见的队列消息和非队列消息，只要你想让他进队列，他就是队列消息，否则是非队列消息。</p><h2 id="抓取消息的API"><a href="#抓取消息的API" class="headerlink" title="抓取消息的API"></a>抓取消息的API</h2><p> <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessage">GetMessage函数</a>。 上面的消息循环就是用的这个抓取队列中的消息。如果这个函数的最后两个参数都为0，什么消息都抓取。一般不返回非0值。当遇到WM_QUIT消息（使应用程序退出的消息）时，GetMessage将返回FALSE。GetMessage函数是阻塞函数，如果没有消息会一直等待。</p><p>GetMessage函数在工作时，会按顺序执行下列步骤：</p><ul><li><p>在程序（线程）消息队列中查找消息，如果队列有消息，检查是否满足抓取消息的范围，满足就抓取</p></li><li><p>如果程序（线程）消息队列没有消息，向系统队列获取属于本程序的消息，如果有就转发到程序的消息队列。</p></li><li><p>如果还是没有消息，检查当前进程的所有窗口有没有需要重绘的区域，如果发现有需要绘制的区域，产生WM_PAINT消息，然后处理</p></li><li><p>如果没有重绘区域，检查计时器有没有到时的计时器，如果有将产生WM_TIMER消息，然后处理</p></li><li><p>如果没有计时器，就整理程序资源，内存等</p></li><li><p>如果执行到了这一步，GetMessage就会一直等候，直到消息有为止</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPMSG lpMsg,         <span class="comment">// 抓取到消息储存的消息结构体</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HWND  hWnd,          <span class="comment">// 抓取消息的窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT  wMsgFilterMin, <span class="comment">// 抓取消息的最小值</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT  wMsgFilterMax  <span class="comment">// 抓取消息的最大值</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-peekmessagew">PeekMessage函数</a>用于以查看的方式查看队列有没有消息，如果没有消息返回0，否则返回非0值。这个函数的前四个参数与GetMessage函数意义完全相同，第五个参数的意义为如果有消息，如果值为PM_NOREMOVE，将不从消息队列中移除这个消息，如果值为PM_REMOVE，将从消息队列中移除这个消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PeekMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPMSG lpMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND  hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT  wMsgFilterMin,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT  wMsgFilterMax,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT  wRemoveMsg</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="发送消息的API"><a href="#发送消息的API" class="headerlink" title="发送消息的API"></a>发送消息的API</h2><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-sendmessage">SendMessage 函数 </a>用于向指定窗口句柄的窗口发送消息，这种方式发送的消息是不进消息队列的。此函数会一直等待消息处理结果，其返回值即为目标窗口的处理结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">SendMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND   hWnd,   <span class="comment">// 指定的窗口句柄 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT   Msg,    <span class="comment">// 发送的消息类型   </span></span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam, <span class="comment">// 消息附带的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam  <span class="comment">// 消息附带的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-postmessagew">PostMessage函数</a>用于向指定窗口句柄的窗口发送消息，这种方式发送的消息进消息队列。此函数发送完马上返回，不等待消息处理结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PostMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HWND   hWnd,   <span class="comment">// 指定的窗口句柄 </span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT   Msg,    <span class="comment">// 发送的消息类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">  WPARAM wParam, <span class="comment">// 消息附带的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPARAM lParam  <span class="comment">// 消息附带的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>本期到此结束，下期看星光探索者处理常用的消息及自定义消息</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：常用基本数据类型和字符编码</title>
      <link href="/blogs/posts/windows/pd3e66887a323.html"/>
      <url>/blogs/posts/windows/pd3e66887a323.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="常用基本数据类型"><a href="#常用基本数据类型" class="headerlink" title="常用基本数据类型"></a>常用基本数据类型</h2><p>windows定义了很多基本数据类型，常用的有下列等效定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONST const</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VOID void</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> CHAR;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> SHORT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> LONG;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">wchar_t</span> WCHAR;</span><br><span class="line"><span class="keyword">typedef</span> SHORT *PSHORT;  </span><br><span class="line"><span class="keyword">typedef</span> LONG *PLONG;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 字节的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>       DWORD;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>                 BOOL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>       BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>      WORD;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span>               FLOAT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子类型</span></span><br><span class="line"><span class="keyword">typedef</span> WORD                ATOM;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE <span class="comment">// 如果定义了UNICODE宏</span></span></span><br><span class="line"><span class="keyword">typedef</span> WCHAR TCHAR, *PTCHAR;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> CHAR TCHAR, *PTCHAR;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CHAR类型字符串</span></span><br><span class="line"><span class="keyword">typedef</span> CHAR *LPSTR, *PSTR;</span><br><span class="line"><span class="comment">// CONST CHAR类型字符串</span></span><br><span class="line"><span class="keyword">typedef</span> CONST CHAR *LPCSTR, *PCSTR;</span><br><span class="line"><span class="comment">// WCHAR类型字符串</span></span><br><span class="line"><span class="keyword">typedef</span> WCHAR *LPWSTR, *PWSTR;</span><br><span class="line"><span class="comment">// COSNT WCHAR类型字符串</span></span><br><span class="line"><span class="keyword">typedef</span> CONST WCHAR *LPCWSTR, *PCWSTR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TCHAR类型的字符串</span></span><br><span class="line"><span class="keyword">typedef</span> TCHAR *PTSTR, *LPTSTR;</span><br><span class="line"><span class="comment">// CONST TCHAR类型字符串</span></span><br><span class="line"><span class="keyword">typedef</span> CONST TCHAR *PCTSTR, *LPCTSTR;</span><br></pre></td></tr></table></figure><p>这些是主要的类型，各位小伙伴初次看到时都会感到比较难以下手，我们只需要大概了解就可以了，毕竟有文档在，况且我们可以随时查看这些函数的定义。</p><p>这些基本数据类型的定义是有规律的，例如带有<code>P</code>的表明这个类型是指针类型，例如LPSTR(char*), PVOID(void*)，带有<code>STR</code>的表明这是一个字符串，例如PSTR(char*), PTSTR(TCHAR*)，带有<code>C</code>表示具有const属性例如PCWSTR(const wchar_t *)，非常好记。</p><p>还有BOOL定义为int，并不是bool，返回BOOL类型时应该返回TRUE(1)或FALSE(0)</p><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>字符(character)是各位文字和符号的总称，字符集（Character set）是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同，常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、 GB18030字符集、Unicode字符集等。计算机要准确的处理各类字符集，需要进行字符编码。实际上字符都是通过数值表示的。</p><p>下面来探索部分字符集：</p><h3 id="ASCII-字符集"><a href="#ASCII-字符集" class="headerlink" title="ASCII 字符集"></a>ASCII 字符集</h3><p>ASCII (American Standard Code for Information Interchange，美国信息互换标准编码）是基于罗马字母表的一套电脑编码系统，主要用于显示英语和其他西欧语言。ASCII字符集用7位表示一个字符，共128个字符，字符值从0到127，其中32到126是可打印字符。7位编码的字符集只能表示128个字符，为了表示更多的字符，ASCII扩展字符集使用8位（bits）表示一个字符，共256字符。</p><h3 id="GB2313字符集"><a href="#GB2313字符集" class="headerlink" title="GB2313字符集"></a>GB2313字符集</h3><p>GB2312又称为GB2312-80字符集，全称为《信息交换用汉字编码字符集·基本集》，由原中国国家标准总局发布，1981年5月1日实施。是中国国家标准的简体中文字符集，他收录的汉字已经覆盖99.75%的使用评率，基本满足了汉字的计算机处理需要。</p><h3 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h3><p>Unicode字符集是Universal Multiple-Octet Coded Character Set 通用多八位编码字符集的简称，支持现今世界各种不同语言的书面文本的交换、处理及显示。</p><p>因此Win32程序使用不同的字符集，将调用不同的API函数。</p><p>下列代码展示如何处理各种字符集的打印方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印多字节字符集使用这个\n&quot;</span>);</span><br><span class="line">    <span class="built_in">wprintf</span>(<span class="string">L&quot;%ls\n&quot;</span>, <span class="string">L&quot;打印Unicode字符集使用这个&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行这段代码，看到printf正常打印，wprintf打印不出正确内容的运行结果(各位可以尝试一下，wprintf打印宽字符集，也就是Unicode字符，目前大多都是不成功的)</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oBp6.png"></p><p>为什么会这样呢？因为wprintf目前对Unicode的支持还不是很好，为了能正常打印，在Windows我们可以使用<a href="https://learn.microsoft.com/zh-cn/windows/console/writeconsole">WriteConsole函数</a>，看下列代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">wchar_t</span> content[] = <span class="string">L&quot;打印Unicode字符集的解决方案&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得标准输出句柄 STD_OUTPUT_HANDLE</span></span><br><span class="line">    <span class="comment">// 还可以获得标准输入句柄，标准错误句柄等</span></span><br><span class="line">    <span class="comment">// HANDLE是句柄类型</span></span><br><span class="line">    HANDLE hOut = <span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制台输出信息</span></span><br><span class="line">    <span class="built_in">WriteConsole</span>(hOut, content, <span class="built_in">wcslen</span>(content), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于TCHAR类型的字符串，计算长度因使用lstrlen</span></span><br><span class="line">    TCHAR szText = <span class="built_in">TEXT</span>(<span class="string">&quot;好！&quot;</span>);</span><br><span class="line">    <span class="built_in">WriteConsole</span>(hOut, szText, <span class="built_in">lstrlen</span>(szText), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一编译，可以看到程序正确打印，非常好。</p><p><a href="https://learn.microsoft.com/zh-cn/windows/console/writeconsole">点我查看WriteConsole函数有关信息</a></p><p>本期到此结束，下期看星光探索者探索Windows如何创建自己的窗口和探索消息机制</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：第一个Win32程序</title>
      <link href="/blogs/posts/windows/p83a7b5481c29.html"/>
      <url>/blogs/posts/windows/p83a7b5481c29.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="探索Windows程序类型"><a href="#探索Windows程序类型" class="headerlink" title="探索Windows程序类型"></a>探索Windows程序类型</h2><p>我们可以给Windows程序分类</p><ul><li><p>控制台程序Console</p><p>DOS程序，本身没有窗口，通过Windows DOS窗口执行。</p><p>在Windows通常为.exe文件，控制台程序的入口为main函数</p></li><li><p>窗口程序</p><p>拥有自己的窗口，可以和用户交互</p><p>通常为.exe文件，情况下窗口程序的入口为WinMain函数</p></li><li><p>库程序</p><p>存放代码，数据的程序，执行文件可以从中取出代码执行和获取数据</p><ul><li><p>静态库程序：拓展名.lib。在链接阶段将代码放入可执行文件中，无入口函数</p></li><li><p>动态库程序：拓展名.dll。在执行文件中执行时从中获得代码，入口函数为DllMain</p></li></ul></li></ul><h2 id="编译工具"><a href="#编译工具" class="headerlink" title="编译工具"></a>编译工具</h2><p>通常编写Win32程序应该使用微软的工具，毕竟Windows是微软的。</p><p>下面让我们一起探索Visual C++的编译工具吧！</p><p>编译器cl.exe：将源代码(.c或.cpp)编译成目标代码.obj</p><p>链接器link.exe：将目标代码，资源，库等链接，生成最终文件</p><p>资源编译器rc.exe：将资源文件(.rc)将资源编译成.res文件，最终通过链接器写入最终文件</p><p>如果你安装了Visual Studio，那么这些编译工具的路径可能为：</p><p>C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.34.31931\bin\Hostx64\x64\</p><h2 id="Windows库和头文件"><a href="#Windows库和头文件" class="headerlink" title="Windows库和头文件"></a>Windows库和头文件</h2><p>下面只是列举部分库和对应的头文件，并不是全部内容</p><ul><li><p>kernel32.dll 提供了核心的API，如进程，线程，内存管理</p></li><li><p>user32.dll 提供了窗口，消息等用户常用的API</p></li><li><p>gdi32.dll 绘图相关的API</p></li></ul><p>路径： C:\Windows\System32\</p><p>Windows的头文件</p><ul><li><p>windows.h 大部分Windows头文件的集合，包含了下列提到的头文件等文件</p></li><li><p>windef.h windows基本数据类型定义</p></li><li><p>winbase.h kernel32.dll 的API</p></li><li><p>wingdi.h gdi32.dll的API</p></li><li><p>winuser.h user32.dll的API</p></li><li><p>winnt.h UNICODE字符集的支持</p></li></ul><p>路径：C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.34.31931\include</p><h2 id="第一个Win32程序"><a href="#第一个Win32程序" class="headerlink" title="第一个Win32程序"></a>第一个Win32程序</h2><p>首先先新建一个文件夹，并创建test.cpp源代码文件，在test.cpp文件书写这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">INT WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,      <span class="comment">// 当前实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,  <span class="comment">// 上一个实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,          <span class="comment">// 运行程序的命令行</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow              <span class="comment">// 程序最初显示方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;探索Windows!&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;星光探索者&quot;</span>), MB_OK);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>星光探索者非常喜欢探索，于是星光探索者在命令行调用Visual C++编译工具，输入了像这样的命令行<code>cl test.cpp</code>就可以编译这个Win32程序了。如果有的小伙伴提示错误信息unresolved symbol无法解析的外部符号，那么就需要手动链接相关的库了。MessageBox函数属于user32.dll，因此我们需要使用link指令：<code>cl test.cpp /link user32.lib</code></p><p>当然用MinGW也是可以的，只不过需要加上<code>-mwindows</code>参数，要不然MinGW不会认为是编译Win32程序，而是认为是控制台程序</p><p>运行这个程序，可以看到显示了一个消息框。</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8osXD.png"></p><h2 id="深入探索"><a href="#深入探索" class="headerlink" title="深入探索"></a>深入探索</h2><p>WinMain函数的结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,      <span class="comment">// 当前实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,  <span class="comment">// 上一个实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,          <span class="comment">// 运行程序的命令行</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow              <span class="comment">// 程序最初显示方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>hInstance</code> 为当前实例句柄。在Windows句柄的概念的随处可见</p></li><li><p><code>hPrevInstance</code> 为上一个实例句柄。他在16位Windows系统使用，现在不使用，值总是为NULL(定义为0)</p></li><li><p><code>pCmdLine</code> 包含命令行参数的字符串。如果需要获取整个命令行，请使用<code>GetCommandLine</code></p></li><li><p><code>nCmdShow</code> 窗口的最初显示方式（最小化，正常，最大化）</p></li></ul><p>这个函数返回INT(定义为int)类型的值，操作系统不使用返回值，但可以传递给其他程序</p><p>WINAPI是Windows的函数调用约定，定义为__stdcall，使用<code>APIENTRY</code>也是相同的结果</p><p>上面那个简易的程序还调用了MessageBox函数，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageBox</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HWND hWnd,          <span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpText,     <span class="comment">//弹窗内容</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpCaption,  <span class="comment">//弹窗标题</span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT uType          <span class="comment">//弹窗类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>hWnd</code> 为显示消息框的窗口句柄，也就是消息框的父窗口，如果没有父窗口就传NULL，关于窗口的更多信息下期星光探索者继续探索。 HWND类型为handle of the windows的意思。</p></li><li><p><code>lpText</code> 是一个TCHAR类型的字符串，为消息框的内容</p><p>TCHAR是windows基本数据类型，是宏定义。如果使用多字节字符集的项目，TCHAR被定义为char；如果使用Unicode字符集的项目，TCHAR被定义为wchar_t。类型<code>LPCTSTR</code>为<code>const TCHAR*</code>，在下一期会深入探索。</p></li><li><p><code>lpCaption</code>是一个TCHAR类型的字符串，为消息框的标题内容</p></li><li><p><code>uType</code>为消息框的显示按钮及消息框标题栏的图标，默认显示一个确定(OK)按钮。这个函数的返回值即为用户按下的按钮。</p><p>可选择的部分样式如下，消息框显示的按钮文本取决于系统的语言，想知道更多信息<a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winuser/nf-winuser-messagebox">请点击我！</a>：</p><p>消息框的按钮：</p><table><thead><tr><th>按钮样式</th><th>效果</th></tr></thead><tbody><tr><td>MB_OK</td><td>消息框包含一个按钮确定，这是默认值</td></tr><tr><td>MB_OKCANCEL</td><td>消息框包含两个按钮，确定取消</td></tr><tr><td>MB_YESNO</td><td>消息框包含两个按钮，是和否</td></tr><tr><td>MB_RETRYCANCEL</td><td>消息框包含两个按钮，重试或取消</td></tr></tbody></table><p> 消息框的图标：</p><table><thead><tr><th>图标样式</th><th>效果</th></tr></thead><tbody><tr><td>MB_ICONWARNING</td><td>消息框中会显示一个感叹号图标</td></tr><tr><td>MB_ICONINFORMATION</td><td>消息框会有一个圆圈，圆圈中间写着小写字母 i(意思为infomation，信息的意思)</td></tr><tr><td>MB_ICONQUESTION</td><td>消息框会显示一个问号图标</td></tr></tbody></table><p>默认选中的按钮</p><table><thead><tr><th>默认选中的按钮</th><th>效果</th></tr></thead><tbody><tr><td>MB_DEFBUTTON1</td><td>选中第一个按钮（默认值）</td></tr><tr><td>MB_DEFBUTTON2</td><td>选中第二个按钮</td></tr><tr><td>MB_DEFBUTTON3</td><td>选中第三个按钮</td></tr><tr><td>MB_DEFBUTTON4</td><td>选中第四个按钮</td></tr></tbody></table><p>等很多功能，但都是以MB_开头，可根据字面意思猜测功能。</p></li></ul><p>MessageBox的返回值为点击的按钮,都是以ID开头。例如IDOK(确认按钮)，IDCANCEL(取消按钮)</p><p>使用案例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (MBCANCEL != <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;是否重试?&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;Error&quot;</span>), MB_YSENO))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 如果消息框想用多个效果，使用 | 运算符</span></span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, </span><br><span class="line">                   <span class="built_in">TEXT</span>(<span class="string">&quot;正在重试&quot;</span>), </span><br><span class="line">                   <span class="built_in">TEXT</span>(<span class="string">&quot;fixing&quot;</span>), </span><br><span class="line">                   MB_OK | MB_ICONINFOMATION | MB_DEFBUTTON1</span><br><span class="line">    );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个TEXT是windows提供的一个宏函数，会根据当前使用的字符集将”…”这样的字符串转换成TCHAR类型的字符串。因为Windows的API要根据不同的字符集调不同的函数，对于要调API的字符串我们可以用TEXT宏来包裹</p><p>定义的效果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE  <span class="comment">// 如果使用UNICODE字符集</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXT(quote) L##quote</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXT(quote) quote</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>刚才上文提到了项目使用的字符集，那个在哪里设置呢？</p><p>打开解决方案管理器(Solution Explorer)</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8o6ne.png"></p><p>对准你要设置字符集的项目按<strong>鼠标右键</strong>，看到菜单，然后点击 <strong>属性(Properties)</strong></p><p><img src="https://s1.ax1x.com/2023/01/20/pS8owfx.png"></p><p>然后选择字符集(Character Set)，在这里就可以设置你项目使用的字符集了。</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oakR.png"></p><p>本期到此结束，下期看星光探索者探索Windows常用基本数据类型和字符编码</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
