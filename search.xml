<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>探索Windows：探索绘图编程和对话框</title>
      <link href="/blogs/posts/windows/pff3fd6e98f0e.html"/>
      <url>/blogs/posts/windows/pff3fd6e98f0e.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="探索绘图编程"><a href="#探索绘图编程" class="headerlink" title="探索绘图编程"></a>探索绘图编程</h2><p>GDI,Graphic Device Interface，Windows提供了大量API供我们绘制各种各样的图形。</p><p>Windows每个窗口都是绘制出来的，当窗口需要绘制的时候，产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/gdi/wm-paint">WM_PAINT消息</a>，进而我们可以绘制窗口。</p><p>HDC，即为设备上下文句柄，DC是设备windows特有的一个概念，我们需要使用他来绘图。</p><p>下面是简单的绘图代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyWindowApplication/resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;kernel32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;星光探索者&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hInstance = hInstance; </span><br><span class="line">    wc.lpfnWndProc = WinProc; </span><br><span class="line">    wc.lpszClassName = CLASSNAME; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>, CLASSNAME, TITLE,WS_OVERLAPPEDWINDOW, </span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT,  CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">NULL</span>,  <span class="literal">NULL</span>,  hInstance, <span class="literal">NULL</span> </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 定义绘图结构体，用来绘图</span></span><br><span class="line">        PAINTSTRUCT ps;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始绘画，得到DC</span></span><br><span class="line">        HDC hdc = <span class="built_in">BeginPaint</span>(hwnd, &amp;ps);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制图标</span></span><br><span class="line">        <span class="built_in">DrawIcon</span>(hdc, <span class="number">50</span>, <span class="number">50</span>, <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, <span class="built_in">LPCTSTR</span>(IDI_MYICON)));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i != <span class="number">40</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">10</span>; j != <span class="number">40</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 绘制一个点</span></span><br><span class="line">                <span class="built_in">SetPixel</span>(hdc, i, j, <span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束绘画</span></span><br><span class="line">        <span class="built_in">EndPaint</span>(hwnd, &amp;ps);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以简单的绘图了。只需BeginPaint获得HDC，然后调用相关的API（API直接查<a href="https://learn.microsoft.com/zh-cn/windows/win32/gdi/windows-gdi">官网相关资源</a>），然后再EndPaint，就可以了。但是并不是什么时候都可以绘图的，<strong>只有绘图消息和计时器消息发生时，绘图才会成功</strong>。</p><h2 id="使用对话框"><a href="#使用对话框" class="headerlink" title="使用对话框"></a>使用对话框</h2><p>对话框是一种窗口，他主要用于向用户显示信息或等待用户输入时的一个小弹窗。如果我们快速制作一个Win32程序，使用对话框是一种便捷方法。</p><p>同样是这个熟悉的界面，右键项目，添加(Add)，资源(Resource)</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8odt1.png"></p><p>点击对话框(Dialog)，之后VS显示了一个可视化的设计器。我们可以直接拖拽控件快速布局。大部分小伙伴都对很喜欢这种形式吧！</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8og7d.png"></p><p>为了示范，星光探索者之后就直接写代码了。</p><p>对话框根据显示后是否阻止与其他窗口交互，可分为模态对话框和非模态对话框。</p><ul><li><p>模态对话框：显示后阻止你创建的其他窗口交互</p></li><li><p>非模态对话框：显示后不阻止你创建的其他窗口交互</p></li></ul><p>模态对话框的创建方式，调用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-dialogboxw">DialogBox函数</a>。这个函数是阻塞函数，返回值为对话框销毁时的返回值。参数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT_PTR <span class="title">DialogBox</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,   <span class="comment">// 实例句柄，如果传NULL将使用当前的</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpTemplate,    <span class="comment">// 创建的资源模板，在资源文件</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWndParent,       <span class="comment">// 对话框的父窗口</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DLGPROC lpDialogFunc   <span class="comment">// 对话框消息过程处理函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>非模态对话框创建方式，调用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-createdialogw">CreateDialog函数</a>，参数如下，意义和上方相同，不多叙述。这个函数不是阻塞函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateDialog</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE  hInstance,     </span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR    lpName,</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND       hWndParent,</span></span></span><br><span class="line"><span class="params"><span class="function">    DLGPROC    lpDialogFunc</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>DLGPROC是对话框过程函数的类型，为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">INT_PTR</span> <span class="params">(CALLBACK* DLGPROC)</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br></pre></td></tr></table></figure><p>实际上和窗口消息过程函数是一模一样的。但是这个对话框过程函数的返回值如果为FALSE，表明还需要默认处理函数处理，否则不调用默认处理函数处理。</p><p>当对话框开始创建未显示时，产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/dlgbox/wm-initdialog">WM_INITDIALOG消息 </a>，不产生WM_CREATE消息。因此，对话框过程函数不应该处理WM_CREATE消息。各位感兴趣的小伙伴可验证一下。</p><p>模态对话框和非模态对话框的处理函数写法要求大不同。模态对话框销毁时使用<a href="https://learn.microsoft.com/zh-CN/windows/win32/api/Winuser/nf-winuser-enddialog">EndDialog 函数</a>，不可以使用DestroyWindow等函数；而非模态对话框销毁时使用<a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winuser/nf-winuser-destroywindow">DestroyWindow 函数</a>。</p><p>要想处理对话框内部的控件的操作，需要处理<a href="https://learn.microsoft.com/zh-cn/windows/win32/menurc/wm-command"> WM_COMMAND消息</a>。控件被点击时，lParam为控制窗口的句柄，wParam的高字节为控件的消息，低字节为控件ID标识符</p><p>下面是一个模态对话框的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;kernel32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;星光探索者&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(WHITE_BRUSH);</span><br><span class="line">    wc.hInstance = hInstance; </span><br><span class="line">    wc.lpfnWndProc = WinProc; </span><br><span class="line">    wc.lpszClassName = CLASSNAME; </span><br><span class="line">    wc.style = CS_HREDRAW | CS_VREDRAW; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>,CLASSNAME, TITLE, WS_OVERLAPPEDWINDOW, </span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span> </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">        <span class="comment">// 处理对话框被创建的消息</span></span><br><span class="line">        <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;对话框被创建&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;探索对话框&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="comment">// 处理对话框被点击的消息</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// IDOK和IDCANCEL都是定义好的，分别代表OK和CANCEL按钮</span></span><br><span class="line">        <span class="keyword">case</span> IDOK:</span><br><span class="line">            <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;我也觉得OK&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;来自对话框的信息&quot;</span>), MB_OK);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        <span class="keyword">case</span> IDCANCEL:</span><br><span class="line">            <span class="built_in">EndDialog</span>(hwnd, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_RBUTTONDOWN:</span><br><span class="line">        <span class="built_in">DialogBox</span>(<span class="literal">NULL</span>, (LPCTSTR)IDD_DIALOG1, hwnd, DialogProc);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个实例，当我们鼠标右键的时候，弹出一个消息框后弹出对话框。点击OK按钮，将显示“我也觉得OK啊“；点击CANCEL按钮，将关闭对话框。</p><h2 id="使用系统定义好的控件"><a href="#使用系统定义好的控件" class="headerlink" title="使用系统定义好的控件"></a>使用系统定义好的控件</h2><p>对话框里能拖出这么多控件，实际上系统已经提前定义好了一些控件。</p><p>包含头文件<code>CommCtrl.h</code>，这个头文件定义了很多<a href="https://learn.microsoft.com/zh-cn/windows/win32/controls/common-control-window-classes">定义好的系统窗口类 </a>。但是你需要在<code>#include &lt;windows.h&gt;</code>头文件后再<code>#include &lt;CommCtrl.h&gt;</code>，因为你微软居然要用windows.h头文件，居然不包含，导致编译的时候提示有很多标识符未定义，不这么做会报错。</p><p>系统已经定义好的控件包括WC_BUTTON(按钮)，WC_EDIT(文本编辑框)，WC_STATIC(不可改文本控件)，WC_TREEVIEW(树状图)，ANIMATE_CLASS(动画)等。</p><p>窗口控件的消息，是通过<a href="https://learn.microsoft.com/zh-cn/windows/win32/menurc/wm-command">WM_COMMAND消息</a>间接传上来的。 <strong>控件被点击时，lParam为控制窗口的句柄，wParam的高字节为控件的消息，低字节为控件ID标识符。</strong> 这个在对话框消息过程函数已经提及。</p><p>看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;CommCtrl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;kernel32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;星光探索者&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(WHITE_BRUSH);</span><br><span class="line">    wc.hInstance = hInstance; </span><br><span class="line">    wc.lpfnWndProc = WinProc; </span><br><span class="line">    wc.lpszClassName = CLASSNAME; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>,CLASSNAME, TITLE, WS_OVERLAPPEDWINDOW, </span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span> </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// GetModuleHandle用于获得程序的hInstance，</span></span><br><span class="line">        <span class="comment">// 就是WinMain函数那里的hInstnace</span></span><br><span class="line">        HINSTANCE hInstance = <span class="built_in">GetModuleHandle</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// WC_BUTTON是按钮类，BS_PUSHBUTTON是按钮的风格</span></span><br><span class="line">        <span class="comment">// 下方的代码创建了一个按钮</span></span><br><span class="line">        <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">            <span class="number">0</span>, WC_BUTTON, <span class="built_in">TEXT</span>(<span class="string">&quot;BUTTON&quot;</span>), </span><br><span class="line">             WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, </span><br><span class="line">            <span class="number">5</span>, <span class="number">5</span>, <span class="number">100</span>, <span class="number">100</span>, hwnd, </span><br><span class="line">            <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="comment">// 控件的消息通过wParam间接传递</span></span><br><span class="line">        <span class="comment">// BN_CLICKED是按钮被点击时产生的消息</span></span><br><span class="line">        <span class="comment">// 点击下方链接查看按钮的部分相关内容 </span></span><br><span class="line">        <span class="comment">// https://zhuanlan.zhihu.com/p/353558221</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">HIWORD</span>(wParam) == BN_CLICKED)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;按钮被点击！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;你好！&quot;</span>), MB_OK);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行本程序，可以看到成功创建了一个按钮，并且点击之后会弹出“按钮被点击”的消息框。</p><h2 id="阶段小结"><a href="#阶段小结" class="headerlink" title="阶段小结"></a>阶段小结</h2><p>经过了好几篇文章的探索，想必你对Win32程序设计有了更深一步的了解，可以继续探索Windows了。转眼间春节就要到了，星光探索者祝各位春节快乐！</p><p>本期到此结束！感谢各位小伙伴的阅读！</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：使用计时器和菜单，图标，光标等资源文件</title>
      <link href="/blogs/posts/windows/p71040f0575db.html"/>
      <url>/blogs/posts/windows/p71040f0575db.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="使用计时器"><a href="#使用计时器" class="headerlink" title="使用计时器"></a>使用计时器</h2><p>计时器是Windows的一种资源。定时器每隔一段时间，会产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/winmsg/wm-timer">WM_TIMER消息 </a>。WM_TIMER附带的两个信息wParam, lParam分别是计时器的id, 计时器到点的处理函数。定时器的精度是毫秒，但是准确度不好。也就是说如果设置间隔1000ms，不一定会在1000ms后刚好产生消息。但是误差不会这么大，最多也就几毫秒。</p><p>要使用计时器，需要用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-settimer">SetTimer函数</a>创建定时器。SetTimer的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT_PTR <span class="title">SetTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND      hWnd,       <span class="comment">// 计时器关联的窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT_PTR  nIDEvent,   <span class="comment">// 计时器的ID，自己随意定，但不能为0</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT      uElapse,    <span class="comment">// 计时器的间隔，单位毫秒</span></span></span></span><br><span class="line"><span class="params"><span class="function">    TIMERPROC lpTimerFunc <span class="comment">// 计时器到点的处理函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数返回创建的计时器ID，如果创建失败了返回0。如果<code>lpTimerFunc</code>传的是NULL，计时器的时间到了，就将发送WM_TIMER消息通知关联的窗口过程函数处理，否则就不发WM_TIMER消息，直接调用<code>lpTimerFunc</code>处理。计时器依赖于消息循环，也就是要使用计时器，就需要消息循环。</p><p><a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winuser/nc-winuser-timerproc">TIMERPROC </a>是计时器回调函数的类型，因此计时器回调函数lpTimeProc因定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> CALLBACK <span class="title">lpTimerProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HWND hWnd,         <span class="comment">// 与计时器关联</span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT nMsg,         <span class="comment">// 消息类型(WM_TIMER)</span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT_PTR uTImerid, <span class="comment">// 计时器ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwTime       <span class="comment">// 时间延迟</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>计时器是系统资源，销毁计时器使用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-killtimer">KillTimer 函数 </a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">KillTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND     hWnd,    <span class="comment">// 销毁计时器的关联窗口</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT_PTR uIDEvent</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>示例代码：创建两个计时器，时间间隔分别为1000毫秒和2000毫秒，每调一次将打印一些字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 各位如果用Visual Studio开发工具，可能会出现某些函数VS觉得不安全不给用</span></span><br><span class="line"><span class="comment">// 如果还是想用，加上这句语句</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;kernel32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;window&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(DKGRAY_BRUSH);</span><br><span class="line">    wc.hIcon = <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, IDI_APPLICATION);</span><br><span class="line">    wc.hCursor = <span class="built_in">LoadCursor</span>(<span class="literal">NULL</span>, IDC_ARROW);  </span><br><span class="line">    wc.hInstance = hInstance; </span><br><span class="line">    wc.lpfnWndProc = WinProc; </span><br><span class="line">    wc.lpszClassName = CLASSNAME; </span><br><span class="line">    wc.lpszMenuName = <span class="literal">NULL</span>; </span><br><span class="line">    wc.style = CS_HREDRAW | CS_VREDRAW; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>,CLASSNAME, TITLE, WS_OVERLAPPEDWINDOW, </span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>,  hInstance, <span class="literal">NULL</span> </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> UINT_PTR timer1, timer2;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">FreeConsole</span>();</span><br><span class="line">        <span class="comment">// 销毁定时器</span></span><br><span class="line">        <span class="built_in">KillTimer</span>(hwnd, timer1);</span><br><span class="line">        <span class="built_in">KillTimer</span>(hwnd, timer2);</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">        <span class="built_in">AllocConsole</span>();</span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;CONOUT$&quot;</span>, <span class="string">&quot;w+t&quot;</span>, stdout);</span><br><span class="line">        <span class="comment">// 创建定时器</span></span><br><span class="line">        timer1 = <span class="built_in">SetTimer</span>(hwnd, <span class="number">1</span>,</span><br><span class="line"> <span class="number">1000</span>, <span class="literal">NULL</span>);</span><br><span class="line">        timer2 = <span class="built_in">SetTimer</span>(hwnd, <span class="number">2</span>, <span class="number">2000</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">case</span> WM_TIMER: </span><br><span class="line">        <span class="comment">// 处理计时器消息</span></span><br><span class="line">        <span class="keyword">if</span> (wParam == timer1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;timer1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wParam == timer2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;timer2\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用菜单资源"><a href="#使用菜单资源" class="headerlink" title="使用菜单资源"></a>使用菜单资源</h2><p>我们创建窗口时很想让这个窗口显示自己的东西，那么我们应该怎么做呢？</p><p>星光探索者前面的说过有个资源编译器rc.exe，可以编译资源文件。首先我们先探索一下如何添加资源吧！</p><p>对准想添加资源的项目右键，弹出下面的菜单。依次点击添加(Add)，资源(Resource)即可。</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oN79.png"></p><p>然后弹出这样的对话框，选择菜单(Menu)，然后点击新建（New）</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8odt1.png"><br>然后将会在Visual Studio弹出可视化的编辑器。相信不用星光探索者多说，各位小伙伴都会摸索的出来如何添加菜单项吧。</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oc0H.png"></p><p>之后在你的项目管理器会添加一个resource.h（可以改名）头文件，和拓展名为.rc的资源文件。资源文件是一种用脚本语言书写的代码文件，当然如果小伙伴乐意，可手写资源文件。在编译过程中，资源文件会被资源编译器(在VC++是rc.exe)编译成.rsc的目标文件，进而通过链接器(在VC++是link.exe)编译成最终文件。</p><p>资源创建了，如何使用呢？刚才添加的resource.h文件定义了那些ID标识符。在打开的资源管理器(Resource View)中，选中添加的菜单，然后右键，点击(Resource Symbol)即可查看添加的资源的id。星光探索者这里创建的菜单ID为IDC_MENU1。当然也可以直接查看resource.h头文件</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8ot0J.png"></p><p>还记得创建窗口类时的WNDCLASS结构体吗？那里有一个lpszMenuName属性，给他赋值就可以使用我们添加的菜单资源了。lpszMenuName需要LPCTSTR的类型，资源文件定义的ID都是数值，我们只需进行强制转换即可。或者CreateWindowEx的第10个参数也是叫传菜单句柄的，也可以选择在那里使用菜单资源。</p><p>既然有了菜单，我们就应该处理菜单的相关消息。处理菜单消息应该处理<a href="https://learn.microsoft.com/zh-cn/windows/win32/menurc/wm-command">WM_COMMAND消息</a>。当窗口内的控件（如按钮，文本等）被点击时，或菜单项被点击时，或窗口标题栏那些按钮（如最小化）被点击时产生此消息。当菜单项被点击时，wParam的高字节为0，低字节为点击的菜单项ID，菜单项ID之前已探索过如何找到。</p><p>于是我们写出像下面这样的代码来使用菜单资源：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;kernel32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;window&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(DKGRAY_BRUSH);</span><br><span class="line">    wc.hIcon = <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, IDI_APPLICATION);</span><br><span class="line">    wc.hCursor = <span class="built_in">LoadCursor</span>(<span class="literal">NULL</span>, IDC_ARROW);  </span><br><span class="line">    wc.hInstance = hInstance; </span><br><span class="line">    wc.lpfnWndProc = WinProc; </span><br><span class="line">    wc.lpszClassName = CLASSNAME; </span><br><span class="line">    <span class="comment">// 强制转换即可使用，星光探索者这里的菜单资源为 IDR_MENU1</span></span><br><span class="line">    wc.lpszMenuName = (LPCWSTR)IDR_MENU1; </span><br><span class="line">    wc.style = CS_HREDRAW | CS_VREDRAW; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>,CLASSNAME, TITLE, WS_OVERLAPPEDWINDOW, </span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="comment">// CreateWindowEx的第10个参数也是叫传菜单句柄的</span></span><br><span class="line">        <span class="comment">// 也可以使用LoadMenu来加载菜单资源</span></span><br><span class="line">        <span class="comment">//LoadMenu(NULL, LPCTSTR(IDR_MENU1)), </span></span><br><span class="line">        <span class="literal">NULL</span>, </span><br><span class="line">        hInstance, <span class="literal">NULL</span> </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="comment">// 处理菜单项被点击，需要处理WM_COMMAND消息</span></span><br><span class="line">        <span class="comment">// wParam的低字节为被点击的菜单项ID，用LOWORD进行获取</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 星光探索者已经改过这些菜单项的名字了</span></span><br><span class="line">        <span class="keyword">case</span> ID_NEW:</span><br><span class="line">            <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;点击新建选项&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;星光探索者&quot;</span>), MB_OK);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ID_OPEN:</span><br><span class="line">            <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;点击打开选项&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;星光探索者&quot;</span>), MB_OK);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，点击菜单的新建选项，将出现这样的效果：</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oYm4.png"></p><h2 id="右键菜单实现"><a href="#右键菜单实现" class="headerlink" title="右键菜单实现"></a>右键菜单实现</h2><p>用过办公软件和浏览器的小伙伴都会体验过，鼠标右键会弹出一个菜单。那么我们应该如何实现呢？</p><p>直接说结论：我们使用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-trackpopupmenu">TrackPopupMenu 函数</a>可以弹出一个快捷菜单，这就是我们期望的。TrackPopupMenu是阻塞函数，直到菜单消失才会返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">TrackPopupMenu</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HMENU      hMenu,        <span class="comment">// 菜单句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT       uFlags,       <span class="comment">// 菜单弹出方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>        x,            <span class="comment">// 菜单的x坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>        y,            <span class="comment">// 菜单的y坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>        nReserved,    <span class="comment">// 预留参数，传NULL即可</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HWND       hWnd,         <span class="comment">// 拥有快捷菜单的窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> RECT *prcRect      <span class="comment">// 此参数被忽略，传NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>然后什么时候弹出呢？我们可以通过处理WM_RBUTTONDOWN（鼠标右键按下）消息来实现，可以是可以。但是事实告诉我们微软提供了<a href="https://learn.microsoft.com/zh-cn/windows/win32/menurc/wm-contextmenu">WM_CONTEXTMENU消息</a>，这样更便捷，这是上下文菜单的消息。正好可以使用右键菜单。</p><p>此消息附带的两个参数如下：</p><ul><li><p><code>wParam</code> 用户右键点击鼠标的窗口句柄</p></li><li><p><code>lParam</code> 低字节表示鼠标光标的x坐标，高字节表示y坐标，这是相对屏幕而言的</p></li></ul><h2 id="添加图标和光标资源"><a href="#添加图标和光标资源" class="headerlink" title="添加图标和光标资源"></a>添加图标和光标资源</h2><p>和前面添加菜单资源一样，但是如果我们有现成的，在弹出这个对话框时，就可以点击导入(Import)使用现有资源。这个步骤相信各位摸索都可以摸索出来。</p><p>然后再调用LoadIcon，LoadCursor即可。</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8odt1.png"></p><p>本期到此结束，下期看星光探索者探索Windows绘图编程和对话框</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：处理常用的消息和自定义消息</title>
      <link href="/blogs/posts/windows/p8cad54b0e5bf.html"/>
      <url>/blogs/posts/windows/p8cad54b0e5bf.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><p>下发假设您自己的窗口类的窗口过程函数均为WndProc，且您正确的按流程写了自定义的窗口程序</p><p>下方均是提供的一种处理方式的代码，并不是必须要这么做。</p><h2 id="处理WM-CLOSE消息"><a href="#处理WM-CLOSE消息" class="headerlink" title="处理WM_CLOSE消息"></a>处理WM_CLOSE消息</h2><p>WM_CLOSE消息在窗口即将终止时产生。</p><p>此消息附带的两个信息</p><ul><li><p><code>wParam</code> 未使用</p></li><li><p><code>lParam</code> 未使用</p></li></ul><p>处理窗口过程函数一个例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="comment">// 应调用此函数，这样会发送WM_QUIT消息</span></span><br><span class="line">        <span class="comment">// 使GetMessage返回0，这样进程才会正确退出</span></span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);  </span><br><span class="line">        <span class="comment">// 不要让默认处理函数处理，否则可能会出错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，WM_DESTROY和WM_QUIT也有退出的意思，这三个消息有什么区别呢？</p><p>WM_DESTROY在窗口销毁时产生，附带的两个信息和WM_CLOSE相同。但在WM_CLOSE可以选择决定是否销毁窗口。WM_QUIT消息在调用PostQuitMessage产生，使得GetMessage返回0。</p><h2 id="处理WM-CREATE消息"><a href="#处理WM-CREATE消息" class="headerlink" title="处理WM_CREATE消息"></a>处理WM_CREATE消息</h2><p>WM_CREATE消息在窗口被创建时产生，在<strong>CreateWindow函数返回之前且窗口未显示之前</strong>产生。如果这个消息返回0，窗口将会被创建，返回-1将销毁创建的窗口。通常处理此消息时，我们初始化一些数据。</p><p>此事件附带的参数</p><ul><li><p><code>wParam</code> 未使用</p></li><li><p><code>lParam</code> 指向 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/ns-winuser-createstructa"><strong>CREATESTRUCT</strong></a>结构的指针，可以获得CreateWindow的全部参数</p></li></ul><p>处理窗口过程函数一个示例如下（运行本示例，您应该能看到先弹出一个消息框，再显示窗口）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="comment">// 大部分小伙伴刚掌握时还不太熟练Windows基本数据类型</span></span><br><span class="line">            <span class="comment">// LPCTSTR = const TCHAR*</span></span><br><span class="line">            <span class="comment">// CREATESTRUE结构可以获得CreateWindow传的所有参数</span></span><br><span class="line">            <span class="comment">// lpszClassName是其中之一</span></span><br><span class="line">            <span class="comment">// reinterpret_cast是C++的类型转换使用的，</span></span><br><span class="line">            LPCTSTR lpClassName = <span class="built_in">reinterpret_cast</span>&lt;CREATESTRUCT*&gt;(lParam)-&gt;lpszClass;</span><br><span class="line">            <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;窗口创建了！&quot;</span>), lpClassName, MB_OK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理WM-SIZE消息"><a href="#处理WM-SIZE消息" class="headerlink" title="处理WM_SIZE消息"></a>处理WM_SIZE消息</h2><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/winmsg/wm-size">WM_SIZE消息</a>将在窗口被调整大小结束后产生。窗口在第一次创建的时候理所当然会调整大小，所以至少会触发一次</p><p>此消息附带的两个信息</p><ul><li><p><code>wParam</code> 调整大小的方式</p></li><li><p><code>lParam</code> 调整后的新范围。低字节为调整后的新宽度，高字节为调整后的新高度</p></li></ul><p>处理此事件的一个示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;iostream&gt; // 使用std::cout包含了这个头文件</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 销毁分配的控制台</span></span><br><span class="line">        <span class="built_in">FreeConsole</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">        <span class="comment">// 给此窗口分配控制台，控制台会由系统处理</span></span><br><span class="line">        <span class="built_in">AllocConsole</span>();</span><br><span class="line">        <span class="comment">// 重定向标准输出流，使得printf可以在控制台输出</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;CONOUT$&quot;</span>,<span class="string">&quot;w+t&quot;</span>, stdout);</span><br><span class="line">    <span class="keyword">case</span> WM_SIZE:</span><br><span class="line">        <span class="comment">// 可用 LOWORD 获取低字节内容 HIWORD 获取高字节内容</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;宽度&quot;</span> &lt;&lt; <span class="built_in">LOWORD</span>(lParam) &lt;&lt; <span class="string">&quot;高度&quot;</span> &lt;&lt; <span class="built_in">HIWORD</span>(lParam) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行此程序，可能的结果如下：</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8or6O.png"></p><h2 id="处理常见鼠标消息"><a href="#处理常见鼠标消息" class="headerlink" title="处理常见鼠标消息"></a>处理常见鼠标消息</h2><p>鼠标移动，按下，松开，会产生鼠标消息。一般情况下，只有在你自己的窗口产生的鼠标消息，才会接收到，要想鼠标在哪个窗口都能处理到鼠标消息，请使用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setcapture">SetCapture 函数 </a>。</p><p>鼠标在窗口移动时，产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-mousemove">WM_MOUSEMOVE消息</a>消息，根据移动的快慢，产生WM_MOUSEMOVE的消息频率是不同的</p><p>鼠标左键按下时，产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-lbuttondown">WM_LBUTTONDOWN消息 </a>，松开时产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-lbuttonup">WM_LBUTTONUP消息</a>。鼠标右键按下时，产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-rbuttondown">WM_RBUTTONDOWN消息</a>，松开时产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-rbuttonup">WM_RBUTTONUP消息 </a></p><p>消息产生均附带的两个信息</p><ul><li><p><code>wParam</code> 产生消息时，其他按键的情况（例如Ctrl,Shift键有没有按下）</p></li><li><p><code>lParam</code> 产生消息时，低字节为鼠标的x坐标，高字节为鼠标的y坐标，是相对窗口而言的</p></li></ul><p>处理消息的一种示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">FreeConsole</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">        <span class="built_in">AllocConsole</span>();</span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;CONOUT$&quot;</span>,<span class="string">&quot;w+t&quot;</span>, stdout);</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;鼠标左键按下 x:%d y: %d\n&quot;</span>, <span class="built_in">LOWORD</span>(lParam), <span class="built_in">HIWORD</span>(lParam));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONUP:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;鼠标左键松开 x:%d y: %d\n&quot;</span>, <span class="built_in">LOWORD</span>(lParam), <span class="built_in">HIWORD</span>(lParam));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_MOUSEMOVE:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;鼠标移动消息 x:%d y: %d\n&quot;</span>, <span class="built_in">LOWORD</span>(lParam), <span class="built_in">HIWORD</span>(lParam));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="鼠标双击消息"><a href="#鼠标双击消息" class="headerlink" title="鼠标双击消息"></a>鼠标双击消息</h2><p>当鼠标左键或右键或中键双击时，并且创建窗口时使用CS_DBCLICK风格，才会产生产生鼠标双击消息。很多小伙伴可能疑惑鼠标中键在哪。实际上鼠标的那个滚轮是可以按下去的，那个就是鼠标中键了。并不是鼠标双击消息产生时，就不会产生鼠标单击消息。</p><p>以鼠标左键双击消息(<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-lbuttondblclk">WM_LBUTTONDBLCLK</a>)，产生消息的顺序是：</p><p>WM_LBUTTONDOWN, WM_LBUTTONUP, WM_LBUTTONDBLCLK, WM_LBUTTONUP</p><p>消息产生均附带的两个信息</p><ul><li><p><code>wParam</code> 产生消息时，其他按键的情况（例如Ctrl,Shift键有没有按下）</p></li><li><p><code>lParam</code> 产生消息时，低字节为鼠标的x坐标，高字节为鼠标的y坐标，是相对窗口而言的</p></li></ul><h2 id="键盘消息"><a href="#键盘消息" class="headerlink" title="键盘消息"></a>键盘消息</h2><p>当键盘的案件被按下或松开时，产生键盘事件。如<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-keydown">WM_KEYDOWN 消息</a>，<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-keyup">WM_KEYUP 消息</a>等。</p><p>消息产生均附带的两个信息</p><ul><li><p><code>wParam</code> 按下按键的VirtualKey（虚拟键代码）</p></li><li><p><code>lParam</code> 按键的参数（如点击了几次）</p></li></ul><p>按下按键只会表明按下的是哪个按键，例如在输入大写字母A和小写字母a时，都是按下了a键，产生WM_KEYDOWN或WM_KEYUP等时没法区分。如果要得到按下按键时的ASCII值，使用<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-char">WM_CHAR 消息 </a>更加方便。</p><h2 id="自定义消息"><a href="#自定义消息" class="headerlink" title="自定义消息"></a>自定义消息</h2><p>有的时候，我们想有自定义消息，那么我们可以使用<a href="https://learn.microsoft.com/zh-CN/windows/win32/winmsg/wm-user">WM_USER</a>宏。自定义消息的格式为WM_USER + x。</p><p>以下是消息编号的范围。</p><table><thead><tr><th>范围</th><th>含义</th></tr></thead><tbody><tr><td>0 到 <strong>WM_USER</strong> –1</td><td>保留供系统使用的消息。</td></tr><tr><td>通过 0x7FFF <strong>进行WM_USER</strong></td><td>用于专用窗口类的整数消息。</td></tr><tr><td>通过0xBFFF <a href="https://learn.microsoft.com/zh-CN/windows/win32/winmsg/wm-app"><strong>WM_APP (0x8000)</strong></a></td><td>可供应用程序使用的消息。</td></tr><tr><td>通过 0xFFFF 进行0xC000</td><td>应用程序使用的字符串消息。</td></tr><tr><td>大于 0xFFFF</td><td>系统保留。</td></tr></tbody></table><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">// 定义自己的消息</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_MESSAGE WM_USER + 2</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;window&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(DKGRAY_BRUSH); <span class="comment">// background color</span></span><br><span class="line">    wc.hIcon = <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, IDI_APPLICATION);              <span class="comment">// window&#x27;s icon</span></span><br><span class="line">    wc.hCursor = <span class="built_in">LoadCursor</span>(<span class="literal">NULL</span>, IDC_ARROW);                <span class="comment">// window&#x27;s cursor</span></span><br><span class="line">    wc.hInstance = hInstance;                                <span class="comment">// window&#x27;s instance</span></span><br><span class="line">    wc.lpfnWndProc = WinProc;                                <span class="comment">// window process callback</span></span><br><span class="line">    wc.lpszClassName = CLASSNAME;                            <span class="comment">// name of the window class</span></span><br><span class="line">    wc.lpszMenuName = <span class="literal">NULL</span>;                                  <span class="comment">// name of the menu</span></span><br><span class="line">    wc.style = CS_HREDRAW | CS_VREDRAW;                      <span class="comment">// window style</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>,                   <span class="comment">// optional window style</span></span><br><span class="line">        CLASSNAME,           <span class="comment">// window class</span></span><br><span class="line">        TITLE,               <span class="comment">// window title</span></span><br><span class="line">        WS_OVERLAPPEDWINDOW, <span class="comment">//window style</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// width and height</span></span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT, </span><br><span class="line">        <span class="comment">// x y</span></span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line"></span><br><span class="line">        <span class="literal">NULL</span>,                <span class="comment">// parent window</span></span><br><span class="line">        <span class="literal">NULL</span>,                <span class="comment">// menu</span></span><br><span class="line">        hInstance,           <span class="comment">// instance handle</span></span><br><span class="line">        <span class="literal">NULL</span>                 <span class="comment">// additional application data</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (hwnd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在鼠标左键时发送消息处理，并获得处理结果</span></span><br><span class="line">        LRESULT nRet = <span class="built_in">SendMessage</span>(hwnd, MY_MESSAGE, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (nRet == <span class="number">114514</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;好臭的处理方式!&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;差评&quot;</span>), MB_ICONWARNING);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理自定义消息</span></span><br><span class="line">    <span class="keyword">case</span> MY_MESSAGE:</span><br><span class="line">        <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;处理我自己的消息！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;MY_MESSAGE&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">114514</span>; <span class="comment">// 返回处理结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行此代码，应该在鼠标左键时弹出一个消息框显示”处理我自己的消息！”，然后显示”好臭的处理方式!”。</p><p>本期到此结束，下期看星光探索者探索使用计时器和菜单，图标，光标等资源文件</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：创建自己的窗口和探索消息机制</title>
      <link href="/blogs/posts/windows/p94939f4d9192.html"/>
      <url>/blogs/posts/windows/p94939f4d9192.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="创建自己的窗口"><a href="#创建自己的窗口" class="headerlink" title="创建自己的窗口"></a>创建自己的窗口</h2><p>前两期的探索内容并没有创建属于自己的窗口，那么我们应该如何创建属于自己的窗口呢？</p><p>一提到窗口，你很可能会想到下面的画面</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oRAA.png"></p><p>没错，这就是一个窗口！实际上，这个应用程序的所有按钮，文本编辑框，菜单都是窗口。有的时候，我们在使用办公软件（如WPS，微软办公套件等），或浏览器时，我们通过点击一下鼠标右键，就弹出了一个菜单，俗称右键菜单。这个右键菜单也可以是窗口，当右键菜单没显示的时候，我们按了一下右键，他就显示了。这样看来，<strong>窗口既可以是显示的，也可以是不显示的</strong>。</p><p>因而，我们可以认为窗口是：</p><ul><li>占据屏幕的某些部分。</li><li>在给定时刻可能看不到或可能不可见。</li><li>了解如何绘制自身。</li><li>响应用户或操作系统的事件。</li></ul><p>说了这么多，让我们一起探索如何创造自己的窗口吧！</p><p>一个完整的窗口程序需要这些步骤：注册窗口类、创建窗口、处理消息。话不多说，看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果报错unresolved symbol无法解析的外部符号错误，就手动链接下面的库</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明窗口处理函数，用于处理窗口消息</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;window&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WNDCLASS 是窗口类结构体</span></span><br><span class="line">    <span class="comment">// 窗口类结构体至少要给 lpfnWndProc，hInstance, lpszClassName</span></span><br><span class="line">    <span class="comment">// 这些属性赋值，否则创建窗口不会成功</span></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(DKGRAY_BRUSH); <span class="comment">// 窗口的背景颜色</span></span><br><span class="line">    wc.hIcon = <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, IDI_APPLICATION);              <span class="comment">// 标题栏图标样式</span></span><br><span class="line">    wc.hCursor = <span class="built_in">LoadCursor</span>(<span class="literal">NULL</span>, IDC_ARROW);                <span class="comment">// 鼠标样式</span></span><br><span class="line">    wc.hInstance = hInstance;                                <span class="comment">// 实例句柄</span></span><br><span class="line">    wc.lpfnWndProc = WinProc;                                <span class="comment">// 窗口过程函数</span></span><br><span class="line">    wc.lpszClassName = CLASSNAME;                            <span class="comment">// 窗口类名称</span></span><br><span class="line">    wc.lpszMenuName = <span class="literal">NULL</span>;                                  <span class="comment">// 窗口菜单名称</span></span><br><span class="line">    wc.style = CS_HREDRAW | CS_VREDRAW;                      <span class="comment">// 窗口风格</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步：注册窗口类</span></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：创建窗口</span></span><br><span class="line">    <span class="comment">// 调这个函数，返回窗口句柄，如果创建窗口失败，返回NULL</span></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>,                   <span class="comment">// 窗口的其他风格</span></span><br><span class="line">        CLASSNAME,           <span class="comment">// 窗口类名</span></span><br><span class="line">        TITLE,               <span class="comment">// 窗口标题栏文字</span></span><br><span class="line">        WS_OVERLAPPEDWINDOW, <span class="comment">// 窗口风格</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// CW_USEDEFAULT 表示使用默认值</span></span><br><span class="line">        <span class="comment">// 窗口初始宽度和高度</span></span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT, </span><br><span class="line">        <span class="comment">// 窗口初始x坐标和y坐标</span></span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line"></span><br><span class="line">        <span class="literal">NULL</span>,                <span class="comment">// 父窗口</span></span><br><span class="line">        <span class="literal">NULL</span>,                <span class="comment">// 菜单</span></span><br><span class="line">        hInstance,           <span class="comment">// 当前实例句柄</span></span><br><span class="line">        <span class="literal">NULL</span>                 <span class="comment">// 附加的内存</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 判断窗口是否创建成功</span></span><br><span class="line">    <span class="keyword">if</span> (hwnd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建窗口失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 展示窗口（第一个参数为要展示的窗口句柄，第二个参数为显示的方式）</span></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="comment">// 更新窗口</span></span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行消息循环</span></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// GetMessage函数用于抓取窗口的消息，这样才能操作窗口</span></span><br><span class="line">    <span class="comment">// 如果抓不到消息，GetMessage返回0，也就是说应用程序该结束了</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 翻译消息（非必要步骤），如果要处理键盘事件，需要翻译消息</span></span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="comment">// 分发消息（必要步骤，否则窗口无法得到消息）</span></span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口处理函数</span></span><br><span class="line"><span class="comment">// @param hwnd 窗口的句柄</span></span><br><span class="line"><span class="comment">// @param uMsg 消息类型</span></span><br><span class="line"><span class="comment">// @param wParam, lParam 窗口消息的两个附加信息，不同的消息，值是不同的</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 处理窗口摧毁消息</span></span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>); <span class="comment">// 发送退出消息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认的窗口消息处理函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译此段代码，可以看到下面的结果：</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oD1K.png"></p><p>成功创建出窗口了！</p><h2 id="过程解析"><a href="#过程解析" class="headerlink" title="过程解析"></a>过程解析</h2><p>首先是WNDCLASS结构体，示例代码已经大部分标的很清楚了。官网上介绍的比星光探索者探索到的还要详细，<a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winuser/ns-winuser-wndclassa">点击查看官网介绍WNDCLASS窗口类结构体</a>！</p><p>在示例代码中，调用了LoadIcon,LoadCursor来加载图标资源，原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HICON <span class="title">LoadIcon</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,  <span class="comment">// 加载资源的实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpIconName    <span class="comment">// 图标名称字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">HCURSOR <span class="title">LoadCursor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance, <span class="comment">// 加载资源的实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpCursorName <span class="comment">// 加载光标名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>Windows的数据类型，如果以<code>H</code>开头，大多都是…的句柄的意思。</p><p>接下来是<a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindoww">RegisterWindow函数</a>，<a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winuser/nf-winuser-createwindoww">CreateWindow函数</a>，这些都是宏定义，都是根据程序使用的字符集来选择调用哪个版本的。例如CreateWindow如果是多字节字符集，将调用CreateWindowA版本，如果是Unicode字符集，将调用CreateWindowW版本，很多皆是如此。</p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-showwindow">ShowWindow 函数</a>和<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-updatewindow">UpdateWindow 函数</a>参数都很简单。</p><p><strong>(重点内容)</strong> 窗口过程函数，是处理窗口消息的函数。Windows是基于消息系统的，当鼠标点击窗口或键盘输入时，将发送相应消息给窗口。因而窗口过程函数即为重要。窗口过程函数写法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WinProc是窗口处理函数的名称，可以随便改</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hwnd,     <span class="comment">// 处理消息的窗口句柄 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT uMsg,     <span class="comment">// 窗口消息</span></span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam, <span class="comment">// 窗口消息附带的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam  <span class="comment">// 窗口消息附带的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>此函数的返回值为窗口消息的处理结果，int类型可以转换成HRESULT类型，大多数情况下返回0表示正常处理。</p><p>如果不处理消息，可交给默认的过程函数DefWinProc处理。但是如果不正确处理相关消息，可能会导致窗口关不了，窗口没了进程还在的情况。</p><h2 id="Windows消息机制"><a href="#Windows消息机制" class="headerlink" title="Windows消息机制"></a>Windows消息机制</h2><p>Windows是以消息为基础的操作系统。消息(MSG类型)组成如下：</p><ul><li><p>窗口句柄</p></li><li><p>消息ID</p></li><li><p>消息的两个附带信息</p></li><li><p>消息产生时间</p></li><li><p>消息产生时的鼠标位置</p></li></ul><p><strong>当系统通知窗口工作时，采用消息的方式派发给窗口</strong>。(本段落以下内容引用自微软官网)如果顶级窗口停止响应消息超过几秒钟，系统将认为窗口不会响应。 在这种情况下，系统会隐藏窗口，并将其替换为具有相同 Z 顺序、位置、大小和视觉属性的幽灵窗口。 这样，用户就可以移动它、调整大小，甚至关闭应用程序。 但是，这些操作是唯一可用的操作，因为应用程序实际上没有响应。 在调试器模式下，系统不会生成虚影窗口。</p><p>消息队列，顾名思义就是储存消息的队列，<strong>队列具有先进先出(First in first out, FIFO)</strong> 的特性。操作系统本身就维护有消息队列，每个应用程序也会有他自己的消息队列。</p><p>但是，并不是所有的消息都会进消息队列，有的消息是直接让窗口处理不进消息队列的。因此，根据消息进不进消息队列，我们可将消息分为<strong>队列消息和非队列消息</strong>。</p><ul><li><p>队列消息：消息发送时，首先进入队列，然后通过消息循环，从队列当中获取。常见的队列消息有WM_PAINT，键盘消息，鼠标消息，定时器消息等</p></li><li><p>非队列消息：消息发送时，直接找到消息接收窗口的窗口过程函数，直接调用此函数完成消息。常见的非队列消息有WM_CREATE，WM_SIZE等</p></li></ul><p>上面说的都是常见的队列消息和非队列消息，只要你想让他进队列，他就是队列消息，否则是非队列消息。</p><h2 id="抓取消息的API"><a href="#抓取消息的API" class="headerlink" title="抓取消息的API"></a>抓取消息的API</h2><p> <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessage">GetMessage函数</a>。 上面的消息循环就是用的这个抓取队列中的消息。如果这个函数的最后两个参数都为0，什么消息都抓取。一般不返回非0值。当遇到WM_QUIT消息（使应用程序退出的消息）时，GetMessage将返回FALSE。GetMessage函数是阻塞函数，如果没有消息会一直等待。</p><p>GetMessage函数在工作时，会按顺序执行下列步骤：</p><ul><li><p>在程序（线程）消息队列中查找消息，如果队列有消息，检查是否满足抓取消息的范围，满足就抓取</p></li><li><p>如果程序（线程）消息队列没有消息，向系统队列获取属于本程序的消息，如果有就转发到程序的消息队列。</p></li><li><p>如果还是没有消息，检查当前进程的所有窗口有没有需要重绘的区域，如果发现有需要绘制的区域，产生WM_PAINT消息，然后处理</p></li><li><p>如果没有重绘区域，检查计时器有没有到时的计时器，如果有将产生WM_TIMER消息，然后处理</p></li><li><p>如果没有计时器，就整理程序资源，内存等</p></li><li><p>如果执行到了这一步，GetMessage就会一直等候，直到消息有为止</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPMSG lpMsg,         <span class="comment">// 抓取到消息储存的消息结构体</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HWND  hWnd,          <span class="comment">// 抓取消息的窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT  wMsgFilterMin, <span class="comment">// 抓取消息的最小值</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT  wMsgFilterMax  <span class="comment">// 抓取消息的最大值</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-peekmessagew">PeekMessage函数</a>用于以查看的方式查看队列有没有消息，如果没有消息返回0，否则返回非0值。这个函数的前四个参数与GetMessage函数意义完全相同，第五个参数的意义为如果有消息，如果值为PM_NOREMOVE，将不从消息队列中移除这个消息，如果值为PM_REMOVE，将从消息队列中移除这个消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PeekMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPMSG lpMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND  hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT  wMsgFilterMin,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT  wMsgFilterMax,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT  wRemoveMsg</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="发送消息的API"><a href="#发送消息的API" class="headerlink" title="发送消息的API"></a>发送消息的API</h2><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-sendmessage">SendMessage 函数 </a>用于向指定窗口句柄的窗口发送消息，这种方式发送的消息是不进消息队列的。此函数会一直等待消息处理结果，其返回值即为目标窗口的处理结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">SendMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND   hWnd,   <span class="comment">// 指定的窗口句柄 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT   Msg,    <span class="comment">// 发送的消息类型   </span></span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam, <span class="comment">// 消息附带的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam  <span class="comment">// 消息附带的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-postmessagew">PostMessage函数</a>用于向指定窗口句柄的窗口发送消息，这种方式发送的消息进消息队列。此函数发送完马上返回，不等待消息处理结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PostMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HWND   hWnd,   <span class="comment">// 指定的窗口句柄 </span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT   Msg,    <span class="comment">// 发送的消息类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">  WPARAM wParam, <span class="comment">// 消息附带的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPARAM lParam  <span class="comment">// 消息附带的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>本期到此结束，下期看星光探索者处理常用的消息及自定义消息</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：常用基本数据类型和字符编码</title>
      <link href="/blogs/posts/windows/pd3e66887a323.html"/>
      <url>/blogs/posts/windows/pd3e66887a323.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="常用基本数据类型"><a href="#常用基本数据类型" class="headerlink" title="常用基本数据类型"></a>常用基本数据类型</h2><p>windows定义了很多基本数据类型，常用的有下列等效定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONST const</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VOID void</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> CHAR;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> SHORT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> LONG;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">wchar_t</span> WCHAR;</span><br><span class="line"><span class="keyword">typedef</span> SHORT *PSHORT;  </span><br><span class="line"><span class="keyword">typedef</span> LONG *PLONG;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 字节的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>       DWORD;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>                 BOOL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>       BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>      WORD;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span>               FLOAT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子类型</span></span><br><span class="line"><span class="keyword">typedef</span> WORD                ATOM;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE <span class="comment">// 如果定义了UNICODE宏</span></span></span><br><span class="line"><span class="keyword">typedef</span> WCHAR TCHAR, *PTCHAR;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> CHAR TCHAR, *PTCHAR;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CHAR类型字符串</span></span><br><span class="line"><span class="keyword">typedef</span> CHAR *LPSTR, *PSTR;</span><br><span class="line"><span class="comment">// CONST CHAR类型字符串</span></span><br><span class="line"><span class="keyword">typedef</span> CONST CHAR *LPCSTR, *PCSTR;</span><br><span class="line"><span class="comment">// WCHAR类型字符串</span></span><br><span class="line"><span class="keyword">typedef</span> WCHAR *LPWSTR, *PWSTR;</span><br><span class="line"><span class="comment">// COSNT WCHAR类型字符串</span></span><br><span class="line"><span class="keyword">typedef</span> CONST WCHAR *LPCWSTR, *PCWSTR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TCHAR类型的字符串</span></span><br><span class="line"><span class="keyword">typedef</span> TCHAR *PTSTR, *LPTSTR;</span><br><span class="line"><span class="comment">// CONST TCHAR类型字符串</span></span><br><span class="line"><span class="keyword">typedef</span> CONST TCHAR *PCTSTR, *LPCTSTR;</span><br></pre></td></tr></table></figure><p>这些是主要的类型，各位小伙伴初次看到时都会感到比较难以下手，我们只需要大概了解就可以了，毕竟有文档在，况且我们可以随时查看这些函数的定义。</p><p>这些基本数据类型的定义是有规律的，例如带有<code>P</code>的表明这个类型是指针类型，例如LPSTR(char*), PVOID(void*)，带有<code>STR</code>的表明这是一个字符串，例如PSTR(char*), PTSTR(TCHAR*)，带有<code>C</code>表示具有const属性例如PCWSTR(const wchar_t *)，非常好记。</p><p>还有BOOL定义为int，并不是bool，返回BOOL类型时应该返回TRUE(1)或FALSE(0)</p><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>字符(character)是各位文字和符号的总称，字符集（Character set）是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同，常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、 GB18030字符集、Unicode字符集等。计算机要准确的处理各类字符集，需要进行字符编码。实际上字符都是通过数值表示的。</p><p>下面来探索部分字符集：</p><h3 id="ASCII-字符集"><a href="#ASCII-字符集" class="headerlink" title="ASCII 字符集"></a>ASCII 字符集</h3><p>ASCII (American Standard Code for Information Interchange，美国信息互换标准编码）是基于罗马字母表的一套电脑编码系统，主要用于显示英语和其他西欧语言。ASCII字符集用7位表示一个字符，共128个字符，字符值从0到127，其中32到126是可打印字符。7位编码的字符集只能表示128个字符，为了表示更多的字符，ASCII扩展字符集使用8位（bits）表示一个字符，共256字符。</p><h3 id="GB2313字符集"><a href="#GB2313字符集" class="headerlink" title="GB2313字符集"></a>GB2313字符集</h3><p>GB2312又称为GB2312-80字符集，全称为《信息交换用汉字编码字符集·基本集》，由原中国国家标准总局发布，1981年5月1日实施。是中国国家标准的简体中文字符集，他收录的汉字已经覆盖99.75%的使用评率，基本满足了汉字的计算机处理需要。</p><h3 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h3><p>Unicode字符集是Universal Multiple-Octet Coded Character Set 通用多八位编码字符集的简称，支持现今世界各种不同语言的书面文本的交换、处理及显示。</p><p>因此Win32程序使用不同的字符集，将调用不同的API函数。</p><p>下列代码展示如何处理各种字符集的打印方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印多字节字符集使用这个\n&quot;</span>);</span><br><span class="line">    <span class="built_in">wprintf</span>(<span class="string">L&quot;%ls\n&quot;</span>, <span class="string">L&quot;打印Unicode字符集使用这个&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行这段代码，看到printf正常打印，wprintf打印不出正确内容的运行结果(各位可以尝试一下，wprintf打印宽字符集，也就是Unicode字符，目前大多都是不成功的)</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oBp6.png"></p><p>为什么会这样呢？因为wprintf目前对Unicode的支持还不是很好，为了能正常打印，在Windows我们可以使用<a href="https://learn.microsoft.com/zh-cn/windows/console/writeconsole">WriteConsole函数</a>，看下列代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">wchar_t</span> content[] = <span class="string">L&quot;打印Unicode字符集的解决方案&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得标准输出句柄 STD_OUTPUT_HANDLE</span></span><br><span class="line">    <span class="comment">// 还可以获得标准输入句柄，标准错误句柄等</span></span><br><span class="line">    <span class="comment">// HANDLE是句柄类型</span></span><br><span class="line">    HANDLE hOut = <span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制台输出信息</span></span><br><span class="line">    <span class="built_in">WriteConsole</span>(hOut, content, <span class="built_in">wcslen</span>(content), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于TCHAR类型的字符串，计算长度因使用lstrlen</span></span><br><span class="line">    TCHAR szText = <span class="built_in">TEXT</span>(<span class="string">&quot;好！&quot;</span>);</span><br><span class="line">    <span class="built_in">WriteConsole</span>(hOut, szText, <span class="built_in">lstrlen</span>(szText), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一编译，可以看到程序正确打印，非常好。</p><p><a href="https://learn.microsoft.com/zh-cn/windows/console/writeconsole">点我查看WriteConsole函数有关信息</a></p><p>本期到此结束，下期看星光探索者探索Windows如何创建自己的窗口和探索消息机制</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：第一个Win32程序</title>
      <link href="/blogs/posts/windows/p83a7b5481c29.html"/>
      <url>/blogs/posts/windows/p83a7b5481c29.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="探索Windows程序类型"><a href="#探索Windows程序类型" class="headerlink" title="探索Windows程序类型"></a>探索Windows程序类型</h2><p>我们可以给Windows程序分类</p><ul><li><p>控制台程序Console</p><p>DOS程序，本身没有窗口，通过Windows DOS窗口执行。</p><p>在Windows通常为.exe文件，控制台程序的入口为main函数</p></li><li><p>窗口程序</p><p>拥有自己的窗口，可以和用户交互</p><p>通常为.exe文件，情况下窗口程序的入口为WinMain函数</p></li><li><p>库程序</p><p>存放代码，数据的程序，执行文件可以从中取出代码执行和获取数据</p><ul><li><p>静态库程序：拓展名.lib。在链接阶段将代码放入可执行文件中，无入口函数</p></li><li><p>动态库程序：拓展名.dll。在执行文件中执行时从中获得代码，入口函数为DllMain</p></li></ul></li></ul><h2 id="编译工具"><a href="#编译工具" class="headerlink" title="编译工具"></a>编译工具</h2><p>通常编写Win32程序应该使用微软的工具，毕竟Windows是微软的。</p><p>下面让我们一起探索Visual C++的编译工具吧！</p><p>编译器cl.exe：将源代码(.c或.cpp)编译成目标代码.obj</p><p>链接器link.exe：将目标代码，资源，库等链接，生成最终文件</p><p>资源编译器rc.exe：将资源文件(.rc)将资源编译成.res文件，最终通过链接器写入最终文件</p><p>如果你安装了Visual Studio，那么这些编译工具的路径可能为：</p><p>C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.34.31931\bin\Hostx64\x64\</p><h2 id="Windows库和头文件"><a href="#Windows库和头文件" class="headerlink" title="Windows库和头文件"></a>Windows库和头文件</h2><p>下面只是列举部分库和对应的头文件，并不是全部内容</p><ul><li><p>kernel32.dll 提供了核心的API，如进程，线程，内存管理</p></li><li><p>user32.dll 提供了窗口，消息等用户常用的API</p></li><li><p>gdi32.dll 绘图相关的API</p></li></ul><p>路径： C:\Windows\System32\</p><p>Windows的头文件</p><ul><li><p>windows.h 大部分Windows头文件的集合，包含了下列提到的头文件等文件</p></li><li><p>windef.h windows基本数据类型定义</p></li><li><p>winbase.h kernel32.dll 的API</p></li><li><p>wingdi.h gdi32.dll的API</p></li><li><p>winuser.h user32.dll的API</p></li><li><p>winnt.h UNICODE字符集的支持</p></li></ul><p>路径：C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.34.31931\include</p><h2 id="第一个Win32程序"><a href="#第一个Win32程序" class="headerlink" title="第一个Win32程序"></a>第一个Win32程序</h2><p>首先先新建一个文件夹，并创建test.cpp源代码文件，在test.cpp文件书写这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">INT WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,      <span class="comment">// 当前实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,  <span class="comment">// 上一个实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,          <span class="comment">// 运行程序的命令行</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow              <span class="comment">// 程序最初显示方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;探索Windows!&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;星光探索者&quot;</span>), MB_OK);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>星光探索者非常喜欢探索，于是星光探索者在命令行调用Visual C++编译工具，输入了像这样的命令行<code>cl test.cpp</code>就可以编译这个Win32程序了。如果有的小伙伴提示错误信息unresolved symbol无法解析的外部符号，那么就需要手动链接相关的库了。MessageBox函数属于user32.dll，因此我们需要使用link指令：<code>cl test.cpp /link user32.lib</code></p><p>当然用MinGW也是可以的，只不过需要加上<code>-mwindows</code>参数，要不然MinGW不会认为是编译Win32程序，而是认为是控制台程序</p><p>运行这个程序，可以看到显示了一个消息框。</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8osXD.png"></p><h2 id="深入探索"><a href="#深入探索" class="headerlink" title="深入探索"></a>深入探索</h2><p>WinMain函数的结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,      <span class="comment">// 当前实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,  <span class="comment">// 上一个实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,          <span class="comment">// 运行程序的命令行</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow              <span class="comment">// 程序最初显示方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>hInstance</code> 为当前实例句柄。在Windows句柄的概念的随处可见</p></li><li><p><code>hPrevInstance</code> 为上一个实例句柄。他在16位Windows系统使用，现在不使用，值总是为NULL(定义为0)</p></li><li><p><code>pCmdLine</code> 包含命令行参数的字符串。如果需要获取整个命令行，请使用<code>GetCommandLine</code></p></li><li><p><code>nCmdShow</code> 窗口的最初显示方式（最小化，正常，最大化）</p></li></ul><p>这个函数返回INT(定义为int)类型的值，操作系统不使用返回值，但可以传递给其他程序</p><p>WINAPI是Windows的函数调用约定，定义为__stdcall，使用<code>APIENTRY</code>也是相同的结果</p><p>上面那个简易的程序还调用了MessageBox函数，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageBox</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HWND hWnd,          <span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpText,     <span class="comment">//弹窗内容</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpCaption,  <span class="comment">//弹窗标题</span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT uType          <span class="comment">//弹窗类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>hWnd</code> 为显示消息框的窗口句柄，也就是消息框的父窗口，如果没有父窗口就传NULL，关于窗口的更多信息下期星光探索者继续探索。 HWND类型为handle of the windows的意思。</p></li><li><p><code>lpText</code> 是一个TCHAR类型的字符串，为消息框的内容</p><p>TCHAR是windows基本数据类型，是宏定义。如果使用多字节字符集的项目，TCHAR被定义为char；如果使用Unicode字符集的项目，TCHAR被定义为wchar_t。类型<code>LPCTSTR</code>为<code>const TCHAR*</code>，在下一期会深入探索。</p></li><li><p><code>lpCaption</code>是一个TCHAR类型的字符串，为消息框的标题内容</p></li><li><p><code>uType</code>为消息框的显示按钮及消息框标题栏的图标，默认显示一个确定(OK)按钮。这个函数的返回值即为用户按下的按钮。</p><p>可选择的部分样式如下，消息框显示的按钮文本取决于系统的语言，想知道更多信息<a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winuser/nf-winuser-messagebox">请点击我！</a>：</p><p>消息框的按钮：</p><table><thead><tr><th>按钮样式</th><th>效果</th></tr></thead><tbody><tr><td>MB_OK</td><td>消息框包含一个按钮确定，这是默认值</td></tr><tr><td>MB_OKCANCEL</td><td>消息框包含两个按钮，确定取消</td></tr><tr><td>MB_YESNO</td><td>消息框包含两个按钮，是和否</td></tr><tr><td>MB_RETRYCANCEL</td><td>消息框包含两个按钮，重试或取消</td></tr></tbody></table><p> 消息框的图标：</p><table><thead><tr><th>图标样式</th><th>效果</th></tr></thead><tbody><tr><td>MB_ICONWARNING</td><td>消息框中会显示一个感叹号图标</td></tr><tr><td>MB_ICONINFORMATION</td><td>消息框会有一个圆圈，圆圈中间写着小写字母 i(意思为infomation，信息的意思)</td></tr><tr><td>MB_ICONQUESTION</td><td>消息框会显示一个问号图标</td></tr></tbody></table><p>默认选中的按钮</p><table><thead><tr><th>默认选中的按钮</th><th>效果</th></tr></thead><tbody><tr><td>MB_DEFBUTTON1</td><td>选中第一个按钮（默认值）</td></tr><tr><td>MB_DEFBUTTON2</td><td>选中第二个按钮</td></tr><tr><td>MB_DEFBUTTON3</td><td>选中第三个按钮</td></tr><tr><td>MB_DEFBUTTON4</td><td>选中第四个按钮</td></tr></tbody></table><p>等很多功能，但都是以MB_开头，可根据字面意思猜测功能。</p></li></ul><p>MessageBox的返回值为点击的按钮,都是以ID开头。例如IDOK(确认按钮)，IDCANCEL(取消按钮)</p><p>使用案例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (MBCANCEL != <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;是否重试?&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;Error&quot;</span>), MB_YSENO))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 如果消息框想用多个效果，使用 | 运算符</span></span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, </span><br><span class="line">                   <span class="built_in">TEXT</span>(<span class="string">&quot;正在重试&quot;</span>), </span><br><span class="line">                   <span class="built_in">TEXT</span>(<span class="string">&quot;fixing&quot;</span>), </span><br><span class="line">                   MB_OK | MB_ICONINFOMATION | MB_DEFBUTTON1</span><br><span class="line">    );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个TEXT是windows提供的一个宏函数，会根据当前使用的字符集将”…”这样的字符串转换成TCHAR类型的字符串。因为Windows的API要根据不同的字符集调不同的函数，对于要调API的字符串我们可以用TEXT宏来包裹</p><p>定义的效果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE  <span class="comment">// 如果使用UNICODE字符集</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXT(quote) L##quote</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXT(quote) quote</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>刚才上文提到了项目使用的字符集，那个在哪里设置呢？</p><p>打开解决方案管理器(Solution Explorer)</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8o6ne.png"></p><p>对准你要设置字符集的项目按<strong>鼠标右键</strong>，看到菜单，然后点击 <strong>属性(Properties)</strong></p><p><img src="https://s1.ax1x.com/2023/01/20/pS8owfx.png"></p><p>然后选择字符集(Character Set)，在这里就可以设置你项目使用的字符集了。</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oakR.png"></p><p>本期到此结束，下期看星光探索者探索Windows常用基本数据类型和字符编码</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
