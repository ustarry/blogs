<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++面向对象知识点总结</title>
      <link href="/blogs/posts/cplusplus/p46f9f8da9911.html"/>
      <url>/blogs/posts/cplusplus/p46f9f8da9911.html</url>
      
        <content type="html"><![CDATA[<p>本文记录了C++面向对象的相关知识点。</p><h2 id="面向对象初识"><a href="#面向对象初识" class="headerlink" title="面向对象初识"></a>面向对象初识</h2><h3 id="何为面向对象"><a href="#何为面向对象" class="headerlink" title="何为面向对象"></a>何为面向对象</h3><p>面向过程(Procedure Oriented)：在解决一个问题时，<strong>将过程拆分为解决事情的步骤，然后按一定的顺序执行这些步骤</strong>，然后解决问题。优点是性能相对面向对象高，因为对象需要构建，开销比较大。缺点是不易维护。</p><p>面向对象(Object Oriented)：在解决一个问题时，<strong>面向对象会将事物抽象成对象的概念，看此问题有哪些对象，这些对象会有什么行为，什么属性，让每个对象执行自己的行为</strong>，然后解决问题。优点是易维护易复用易拓展，缺点是性能比面向过程低，但也不会非常低。<strong>对象的行为和属性称为对象的成员</strong>。</p><p>什么是对象，例如人，手机，是对象<br>什么是行为，例如走路，跑步，转身<br>什么是属性，例如人的年龄，手机的电量，人的身高</p><p><strong>具有相同行为，属性的对象组成的集合叫做类</strong>。</p><blockquote><p>参考案例：用圆规画圆<br>面向过程：拿出圆规，修改圆规半径，旋转圆规，结束<br>面向过程：圆规创建，圆规.调整自身大小行为，圆规.旋转行为，结束。</p></blockquote><blockquote><p>参考案例：象棋对弈人工智能<br>面向过程：执行走法（我 or 人机)<br>面向过程：我.下棋 , 人机.下棋 </p></blockquote><p>在C++，面向对象世界有三大特征：<strong>封装，继承，多态</strong>。</p><h3 id="C-面向对象的基本使用"><a href="#C-面向对象的基本使用" class="headerlink" title="C++面向对象的基本使用"></a>C++面向对象的基本使用</h3><p>要创建一个对象，我们需要先实现一个类，在C++类我们可以使用<code>class</code>关键字声明。注意是<strong>可以</strong>，也就是说，可以使用别的关键字声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 声明对象行为和属性的代码 */</span></span><br><span class="line">&#125;;  <span class="comment">// 注意需要分号结尾</span></span><br></pre></td></tr></table></figure><p>如下列示例代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明对象的行为如 展示自己的名字</span></span><br><span class="line">    <span class="comment">// 对象的行为写法就如函数的写法一样</span></span><br><span class="line">    <span class="comment">// 因此这被称作 成员函数 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show_name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我叫&quot;</span> &lt;&lt; m_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明对象拥有的属性如 名字name, 年龄age</span></span><br><span class="line">    <span class="comment">// 对象的属性被称为 成员变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p; <span class="comment">// 创建对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给对象相应属性赋值， 用 对象.属性 的方式改值</span></span><br><span class="line">    p.m_name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    p.m_age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让对象执行对象的行为，用 对象.行为()  </span></span><br><span class="line">    p.<span class="built_in">show_name</span>();</span><br><span class="line">    <span class="comment">// 访问对象的年龄</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;我的年龄&quot;</span> &lt;&lt; p.m_age &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果:<br>我叫张三<br>我的年龄18</p></blockquote><p><strong>创建一个对象的过程叫做实例化，一个对象为该类的一个实例</strong>。</p><h2 id="面向对象：封装"><a href="#面向对象：封装" class="headerlink" title="面向对象：封装"></a>面向对象：封装</h2><p>我们可以使用访问权限控制符来限制对象行为和属性是否能被外界访问。我么可以使用 <code>public</code>, <code>protected</code>, <code>private</code> 三个关键字来限制访问权限。如不使用这些关键字，在用class声明的类里默认使用private</p><p><code>public</code> 表示外界可以访问<br><code>protected</code> 和 <code>private</code>都表示外界不可以访问，但是<code>protected</code> 属性在被继承后，仍可以被子类访问，但<code>private</code> 修饰的，就不行。</p><p>但无论用哪种修饰符，类内都可以正常访问这些行为。可以多次使用这些修饰符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我已经&quot;</span> &lt;&lt; m_age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用private限制外界访问</span></span><br><span class="line">    <span class="type">double</span> m_eyesight;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//p.m_name = &quot;张三&quot;; // 错误，外界不可以访问private修饰的属性</span></span><br><span class="line">    p.m_eyesight = <span class="number">5.0</span>; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">show_name</span>(); </span><br><span class="line">    <span class="comment">// 正确，但是运行结果不确定，</span></span><br><span class="line">    <span class="comment">// 各位小伙伴可以编译此程序，看运行结果</span></span><br><span class="line">    <span class="comment">// 下方会继续探讨为什么</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们尽量给对象的属性设置非public的权限防止用户直接修改我们类的属性，避免异常。然后，提供public属性的其他成员函数来替代操作对象的属性。这即为封装的意义</p><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><p>生活中，不用的东西我们都会尽量消除与自己个人信息相关的地方，也就是保护隐私。例如扔硬盘时，我们会尽量粉碎硬盘，删除相关的个人信息。公司的一些文件，销毁时使用碎纸机，尽量销毁相关信息。</p><p>因而构造函数和析构函数是帮助我们处理构造对象和销毁对象的相关工作。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>语法如下（注：成员函数也是可以重载的）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">    类名(<span class="comment">/*参数列表*/</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 构造对象的相关工作 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~类名()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 销毁对象的相关工作 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>构造函数和析构函数没有返回值，但是不写void，函数名与类名同名，但不能使用const, virtual修饰函数。<br>析构函数不能有参数，因而析构函数不可以重载，但是构造函数可以重载，但不能使用const修饰函数。</p><p>构造函数和析构函数将分别在构造对象和销毁对象的时候自动执行，编译器保证肯定会执行。当对象生命周期结束时，对象会被析构。但是构造函数和析构函数应使用public的访问权限，要不然编译器无法构造和析构对象。在单例模式中我们将了解到限制实例化对象的方式。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Object</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;对象被析构\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;对象被构建\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Object o1;</span><br><span class="line">    Object o2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>对象被构建<br>对象被构建<br>对象被析构<br>对象被析构</p></blockquote><h4 id="构造函数的分类"><a href="#构造函数的分类" class="headerlink" title="构造函数的分类"></a>构造函数的分类</h4><p>根据构造函数是否有参数，可分为：无参构造函数，有参构造函数<br>根据构造函数的意义，可分为：默认构造函数（没有参数的构造函数，也可称作缺省构造函数），复制构造函数（对象拷贝的构造函数，也可称作拷贝构造函数），移动构造函数（对象资源移动所有权时的构造函数，这是C++11语法）</p><p>下面是一些示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Object</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;对象被析构\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现默认构造函数</span></span><br><span class="line">    <span class="built_in">Object</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_val = <span class="number">0</span>;  <span class="comment">// 在构造函数中，给成员属性赋值</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;默认构造函数\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现有参构造函数</span></span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">int</span> val)</span><br><span class="line">    &#123;</span><br><span class="line">        m_val = val;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;有参构造函数\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现拷贝构造函数</span></span><br><span class="line">    <span class="comment">// 拷贝构造函数的参数类型是 const 类型名&amp;</span></span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">const</span> Object&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        m_val = obj.m_val;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;拷贝构造函数\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show_val</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;val: &quot;</span> &lt;&lt; m_val &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Object o1;</span><br><span class="line">    <span class="function">Object <span class="title">o2</span><span class="params">(<span class="number">3</span>)</span></span>;  <span class="comment">// 调用有参构造函数</span></span><br><span class="line">    <span class="function">Object <span class="title">o3</span><span class="params">(o1)</span></span>; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Object 对象(参数) 来调用构造函数</span></span><br><span class="line">    <span class="comment">// Object 对象;  调用的是默认构造函数，</span></span><br><span class="line">    <span class="comment">// 不使用Object xxx()  来调用默认函数初始化对象</span></span><br><span class="line">    <span class="comment">// 因为这会被当做函数的声明：返回值类型 Object， 函数名 xxx ，参数列表 (void)</span></span><br><span class="line"></span><br><span class="line">    o1.<span class="built_in">show_val</span>();</span><br><span class="line">    o2.<span class="built_in">show_val</span>();</span><br><span class="line">    o3.<span class="built_in">show_val</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>默认构造函数<br>有参构造函数<br>拷贝构造函数<br>val: 0<br>val: 3<br>val: 0<br>对象被析构<br>对象被析构<br>对象被析构</p></blockquote><h4 id="默认提供的构造函数"><a href="#默认提供的构造函数" class="headerlink" title="默认提供的构造函数"></a>默认提供的构造函数</h4><p>如果你不实现构造函数，编译器会实现默认的。如果你实现了默认构造函数，那么编译器还会提供默认实现的拷贝构造函数。如果你实现了一个带参数的构造函数，但不是拷贝构造函数，编译器不提供默认构造函数，但仍会提供默认的拷贝构造函数。如果你实现了一个拷贝构造函数，那么编译器不再提供默认实现的构造函数。</p><p>默认提供的拷贝构造函数，会将自身的每个属性从一遍逐个字节拷贝到另一个对象。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_val;</span><br><span class="line">    <span class="type">int</span>* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">int</span> val, <span class="type">int</span>* ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        m_val = val;</span><br><span class="line">        m_ptr = ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;val: &quot;</span> &lt;&lt; m_val &lt;&lt; <span class="string">&quot;ptr: &quot;</span> &lt;&lt; m_ptr &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="function">Object <span class="title">o1</span><span class="params">(<span class="number">5</span>, p)</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">o2</span><span class="params">(<span class="number">5</span>, p)</span></span>;</span><br><span class="line">    o1.<span class="built_in">show</span>();</span><br><span class="line">    o2.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行此段代码，可以看到打印o1,o2的值完全一致。</p><p>但是如果我们改成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 想法：Object对象将管控堆区的数据，对象析构时将销毁相应数据</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Object</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 释放堆区的数据</span></span><br><span class="line">        <span class="keyword">if</span> (m_ptr != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_ptr;</span><br><span class="line">            m_ptr = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">int</span>* ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ptr = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">o1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">o2</span><span class="params">(o1)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，会发现出错，原因是重复释放堆区的内存。o2被析构时，o2的m_ptr指向的堆区内存被释放。o1析构时，由于o1和o2的m_ptr都指向同一块堆区内存，因为这是默认提供的构造函数造成的，o1又释放了一遍，因此代码出错了。</p><p>编译器默认提供的拷贝构造函数叫做浅拷贝，<strong>浅拷贝会会将自身的每个属性从一遍逐个字节拷贝到另一个对象</strong>。为了避免浅拷贝的危害，对于储存堆区数据的类，我们需要实现深拷贝。<strong>深拷贝即为，再开辟一块新的内存空间，拷贝原先数据到新的数据那里，而不是直接拷贝。</strong></p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Object</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 释放堆区的数据</span></span><br><span class="line">        <span class="keyword">if</span> (m_ptr != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_ptr;</span><br><span class="line">            m_ptr = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">int</span>* ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ptr = ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝的示例</span></span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">const</span> Object&amp; left)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 分配一个新的内存空间，然后再拷贝</span></span><br><span class="line">        m_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(*left.m_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">o1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">o2</span><span class="params">(o1)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>我们使用初始化列表，可以更高效地初始化类的相关属性</p><p>语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">    类名() : 属性值<span class="number">1</span>(构造需要的参数列表<span class="number">1</span>), 属性值<span class="number">2</span>(构造需要的参数列表<span class="number">2</span>) ... </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">O</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val1;</span><br><span class="line">    <span class="type">int</span> val2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">O</span>(<span class="type">int</span> val) : <span class="built_in">val1</span>(val), <span class="built_in">val2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用初始化列表初始化对象，写起来比较直观。</p><h4 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h4><p>使用 <code>对象名(参数)</code> 可以构造一个匿名对象，匿名对象由于没有名字，构造之后会被马上销毁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">O</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">O</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;析构函数调用\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">O</span>(<span class="type">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;构造函数调用\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">O</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><p>构造函数调用<br>析构函数调用</p></blockquote><p>匿名对象在之后的swap函数实现非常有用。</p><p>总之，对象的构建顺序是，先分配内存给对象，然后对象调用构造函数，对象的析构顺序是，先调用析构函数，再回收对象占用的内存空间。</p><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>一个类的所有实例都能共享的成员变量或成员函数，称为静态成员。</p><p>静态成员变量特征：所有实例共享，编译阶段分配内存，类内声明类外初始化。</p><p>静态成员函数特征：静态成员函数只能访问静态成员变量，原因是静态成员函数没有this指针（下方内容提到了this指针的概念）</p><p>访问静态成员的方式：</p><ol><li>类名::静态成员</li><li>先创建一个对象，然后 对象.静态成员 来访问</li></ol><p>静态成员在某种意义上可以看成是只属于这个类的全局函数或全局变量，但是可以通过访问权限来限制外界访问这个静态成员。因此只有静态成员声明为public时，外界可以访问。</p><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;do_something\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须要对静态成员变量初始化，</span></span><br><span class="line"><span class="comment">// 因为编译器要编译阶段给他分配内存</span></span><br><span class="line"><span class="comment">// 如果不初始化，编译器没有办法给他分配默认值</span></span><br><span class="line"><span class="comment">// 这个步骤因此是必须要做的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方式   类型名 类名::静态成员变量名 = 值;</span></span><br><span class="line"><span class="type">int</span> MyClass::value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问静态成员变量的一种方式</span></span><br><span class="line">    MyClass::value;  </span><br><span class="line">    <span class="comment">// 第二种方式，一般用第一种</span></span><br><span class="line">    c.value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-对象模型初步探索和this指针"><a href="#C-对象模型初步探索和this指针" class="headerlink" title="C++对象模型初步探索和this指针"></a>C++对象模型初步探索和this指针</h3><p>C++在设计类时，经过了努力有了现在的对象模型。最终，C++标准规定，一个类如果什么成员变量都没有，即空类占1字节。只有成员变量储存在对象身上，其他的成员函数不储存在对象身上。</p><p>那么现在出现了一个问题，所有对象都调用同一个成员函数。成员函数是如何区分是哪个对象调用的成员函数呢？C++通过使用特殊的指针，this指针来解决这个问题。在调用成员函数时，编译器会隐含传入this指针，哪个对象调用的成员函数，this指针就指向谁。this指针不需要自己声明，因为编译器在默默帮助你。</p><p>this指针的用途：</p><ol><li>使用this指针解决冲突。当函数形参或局部变量与类成员变量重名时，会产生名字冲突。</li><li>返回指向自身的地址或引用。再之后的高深技术中，我们可以运用this指针防止自己给自己赋值，实现累加操作等。</li></ol><p>this指针的实质是指针常量，指针的指向是不可修改的。相当于<code>类名 const * this;</code></p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">int</span> val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//val = val; </span></span><br><span class="line">        <span class="comment">// 上面的val会被认为是函数形参val，而不是成员变量val</span></span><br><span class="line">        <span class="comment">// 自己给自己赋值是没什么意义的</span></span><br><span class="line">        <span class="comment">// 要想解决这个问题，使用this指针，如下：</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">        <span class="comment">// 这样即可成功赋值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">talk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 默认情况下，这都会被看成是 this-&gt;val，因为这个类有名为val的成员</span></span><br><span class="line">        <span class="comment">// 因此，不需要频繁的使用this指针</span></span><br><span class="line">        <span class="comment">// 一般推荐在属性名前使用 m_ 前缀来表明此变量为成员变量</span></span><br><span class="line">        val; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object&amp; <span class="title">add_val</span><span class="params">(<span class="type">const</span> Object&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val += obj.val; </span><br><span class="line">        <span class="comment">// 返回自身引用</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">o1</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">o2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过不断返回自身引用，就可以一直调用add_val</span></span><br><span class="line">    <span class="comment">// 这种编程思想称为链式编程</span></span><br><span class="line">    o1.<span class="built_in">add_val</span>(o2).<span class="built_in">add_val</span>(o1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空指针或野指针调用成员函数"><a href="#空指针或野指针调用成员函数" class="headerlink" title="空指针或野指针调用成员函数"></a>空指针或野指针调用成员函数</h3><p>空指针或野指针也是可以调用成员函数的。因为编译器没法知道什么时候是空指针或野指针调用成员函数。这种方式调用时，可能会出错，也可能不会。出错的时候，可能是因为使用了this指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show_class</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show_val</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Object *p = <span class="literal">NULL</span>;</span><br><span class="line">    p.<span class="built_in">show_class</span>(); <span class="comment">// 成功调用</span></span><br><span class="line">    p.<span class="built_in">show_val</span>();   <span class="comment">// 调用出错，原因是this为空指针，尝试访问空指针是非法的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们为了使show_val成员函数仍正常输出，使用如下措施保证其不报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改show_val函数保证正常输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_val</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 仅能预防空指针调用时的报错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员常量和常函数"><a href="#成员常量和常函数" class="headerlink" title="成员常量和常函数"></a>成员常量和常函数</h3><p>成员常量是不可修改的，如果想要初始化成员常量，<strong>需要用初始化列表初始化</strong>。</p><p>成员函数用const修饰之后被称作常函数，常函数不可以修改成员属性，但是如果给成员属性用mutable关键字，常函数中仍可以修改</p><p>声明对象时用const，此对象被称为常对象，常对象只能调常函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> prize;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> id; <span class="comment">// 成员常量</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">const</span> <span class="type">int</span> age; <span class="comment">// 声明可以被常函数改值的成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">id</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">not_const_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常函数的const写在这个位置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">const_func</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//prize = 6; // 错误，不可以改这个值</span></span><br><span class="line">        <span class="comment">//id = 5; // 也不可以改</span></span><br><span class="line">        age = <span class="number">-6</span>; <span class="comment">// 可以改，因为用mutable修饰</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass c1;</span><br><span class="line">    <span class="type">const</span> MyClass c2;  <span class="comment">// 常对象</span></span><br><span class="line"></span><br><span class="line">    c2.<span class="built_in">const_func</span>(); <span class="comment">// 成功调用</span></span><br><span class="line">    <span class="comment">//c2.not_const_func(); // 调用失败，尽管not_const_func成员函数没有使用任何成员变量和成员常量，由于他不用const修饰，也是不可以调用成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>有时我们希望全局函数，其他类，或其他类的成员函数也可以访问我们的非public权限的成员，我们应该怎么做呢？答案是使用友元。友元，使用friend关键字，friend即朋友的意思。</p><p>友元的三种方式：</p><ul><li>全局函数做友元</li><li>成员函数做友元</li><li>类做友元</li></ul><p>友元案例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MidClass</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_val;</span><br><span class="line">    <span class="comment">// 1. 全局函数做友元</span></span><br><span class="line">    <span class="comment">// 声明全局函数的友元，声明全局函数 friend_func可以访问MyClass的私有成员</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">friend_func</span><span class="params">(MyClass*)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成为友元的全局函数可以在类内实现，也可以在类外实现，类内实现，只需像下方被注释的代码一样</span></span><br><span class="line">    <span class="comment">// friend void friend_func(MyClass* p)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     p-&gt;val = 0;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 成员函数做友元</span></span><br><span class="line">    <span class="comment">// 声明 void MidClass::read_some函数为友元，此函数就可以访问MyClass的私有属性，但MidClass的其他成员函数仍然不可以访问</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">MidClass::read_some</span><span class="params">(MyClass*)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 类做友元</span></span><br><span class="line">    <span class="comment">// 声明 FriendClass 作为友元， FriendClass 可以访问MyClass类的所有属性，相比成员函数做友元，这个权限更高</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">FriendClass</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局友元函数类外实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">friend_func</span><span class="params">(MyClass* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;val = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MidClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read_all</span><span class="params">(MyClass* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//p-&gt;val = 6; // 错误，此成员函数不是MyClass的友元</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">real_some</span><span class="params">(MyClass* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p-&gt;val = <span class="number">0</span>; <span class="comment">// 正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 正确的代码，FriendClass是MyClass的友元</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read_all</span><span class="params">(MyClass* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p-&gt;val = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">real_some</span><span class="params">(MyClass* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p-&gt;val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向对象：继承"><a href="#面向对象：继承" class="headerlink" title="面向对象：继承"></a>面向对象：继承</h2><h3 id="继承初步"><a href="#继承初步" class="headerlink" title="继承初步"></a>继承初步</h3><p>看这个网页<a href="%E7%82%B9%E6%88%91%E6%9F%A5%E7%9C%8B">https://ustarry.github.io/</a>，我们可以看到，在这个网页的 首页，领地，工具这些页面中，都有相同的标题栏，但是网页的内容不同。</p><p><img src="https://s1.ax1x.com/2023/02/26/pppwGvV.png"><br><img src="https://s1.ax1x.com/2023/02/26/pppcUhD.png"><br><img src="https://s1.ax1x.com/2023/02/26/pppwNbF.png"></p><p>像这样，我们可以通过<strong>继承的方式，让一个类继承一个类，继承后的类拥有原先类的所有行为，但可以有自己独特的行为</strong>，这样可以减少代码量，这就是继承的优势</p><p>如果类B继承类A，那么B叫做子类，A叫做基类。继承语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 子类名 : 继承方式 基类</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 子类的代码 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>继承方式有<code>public</code>, <code>protected</code>, <code>private</code>三种，如果不指定继承方式，在继承用class声明的类时默认使用private。使用public方式，父类的public属性的仍然在子类表现为public，protected也表现为public，private属性不可以访问<br>用protected方式，父类的public属性在子类表现为protected，protected属性表现为private，private属性的直接不可访问<br>用private方式，父类的public属性变为private，父类的其他属性再也不可以访问</p><p>例如上面的案例，我们就可以通过继承来减少代码：<br>这是不用继承的实现方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;星光工作室的网页&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;首页&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZonePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;星光工作室的网页&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;领域&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ToolPage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;星光工作室的网页&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;工具&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用继承之后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;星光工作室的网页&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomePage</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;首页&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZonePage</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;领域&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ToolPage</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;工具&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种代码效果等价，但是很明显第二种代码更少。这即为继承的优势</p><h3 id="继承的父类子类构造顺序和多继承"><a href="#继承的父类子类构造顺序和多继承" class="headerlink" title="继承的父类子类构造顺序和多继承"></a>继承的父类子类构造顺序和多继承</h3><p>继承之后，是先构建父类还是先构建子类呢？直接说结论，先构建父类，再构建子类。析构的时候，先析构子类，再析构父类。</p><p>C++允许一个类继承多个类，多继承语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 子类: 继承方式<span class="number">1</span> 父类<span class="number">1</span>， 继承方式<span class="number">2</span> 父类<span class="number">2</span> ...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 代码 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果父类和子类在某些成员上重名了，那么默认使用子类的属性，如果一定要使用父类的成员，使用 :: （作用域运算符） 强制使用父类的成员。</p><p>如，类Son是类Base的子类，这些类都定义了val属性。假设我们已经有了子类的一个实例叫做<code>obj</code>。如果我们想在子类访问子类的val属性，直接 <code>obj.val</code>，或使用作用域运算符<code>obj.Son::val</code>。用父类的属性，则必须<code>obj.Base::val</code></p><p>当然，作者不建议使用多继承。</p><h3 id="菱形继承和虚继承"><a href="#菱形继承和虚继承" class="headerlink" title="菱形继承和虚继承"></a>菱形继承和虚继承</h3><p>如果有类AA，BB，CC，DD，类AA有long long的，m_data1, m_data2，m_special属性。这时我们使BB继承了AA，CC继承AA，DD多继承BB和CC。像这样的继承，如果我们画出继承图像，图像看起来像菱形，因此这种继承方式被称为菱形继承，也称为钻石继承。我们来尝试输出D占的字节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_data1;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_data2;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_special;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> : <span class="keyword">public</span> AA&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CC</span> : <span class="keyword">public</span> AA&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DD</span> : <span class="keyword">public</span> BB, <span class="keyword">public</span> CC&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(DD) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们期望应该只占三个long long的和。然而，在作者的计算机处运行，结果居然占了48字节！</p><p><img src="https://s1.ax1x.com/2023/02/26/pppRtA0.png"></p><p>这是为什么呢？在这里我们可以使用MSVC的工具集来看一下这个类D在内存中的布局。</p><p>进入到存放此代码的目录，调出命令行，输入下方指令( <strong>注意是 d1不是 dl</strong>  )</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /d1 reportSingleClassLayoutDD test.cpp</span><br></pre></td></tr></table></figure><p>这段指令将查看test.cpp文件中类DD的内存布局模型，如果你想查看666.cpp文件中类Monster的内存布局模型，输入<code>cl /dl reportSingleClassLayoutMonster test.cpp</code></p><p>作者看到DD类的内存布局如下：</p><p><img src="https://s1.ax1x.com/2023/02/26/pppRUhT.png"></p><p>可以看到，如果像这种方式继承，我们浪费了很多字节。因为m_data1，m_data2，m_special本来就要一份就好，现在有这么多份。我们应该怎么做避免浪费呢？使用虚继承就可以了！看下列改进的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_data1;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_data2;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_special;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> AA&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CC</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> AA&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DD</span> : <span class="keyword">public</span> BB, <span class="keyword">public</span> CC&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(DD) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下这种状况下的内存布局，发现占用更少了！</p><p><img src="https://s1.ax1x.com/2023/02/26/pppRNNV.png"></p><p>原理到底是什么呢？原来，使用虚继承后，就<strong>改成继承 vbptr（virtual base pointer，虚基类指针）</strong>，而不是直接继承m_data1, m_data2, m_special。然后vbptr指向叫 <strong>vbtable(virtual base table虚基类表)</strong> 的东西，每一个进行虚继承的类，都会生成一个叫vbtable的表，这个表储存的是偏移量，这样就可以导致m_data1, m_data2, m_special只需要储存一份，BB,CC类使用vbptr指向的偏移量，偏移到储存m_data1, m_data2, m_special的位置就可以读取数据了，这样就形成了数据的共享，减少了占用。</p><p>当然并不推荐进行多继承，了解一下原理也是不错的。</p><h2 id="面向对象：多态"><a href="#面向对象：多态" class="headerlink" title="面向对象：多态"></a>面向对象：多态</h2><h3 id="多态认识"><a href="#多态认识" class="headerlink" title="多态认识"></a>多态认识</h3><p>多态，顾名思义，即为多种形态。多态可以分为静态多态和动态多态。</p><ul><li><p>静态多态：编译阶段确定调用函数的类型，即地址早绑定。例如函数的重载，运算符重载，模板(如CRTP技术)</p></li><li><p>动态多态：运行时才确定函数的类型，即地址晚绑定</p></li></ul><p>来看下列代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base\n&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Son1\n&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Son2\n&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_say</span><span class="params">(Base* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;<span class="built_in">say</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base s1;</span><br><span class="line">    Son1 s2;</span><br><span class="line">    Son2 s3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在存在一个问题，下面将调用的是son1::say函数还是base::say函数，</span></span><br><span class="line">    <span class="comment">// 还是son2::say函数，还是都有？</span></span><br><span class="line">    <span class="built_in">to_say</span>(&amp;s1);</span><br><span class="line">    <span class="built_in">to_say</span>(&amp;s2);</span><br><span class="line">    <span class="built_in">to_say</span>(&amp;s3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题似乎非常难解决。但是我们应该考虑到，但凭一个地址没有办法分辨是哪个类型的对象调用的say函数，<code>void to_say(Base*)</code>函数定义参数类型为Base*，因而，都调用的是<code>Base::say</code>函数。</p><p>但是，如果我们想传入哪个类型的对象，to_say就执行哪种类型的say函数。那么应该如何做呢？使用virtual关键字定义虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义虚函数，加virtual关键字即可</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base\n&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这时，下面的代码意义即为重写父类的虚函数</span></span><br><span class="line">    <span class="comment">// virtual 关键字可加可不加，意义都一样</span></span><br><span class="line">    <span class="comment">// virtual void say()</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Son1\n&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Son2\n&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">to_say</span><span class="params">(Base* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;<span class="built_in">say</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base s1;</span><br><span class="line">    Son1 s2;</span><br><span class="line">    Son2 s3;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">to_say</span>(&amp;s1);</span><br><span class="line">    <span class="built_in">to_say</span>(&amp;s2);</span><br><span class="line">    <span class="built_in">to_say</span>(&amp;s3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样之后，我们想传入哪个类型的对象，to_say就执行哪种类型的say函数。不信可试一下。使用虚函数，这样就可以使得这种想法实现了。</p><p>动态多态满足的条件：子类继承父类，并重写虚函数，并且传参数时传指针或者引用。</p><p>关于重写和重载的认识</p><ul><li>重写：函数返回值类型，函数名，函数参数列表完全一致</li><li>重载：函数名一致，但函数参数列表不同</li></ul><h3 id="虚函数原理"><a href="#虚函数原理" class="headerlink" title="虚函数原理"></a>虚函数原理</h3><p>我们使用MSVC的开发者工具分别查看上方未使用虚函数时，和使用虚函数时的类Son1内存布局。</p><p>之前</p><p><img src="https://s1.ax1x.com/2023/02/26/ppphJHA.png"></p><p>之后</p><p><img src="https://s1.ax1x.com/2023/02/26/ppphNNt.png"></p><p>我们可以清晰地看到，之后类Son1中多了**vfptr(virtual function pointer，虚函数指针)，虚函数指针指向vftable(virtual function table，虚函数表)**。每个类都有自己的虚函数表，虚函数表储存了类的所有虚函数的地址。如果本类重写了某名称的虚函数，那么本类的虚函数表的该名称的虚函数地址将使用为自己重写的函数的地址，否则就用父类的虚函数地址。函数调用时，通过读到对象的vfptr获得相应要调用的成员函数的地址，然后跳转到该地址执行代码。 每个子类都有不同的虚函数表，因此，传每个子类的实例上去，都会调用相应的函数，这就是虚函数原理了。</p><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>有时，我们的父类的虚函数不需要写任何代码，但是父类调用又没有任何意义，我们想强迫子类必须重写父类的虚函数。这时，我们就可以使用纯虚函数了。语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 直接使函数等于0</span></span><br><span class="line">    <span class="keyword">virtual</span> 返回值 函数名(<span class="comment">/*参数列表*/</span>) = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有一个及以上纯虚函数的类叫做虚基类，虚基类不可以实例化对象，因为如果要调用虚函数，虚基类可没有办法实现。这时，必须要子类继承，并重写父类的所有纯虚函数，如果没有重写完，子类也不可以实例化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doit</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Base b; // 错误，不可以实例化虚基类对象</span></span><br><span class="line">    Son s; <span class="comment">// 合法的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-11下面向对象的新关键字"><a href="#C-11下面向对象的新关键字" class="headerlink" title="C++11下面向对象的新关键字"></a>C++11下面向对象的新关键字</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>我们可以使用<code>final</code>关键字阻止子类重写虚函数，或者使某个类无法被继承</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AAA</span> <span class="keyword">final</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//class BBB : AAA &#123;&#125;;</span></span><br><span class="line"><span class="comment">// 错误，final 修饰的类不可以被继承</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">final</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCaller</span> ： <span class="keyword">public</span> Caller</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 错误，不能重写final修饰的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p><code>override</code>关键字保证函数必须重写了父类函数，如果没有重写，就会报错</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 报错，因为父类没有叫funx的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funx</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>如果我们想在构造对象时，委托另一构造函数执行部分工作，在C++11前没有办法做到，必须使用成员函数，现在我们可以直接委托构造函数进行构造的部分工作了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 委托Factory的其他构造函数完成构造的相关工作</span></span><br><span class="line">    <span class="built_in">Factory</span>() : <span class="built_in">Factory</span>(<span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;开工！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Factory</span>(<span class="type">int</span> people)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;开工人数&quot;</span> &lt;&lt; people &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h3><p>有时我们可以一步到位，直接继承完父类的所有构造函数，而不复制粘贴一遍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> Base&amp;) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">double</span> a, <span class="type">double</span> b) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> <span class="type">char</span>* c, <span class="type">char</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一句话，继承父类Base的所有构造函数</span></span><br><span class="line">    <span class="comment">// 父类有的所有构造函数，子类全部都有</span></span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="x3D-default-amp-x3D-delete"><a href="#x3D-default-amp-x3D-delete" class="headerlink" title="&#x3D;default &amp; &#x3D; delete"></a>&#x3D;default &amp; &#x3D; delete</h3><p>有的时候，我们想显示指定编译器生成默认的构造函数，我们就可以使用&#x3D;default</p><p>有的时候，有些类我们不想让他有拷贝构造函数，但是又想有默认构造函数，我们就可以使用&#x3D;delete</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使编译器生成默认的默认构函数</span></span><br><span class="line">    <span class="built_in">Base</span>() = <span class="keyword">default</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使编译器禁用拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Base</span>() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =delete还可以用来禁用析构函数，</span></span><br><span class="line">    <span class="comment">// 阻止隐式类型转换等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cplusplus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星光心灵 - 倾听是否重要</title>
      <link href="/blogs/posts/psychology/p320b63238c75.html"/>
      <url>/blogs/posts/psychology/p320b63238c75.html</url>
      
        <content type="html"><![CDATA[<p>We all like to tell our thoughts to others when in an informal conversation. As you can see, sometimes someone has not ended up talking, others can’t help cutting in. Who masters speaking is welcomed, but a man who is good at listening is also attractive.</p><p>我们都喜欢在非正式对话中向他人讲述我们的想法。如你所见，有时有人没有结束说话，其他人会忍不住插话。谁精通说话是受欢迎的，但善于倾听的人也很有吸引力。</p><p>In he occasion when a man listens to you, you will feel like you are respected, trusted, not ignored. It is the man who understands you! He does still listen to your words! A kind of entertaining feeling spreads through your mind. Thus, you can talk to him to your heart’s content.</p><p>当一个人听你说话时，你会觉得你受到尊重，被信任，没被忽视。他理解你！他听你的话！一种愉快的感觉弥漫在脑海。因此，你可以尽情地与他交谈。</p><p>One Mid-Autumn night, a man flew back to his home. The plane was suddenly about to crash down during the flight.Owing to the captain’s calm and professional moves, all the passengers were out of death, appreciated for life. However, as the man talked about this with his wife,  he was much excited and joyful, even he would screamed and shouted in the intriguing part, hopeing to share the unforgetable memory to her. The wife was just only in the joy of the festival, had no reacton with this. The huge contrast from words had the man downhill. Months later he broke up with her.</p><p>一个中秋的夜晚，一个男人乘飞机飞回家。飞机在飞行过程中突然要坠毁。由于机长的冷静和专业的操作，所有乘客都摆脱了死亡，感谢生命的美好。然而，当男人和妻子谈论这件事时，他非常兴奋和高兴，甚至他会在耐人寻味的部分尖叫和喊叫，希望将难忘的回忆分享给她。妻子只是在节日的喜悦中，对此没有任何反应。言语的巨大反差让男人十分低落。几个月后，他和她分手了。</p><p>In that case, that his wife did not reply to him ended up their marriage, although emotion between them before was so passionate and heated. Only in one day did they become passers-by.</p><p>在这种情况下，他的妻子没有回复他，终结了他们的婚姻。尽管他们之间的感情之前是如此情意绵绵，如此热情。仅仅一天，他们就成了路人。</p><p>Also, to listen can have we know more about someone. Hearing what patients talk about theirselves more has doctors heal them better. Hearing what students ask has teachers  process the lessons more quickly. Hearing what customers long for has the company offers splendiferous products more. The Panasonic Company’s manager often listens to its workers’ views. That is why it can success.</p><p>此外，倾听可以让我们更多地了解某人。听到病人更多地谈论他们的自我，医生可以更好地治愈他们。倾听学生的问题可以让老师更快地处理课程。听到客户渴望什么，公司提供了更多精彩的产品。松下公司的经理经常听取工人的意见。这就是为什么它可以成功。</p><p>What’s more, listening can further our knowledge. Listening to different people, we can receive a wide range of ideas. Animal-lovers’ words show how to protect animals. Well-known basketball players’ words give us the ecperience of practicing the basketball. World-famous writers’ words represent the tricks of writting. No matter who he is, we can learn a lot from it.</p><p>更重要的是，倾听可以增进我们的知识。倾听不同的人，我们可以收到各种各样的想法。动物爱好者的话说明了如何保护动物。知名篮球运动员的话，给了我们练习篮球的经验。世界著名作家的话，象征了写作的技巧。不管他是谁，我们都可以从中学到很多东西。</p><p>All in all, there is no denying that listening is useful.We cannot emphasize the importance of listening too much. The more you listen, the more you will be brilliant!</p><p>总而言之，不可否认，倾听是有用的。我们再怎么强调倾听的重要性也不为过。你听得越多，你就会越闪耀！</p>]]></content>
      
      
      <categories>
          
          <category> psychology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> psychology </tag>
            
            <tag> philosophy </tag>
            
            <tag> art </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星光心灵 - 如何安慰他人</title>
      <link href="/blogs/posts/psychology/p951ad8dc218a.html"/>
      <url>/blogs/posts/psychology/p951ad8dc218a.html</url>
      
        <content type="html"><![CDATA[<p>Life is like a wave, which will go up and down. We cannot avoid suffering. Thus, we all need others’ comfort. The following informations show the useful tips to comfort people.</p><p>人生就像波浪，会起起落落。我们无法避免痛苦。因此，我们都需要别人的安慰。以下信息显示了安慰人们的有用技巧。</p><p>Better not to…</p><p>最好不要…</p><ol><li><p>Tell him or her that your situation is worse 跟他比惨<br>When someone turns to you, it is clear he or she wants your comfort. Telling “Mine is worse” always means “I can afford the worse situation than yours. So why can’t you?”. Although our thoughts are reasonable and these words sound motivating, the one will still assume you never care about his feelings, for you did not mention something about him.<br>当有人想你求助时时，很明显他想要你的安慰。说“我的情况更糟糕”总是意味着“我能承受比你更糟糕的情况。那你为什么不能呢？”虽然我们的想法是合理的，这些话听起来很激励人心，但那个人仍然会认为你从不在乎他的感受，因为你没有提到有关他的事情。</p></li><li><p>Tell words like “I already told you…” 说出诸如“我已经告诉过你了……”之类的话<br>Never tell words like “I already told you…”, “Were I you, it would not …”, “Have you thunk of my words?” When we talk like this, we do wish that the bad would have not happened if the one would follow our suggestios. However, in the occasion when the one need comfort, these words may always bring extra meanings like “You made you bed, now lie on it”, “You do your math”, “Put the stone and hit your legs”. It cannot be like your helping him out.<br>永远不要说“我已经告诉过你……”，“如果我是你，就不会……”，“你把我的话扔掉了吗？”当我们这样说话时，我们确实希望如果一个人听从我们的建议，坏事就不会发生。然而，在需要安慰的场合，这些话可能总会带来额外的含义，比如“你自作自受”，“你自己解决”，“搬石头砸自己的脚”。这不可能像是你在帮助他。</p></li><li><p>Give advice immediately 立即提供建议<br>As the saying goes, “When in Rome, do as the Romans do”. To comfort us is the same thing. Therefore, do not give advice to the one immediately. It is not the time. When doing this, the one who longs for the comfort may have to think  “Am so stupid I that I need to be given lessons by you?” Things are in a wrong way!<br>常言道：“入乡随俗”。安慰我们也是一样的。因此，不要立即给建议给他们。时机还未到！这么做的时候，那些渴望安慰的人可能不得不认为“我是傻到需要被你教训？”事情在朝坏的方向发展！</p></li></ol><p>As a consequent, what can we do to have it not happen?<br>因此，我们能做些什么来避免它发生？</p><ol><li><p>Think what he thinks 想他所想<br>Everyone was born in different backgrounds, so their personalities, lifestyles, hobbies and minds are quite different. The most important part is to think what he thinks. We cannot force all to be like us. Only in this way can we shine in the sky together.<br>每个人出生在不同的背景中，所以他们的个性、生活方式、爱好和思想都大不相同。最重要的是想他所想。我们不能强迫所有人都像我们一样做事。只有这样，我们才能一起在天空中发光。</p></li><li><p>Have the one speak out the pain 让那个人说出痛苦<br>The one has been in disappointment and in blue for a long time. So just have the one speak out, in order to clear his mind, open his cheats, meet the better himself. Also, we need to listen to him carefully and patiently. You can cut in to further the process if you are good at it. Anyway, you should be like “Whatever, wherever, however, you can turn to me and I’ll always help you out. I’ll be your lighthouse forever”. Even if you say nothing, a hug can warm him much.<br>那个人已经失望和抑郁很长时间了。所以只要让那个人说出来，才能理清思路，敞开胸襟，遇见更好的自己。此外，我们需要仔细和耐心地倾听。如果你擅长，你可以插话以进一步推进该过程。无论如何，你应该像是“无论如何，无论在哪里，无论怎么样，你可以求助于我，我都会帮助你。我会永远是你的灯塔”。即使你一句不算，一个拥抱也能温暖他的内心。</p></li><li><p>Offer ideas if necessary 必要时提供想法<br>One can not always downhill any longer. So we have to find way out. But no offering ideas immediately until he is getting happier.<br>一个人不能再总是下坡了。所以我们必须找到出路。但是在他开心之前，不要立即提出想法。</p></li></ol><p>That is it! Drama will come to an end but our life will not. We just do hope we can live, happy and joyful!<br>就是这样！戏会落幕，但我们的人生不会。我们希望我们能快乐生活！</p>]]></content>
      
      
      <categories>
          
          <category> psychology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> psychology </tag>
            
            <tag> philosophy </tag>
            
            <tag> art </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：探索绘图编程和对话框</title>
      <link href="/blogs/posts/windows/pff3fd6e98f0e.html"/>
      <url>/blogs/posts/windows/pff3fd6e98f0e.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="探索绘图编程"><a href="#探索绘图编程" class="headerlink" title="探索绘图编程"></a>探索绘图编程</h2><p>GDI,Graphic Device Interface，Windows提供了大量API供我们绘制各种各样的图形。</p><p>Windows每个窗口都是绘制出来的，当窗口需要绘制的时候，产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/gdi/wm-paint">WM_PAINT消息</a>，进而我们可以绘制窗口。</p><p>HDC，即为设备上下文句柄，DC是设备windows特有的一个概念，我们需要使用他来绘图。</p><p>下面是简单的绘图代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyWindowApplication/resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;kernel32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;星光探索者&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hInstance = hInstance; </span><br><span class="line">    wc.lpfnWndProc = WinProc; </span><br><span class="line">    wc.lpszClassName = CLASSNAME; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>, CLASSNAME, TITLE,WS_OVERLAPPEDWINDOW, </span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT,  CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">NULL</span>,  <span class="literal">NULL</span>,  hInstance, <span class="literal">NULL</span> </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 定义绘图结构体，用来绘图</span></span><br><span class="line">        PAINTSTRUCT ps;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始绘画，得到DC</span></span><br><span class="line">        HDC hdc = <span class="built_in">BeginPaint</span>(hwnd, &amp;ps);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制图标</span></span><br><span class="line">        <span class="built_in">DrawIcon</span>(hdc, <span class="number">50</span>, <span class="number">50</span>, <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, <span class="built_in">LPCTSTR</span>(IDI_MYICON)));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i != <span class="number">40</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">10</span>; j != <span class="number">40</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 绘制一个点</span></span><br><span class="line">                <span class="built_in">SetPixel</span>(hdc, i, j, <span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束绘画</span></span><br><span class="line">        <span class="built_in">EndPaint</span>(hwnd, &amp;ps);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以简单的绘图了。只需BeginPaint获得HDC，然后调用相关的API（API直接查<a href="https://learn.microsoft.com/zh-cn/windows/win32/gdi/windows-gdi">官网相关资源</a>），然后再EndPaint，就可以了。但是并不是什么时候都可以绘图的，<strong>只有绘图消息和计时器消息发生时，绘图才会成功</strong>。</p><h2 id="使用对话框"><a href="#使用对话框" class="headerlink" title="使用对话框"></a>使用对话框</h2><p>对话框是一种窗口，他主要用于向用户显示信息或等待用户输入时的一个小弹窗。如果我们快速制作一个Win32程序，使用对话框是一种便捷方法。</p><p>同样是这个熟悉的界面，右键项目，添加(Add)，资源(Resource)</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8odt1.png"></p><p>点击对话框(Dialog)，之后VS显示了一个可视化的设计器。我们可以直接拖拽控件快速布局。大部分小伙伴都对很喜欢这种形式吧！</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8og7d.png"></p><p>为了示范，星光探索者之后就直接写代码了。</p><p>对话框根据显示后是否阻止与其他窗口交互，可分为模态对话框和非模态对话框。</p><ul><li><p>模态对话框：显示后阻止你创建的其他窗口交互</p></li><li><p>非模态对话框：显示后不阻止你创建的其他窗口交互</p></li></ul><p>模态对话框的创建方式，调用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-dialogboxw">DialogBox函数</a>。这个函数是阻塞函数，返回值为对话框销毁时的返回值。参数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT_PTR <span class="title">DialogBox</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,   <span class="comment">// 实例句柄，如果传NULL将使用当前的</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpTemplate,    <span class="comment">// 创建的资源模板，在资源文件</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWndParent,       <span class="comment">// 对话框的父窗口</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DLGPROC lpDialogFunc   <span class="comment">// 对话框消息过程处理函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>非模态对话框创建方式，调用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-createdialogw">CreateDialog函数</a>，参数如下，意义和上方相同，不多叙述。这个函数不是阻塞函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateDialog</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE  hInstance,     </span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR    lpName,</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND       hWndParent,</span></span></span><br><span class="line"><span class="params"><span class="function">    DLGPROC    lpDialogFunc</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>DLGPROC是对话框过程函数的类型，为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">INT_PTR</span> <span class="params">(CALLBACK* DLGPROC)</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br></pre></td></tr></table></figure><p>实际上和窗口消息过程函数是一模一样的。但是这个对话框过程函数的返回值如果为FALSE，表明还需要默认处理函数处理，否则不调用默认处理函数处理。</p><p>当对话框开始创建未显示时，产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/dlgbox/wm-initdialog">WM_INITDIALOG消息 </a>，不产生WM_CREATE消息。因此，对话框过程函数不应该处理WM_CREATE消息。各位感兴趣的小伙伴可验证一下。</p><p>模态对话框和非模态对话框的处理函数写法要求大不同。模态对话框销毁时使用<a href="https://learn.microsoft.com/zh-CN/windows/win32/api/Winuser/nf-winuser-enddialog">EndDialog 函数</a>，不可以使用DestroyWindow等函数；而非模态对话框销毁时使用<a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winuser/nf-winuser-destroywindow">DestroyWindow 函数</a>。</p><p>要想处理对话框内部的控件的操作，需要处理<a href="https://learn.microsoft.com/zh-cn/windows/win32/menurc/wm-command"> WM_COMMAND消息</a>。控件被点击时，lParam为控制窗口的句柄，wParam的高字节为控件的消息，低字节为控件ID标识符</p><p>下面是一个模态对话框的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;kernel32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;星光探索者&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(WHITE_BRUSH);</span><br><span class="line">    wc.hInstance = hInstance; </span><br><span class="line">    wc.lpfnWndProc = WinProc; </span><br><span class="line">    wc.lpszClassName = CLASSNAME; </span><br><span class="line">    wc.style = CS_HREDRAW | CS_VREDRAW; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>,CLASSNAME, TITLE, WS_OVERLAPPEDWINDOW, </span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span> </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">DialogProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">        <span class="comment">// 处理对话框被创建的消息</span></span><br><span class="line">        <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;对话框被创建&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;探索对话框&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="comment">// 处理对话框被点击的消息</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// IDOK和IDCANCEL都是定义好的，分别代表OK和CANCEL按钮</span></span><br><span class="line">        <span class="keyword">case</span> IDOK:</span><br><span class="line">            <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;我也觉得OK&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;来自对话框的信息&quot;</span>), MB_OK);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        <span class="keyword">case</span> IDCANCEL:</span><br><span class="line">            <span class="built_in">EndDialog</span>(hwnd, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_RBUTTONDOWN:</span><br><span class="line">        <span class="built_in">DialogBox</span>(<span class="literal">NULL</span>, (LPCTSTR)IDD_DIALOG1, hwnd, DialogProc);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个实例，当我们鼠标右键的时候，弹出一个消息框后弹出对话框。点击OK按钮，将显示“我也觉得OK啊“；点击CANCEL按钮，将关闭对话框。</p><h2 id="使用系统定义好的控件"><a href="#使用系统定义好的控件" class="headerlink" title="使用系统定义好的控件"></a>使用系统定义好的控件</h2><p>对话框里能拖出这么多控件，实际上系统已经提前定义好了一些控件。</p><p>包含头文件<code>CommCtrl.h</code>，这个头文件定义了很多<a href="https://learn.microsoft.com/zh-cn/windows/win32/controls/common-control-window-classes">定义好的系统窗口类 </a>。但是你需要在<code>#include &lt;windows.h&gt;</code>头文件后再<code>#include &lt;CommCtrl.h&gt;</code>，因为你微软居然要用windows.h头文件，居然不包含，导致编译的时候提示有很多标识符未定义，不这么做会报错。</p><p>系统已经定义好的控件包括WC_BUTTON(按钮)，WC_EDIT(文本编辑框)，WC_STATIC(不可改文本控件)，WC_TREEVIEW(树状图)，ANIMATE_CLASS(动画)等。</p><p>窗口控件的消息，是通过<a href="https://learn.microsoft.com/zh-cn/windows/win32/menurc/wm-command">WM_COMMAND消息</a>间接传上来的。 <strong>控件被点击时，lParam为控制窗口的句柄，wParam的高字节为控件的消息，低字节为控件ID标识符。</strong> 这个在对话框消息过程函数已经提及。</p><p>看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;CommCtrl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;kernel32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;星光探索者&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(WHITE_BRUSH);</span><br><span class="line">    wc.hInstance = hInstance; </span><br><span class="line">    wc.lpfnWndProc = WinProc; </span><br><span class="line">    wc.lpszClassName = CLASSNAME; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>,CLASSNAME, TITLE, WS_OVERLAPPEDWINDOW, </span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span> </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// GetModuleHandle用于获得程序的hInstance，</span></span><br><span class="line">        <span class="comment">// 就是WinMain函数那里的hInstnace</span></span><br><span class="line">        HINSTANCE hInstance = <span class="built_in">GetModuleHandle</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// WC_BUTTON是按钮类，BS_PUSHBUTTON是按钮的风格</span></span><br><span class="line">        <span class="comment">// 下方的代码创建了一个按钮</span></span><br><span class="line">        <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">            <span class="number">0</span>, WC_BUTTON, <span class="built_in">TEXT</span>(<span class="string">&quot;BUTTON&quot;</span>), </span><br><span class="line">             WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, </span><br><span class="line">            <span class="number">5</span>, <span class="number">5</span>, <span class="number">100</span>, <span class="number">100</span>, hwnd, </span><br><span class="line">            <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="comment">// 控件的消息通过wParam间接传递</span></span><br><span class="line">        <span class="comment">// BN_CLICKED是按钮被点击时产生的消息</span></span><br><span class="line">        <span class="comment">// 点击下方链接查看按钮的部分相关内容 </span></span><br><span class="line">        <span class="comment">// https://zhuanlan.zhihu.com/p/353558221</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">HIWORD</span>(wParam) == BN_CLICKED)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;按钮被点击！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;你好！&quot;</span>), MB_OK);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行本程序，可以看到成功创建了一个按钮，并且点击之后会弹出“按钮被点击”的消息框。</p><h2 id="阶段小结"><a href="#阶段小结" class="headerlink" title="阶段小结"></a>阶段小结</h2><p>经过了好几篇文章的探索，想必你对Win32程序设计有了更深一步的了解，可以继续探索Windows了。转眼间春节就要到了，星光探索者祝各位春节快乐！</p><p>本期到此结束！感谢各位小伙伴的阅读！</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：使用计时器和菜单，图标，光标等资源文件</title>
      <link href="/blogs/posts/windows/p71040f0575db.html"/>
      <url>/blogs/posts/windows/p71040f0575db.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="使用计时器"><a href="#使用计时器" class="headerlink" title="使用计时器"></a>使用计时器</h2><p>计时器是Windows的一种资源。定时器每隔一段时间，会产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/winmsg/wm-timer">WM_TIMER消息 </a>。WM_TIMER附带的两个信息wParam, lParam分别是计时器的id, 计时器到点的处理函数。定时器的精度是毫秒，但是准确度不好。也就是说如果设置间隔1000ms，不一定会在1000ms后刚好产生消息。但是误差不会这么大，最多也就几毫秒。</p><p>要使用计时器，需要用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-settimer">SetTimer函数</a>创建定时器。SetTimer的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT_PTR <span class="title">SetTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND      hWnd,       <span class="comment">// 计时器关联的窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT_PTR  nIDEvent,   <span class="comment">// 计时器的ID，自己随意定，但不能为0</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT      uElapse,    <span class="comment">// 计时器的间隔，单位毫秒</span></span></span></span><br><span class="line"><span class="params"><span class="function">    TIMERPROC lpTimerFunc <span class="comment">// 计时器到点的处理函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数返回创建的计时器ID，如果创建失败了返回0。如果<code>lpTimerFunc</code>传的是NULL，计时器的时间到了，就将发送WM_TIMER消息通知关联的窗口过程函数处理，否则就不发WM_TIMER消息，直接调用<code>lpTimerFunc</code>处理。计时器依赖于消息循环，也就是要使用计时器，就需要消息循环。</p><p><a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winuser/nc-winuser-timerproc">TIMERPROC </a>是计时器回调函数的类型，因此计时器回调函数lpTimeProc因定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> CALLBACK <span class="title">lpTimerProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HWND hWnd,         <span class="comment">// 与计时器关联</span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT nMsg,         <span class="comment">// 消息类型(WM_TIMER)</span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT_PTR uTImerid, <span class="comment">// 计时器ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwTime       <span class="comment">// 时间延迟</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>计时器是系统资源，销毁计时器使用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-killtimer">KillTimer 函数 </a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">KillTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND     hWnd,    <span class="comment">// 销毁计时器的关联窗口</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT_PTR uIDEvent</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>示例代码：创建两个计时器，时间间隔分别为1000毫秒和2000毫秒，每调一次将打印一些字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 各位如果用Visual Studio开发工具，可能会出现某些函数VS觉得不安全不给用</span></span><br><span class="line"><span class="comment">// 如果还是想用，加上这句语句</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;kernel32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;window&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(DKGRAY_BRUSH);</span><br><span class="line">    wc.hIcon = <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, IDI_APPLICATION);</span><br><span class="line">    wc.hCursor = <span class="built_in">LoadCursor</span>(<span class="literal">NULL</span>, IDC_ARROW);  </span><br><span class="line">    wc.hInstance = hInstance; </span><br><span class="line">    wc.lpfnWndProc = WinProc; </span><br><span class="line">    wc.lpszClassName = CLASSNAME; </span><br><span class="line">    wc.lpszMenuName = <span class="literal">NULL</span>; </span><br><span class="line">    wc.style = CS_HREDRAW | CS_VREDRAW; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>,CLASSNAME, TITLE, WS_OVERLAPPEDWINDOW, </span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>,  hInstance, <span class="literal">NULL</span> </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> UINT_PTR timer1, timer2;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">FreeConsole</span>();</span><br><span class="line">        <span class="comment">// 销毁定时器</span></span><br><span class="line">        <span class="built_in">KillTimer</span>(hwnd, timer1);</span><br><span class="line">        <span class="built_in">KillTimer</span>(hwnd, timer2);</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">        <span class="built_in">AllocConsole</span>();</span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;CONOUT$&quot;</span>, <span class="string">&quot;w+t&quot;</span>, stdout);</span><br><span class="line">        <span class="comment">// 创建定时器</span></span><br><span class="line">        timer1 = <span class="built_in">SetTimer</span>(hwnd, <span class="number">1</span>,</span><br><span class="line"> <span class="number">1000</span>, <span class="literal">NULL</span>);</span><br><span class="line">        timer2 = <span class="built_in">SetTimer</span>(hwnd, <span class="number">2</span>, <span class="number">2000</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">case</span> WM_TIMER: </span><br><span class="line">        <span class="comment">// 处理计时器消息</span></span><br><span class="line">        <span class="keyword">if</span> (wParam == timer1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;timer1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wParam == timer2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;timer2\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用菜单资源"><a href="#使用菜单资源" class="headerlink" title="使用菜单资源"></a>使用菜单资源</h2><p>我们创建窗口时很想让这个窗口显示自己的东西，那么我们应该怎么做呢？</p><p>星光探索者前面的说过有个资源编译器rc.exe，可以编译资源文件。首先我们先探索一下如何添加资源吧！</p><p>对准想添加资源的项目右键，弹出下面的菜单。依次点击添加(Add)，资源(Resource)即可。</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oN79.png"></p><p>然后弹出这样的对话框，选择菜单(Menu)，然后点击新建（New）</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8odt1.png"><br>然后将会在Visual Studio弹出可视化的编辑器。相信不用星光探索者多说，各位小伙伴都会摸索的出来如何添加菜单项吧。</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oc0H.png"></p><p>之后在你的项目管理器会添加一个resource.h（可以改名）头文件，和拓展名为.rc的资源文件。资源文件是一种用脚本语言书写的代码文件，当然如果小伙伴乐意，可手写资源文件。在编译过程中，资源文件会被资源编译器(在VC++是rc.exe)编译成.rsc的目标文件，进而通过链接器(在VC++是link.exe)编译成最终文件。</p><p>资源创建了，如何使用呢？刚才添加的resource.h文件定义了那些ID标识符。在打开的资源管理器(Resource View)中，选中添加的菜单，然后右键，点击(Resource Symbol)即可查看添加的资源的id。星光探索者这里创建的菜单ID为IDC_MENU1。当然也可以直接查看resource.h头文件</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8ot0J.png"></p><p>还记得创建窗口类时的WNDCLASS结构体吗？那里有一个lpszMenuName属性，给他赋值就可以使用我们添加的菜单资源了。lpszMenuName需要LPCTSTR的类型，资源文件定义的ID都是数值，我们只需进行强制转换即可。或者CreateWindowEx的第10个参数也是叫传菜单句柄的，也可以选择在那里使用菜单资源。</p><p>既然有了菜单，我们就应该处理菜单的相关消息。处理菜单消息应该处理<a href="https://learn.microsoft.com/zh-cn/windows/win32/menurc/wm-command">WM_COMMAND消息</a>。当窗口内的控件（如按钮，文本等）被点击时，或菜单项被点击时，或窗口标题栏那些按钮（如最小化）被点击时产生此消息。当菜单项被点击时，wParam的高字节为0，低字节为点击的菜单项ID，菜单项ID之前已探索过如何找到。</p><p>于是我们写出像下面这样的代码来使用菜单资源：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;kernel32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;window&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(DKGRAY_BRUSH);</span><br><span class="line">    wc.hIcon = <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, IDI_APPLICATION);</span><br><span class="line">    wc.hCursor = <span class="built_in">LoadCursor</span>(<span class="literal">NULL</span>, IDC_ARROW);  </span><br><span class="line">    wc.hInstance = hInstance; </span><br><span class="line">    wc.lpfnWndProc = WinProc; </span><br><span class="line">    wc.lpszClassName = CLASSNAME; </span><br><span class="line">    <span class="comment">// 强制转换即可使用，星光探索者这里的菜单资源为 IDR_MENU1</span></span><br><span class="line">    wc.lpszMenuName = (LPCWSTR)IDR_MENU1; </span><br><span class="line">    wc.style = CS_HREDRAW | CS_VREDRAW; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>,CLASSNAME, TITLE, WS_OVERLAPPEDWINDOW, </span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="comment">// CreateWindowEx的第10个参数也是叫传菜单句柄的</span></span><br><span class="line">        <span class="comment">// 也可以使用LoadMenu来加载菜单资源</span></span><br><span class="line">        <span class="comment">//LoadMenu(NULL, LPCTSTR(IDR_MENU1)), </span></span><br><span class="line">        <span class="literal">NULL</span>, </span><br><span class="line">        hInstance, <span class="literal">NULL</span> </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        <span class="comment">// 处理菜单项被点击，需要处理WM_COMMAND消息</span></span><br><span class="line">        <span class="comment">// wParam的低字节为被点击的菜单项ID，用LOWORD进行获取</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">LOWORD</span>(wParam))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 星光探索者已经改过这些菜单项的名字了</span></span><br><span class="line">        <span class="keyword">case</span> ID_NEW:</span><br><span class="line">            <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;点击新建选项&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;星光探索者&quot;</span>), MB_OK);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ID_OPEN:</span><br><span class="line">            <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;点击打开选项&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;星光探索者&quot;</span>), MB_OK);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，点击菜单的新建选项，将出现这样的效果：</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oYm4.png"></p><h2 id="右键菜单实现"><a href="#右键菜单实现" class="headerlink" title="右键菜单实现"></a>右键菜单实现</h2><p>用过办公软件和浏览器的小伙伴都会体验过，鼠标右键会弹出一个菜单。那么我们应该如何实现呢？</p><p>直接说结论：我们使用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-trackpopupmenu">TrackPopupMenu 函数</a>可以弹出一个快捷菜单，这就是我们期望的。TrackPopupMenu是阻塞函数，直到菜单消失才会返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">TrackPopupMenu</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HMENU      hMenu,        <span class="comment">// 菜单句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT       uFlags,       <span class="comment">// 菜单弹出方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>        x,            <span class="comment">// 菜单的x坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>        y,            <span class="comment">// 菜单的y坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>        nReserved,    <span class="comment">// 预留参数，传NULL即可</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HWND       hWnd,         <span class="comment">// 拥有快捷菜单的窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> RECT *prcRect      <span class="comment">// 此参数被忽略，传NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>然后什么时候弹出呢？我们可以通过处理WM_RBUTTONDOWN（鼠标右键按下）消息来实现，可以是可以。但是事实告诉我们微软提供了<a href="https://learn.microsoft.com/zh-cn/windows/win32/menurc/wm-contextmenu">WM_CONTEXTMENU消息</a>，这样更便捷，这是上下文菜单的消息。正好可以使用右键菜单。</p><p>此消息附带的两个参数如下：</p><ul><li><p><code>wParam</code> 用户右键点击鼠标的窗口句柄</p></li><li><p><code>lParam</code> 低字节表示鼠标光标的x坐标，高字节表示y坐标，这是相对屏幕而言的</p></li></ul><h2 id="添加图标和光标资源"><a href="#添加图标和光标资源" class="headerlink" title="添加图标和光标资源"></a>添加图标和光标资源</h2><p>和前面添加菜单资源一样，但是如果我们有现成的，在弹出这个对话框时，就可以点击导入(Import)使用现有资源。这个步骤相信各位摸索都可以摸索出来。</p><p>然后再调用LoadIcon，LoadCursor即可。</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8odt1.png"></p><p>本期到此结束，下期看星光探索者探索Windows绘图编程和对话框</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：处理常用的消息和自定义消息</title>
      <link href="/blogs/posts/windows/p8cad54b0e5bf.html"/>
      <url>/blogs/posts/windows/p8cad54b0e5bf.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><p>下发假设您自己的窗口类的窗口过程函数均为WndProc，且您正确的按流程写了自定义的窗口程序</p><p>下方均是提供的一种处理方式的代码，并不是必须要这么做。</p><h2 id="处理WM-CLOSE消息"><a href="#处理WM-CLOSE消息" class="headerlink" title="处理WM_CLOSE消息"></a>处理WM_CLOSE消息</h2><p>WM_CLOSE消息在窗口即将终止时产生。</p><p>此消息附带的两个信息</p><ul><li><p><code>wParam</code> 未使用</p></li><li><p><code>lParam</code> 未使用</p></li></ul><p>处理窗口过程函数一个例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="comment">// 应调用此函数，这样会发送WM_QUIT消息</span></span><br><span class="line">        <span class="comment">// 使GetMessage返回0，这样进程才会正确退出</span></span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);  </span><br><span class="line">        <span class="comment">// 不要让默认处理函数处理，否则可能会出错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，WM_DESTROY和WM_QUIT也有退出的意思，这三个消息有什么区别呢？</p><p>WM_DESTROY在窗口销毁时产生，附带的两个信息和WM_CLOSE相同。但在WM_CLOSE可以选择决定是否销毁窗口。WM_QUIT消息在调用PostQuitMessage产生，使得GetMessage返回0。</p><h2 id="处理WM-CREATE消息"><a href="#处理WM-CREATE消息" class="headerlink" title="处理WM_CREATE消息"></a>处理WM_CREATE消息</h2><p>WM_CREATE消息在窗口被创建时产生，在<strong>CreateWindow函数返回之前且窗口未显示之前</strong>产生。如果这个消息返回0，窗口将会被创建，返回-1将销毁创建的窗口。通常处理此消息时，我们初始化一些数据。</p><p>此事件附带的参数</p><ul><li><p><code>wParam</code> 未使用</p></li><li><p><code>lParam</code> 指向 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/ns-winuser-createstructa"><strong>CREATESTRUCT</strong></a>结构的指针，可以获得CreateWindow的全部参数</p></li></ul><p>处理窗口过程函数一个示例如下（运行本示例，您应该能看到先弹出一个消息框，再显示窗口）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="comment">// 大部分小伙伴刚掌握时还不太熟练Windows基本数据类型</span></span><br><span class="line">            <span class="comment">// LPCTSTR = const TCHAR*</span></span><br><span class="line">            <span class="comment">// CREATESTRUE结构可以获得CreateWindow传的所有参数</span></span><br><span class="line">            <span class="comment">// lpszClassName是其中之一</span></span><br><span class="line">            <span class="comment">// reinterpret_cast是C++的类型转换使用的，</span></span><br><span class="line">            LPCTSTR lpClassName = <span class="built_in">reinterpret_cast</span>&lt;CREATESTRUCT*&gt;(lParam)-&gt;lpszClass;</span><br><span class="line">            <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;窗口创建了！&quot;</span>), lpClassName, MB_OK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理WM-SIZE消息"><a href="#处理WM-SIZE消息" class="headerlink" title="处理WM_SIZE消息"></a>处理WM_SIZE消息</h2><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/winmsg/wm-size">WM_SIZE消息</a>将在窗口被调整大小结束后产生。窗口在第一次创建的时候理所当然会调整大小，所以至少会触发一次</p><p>此消息附带的两个信息</p><ul><li><p><code>wParam</code> 调整大小的方式</p></li><li><p><code>lParam</code> 调整后的新范围。低字节为调整后的新宽度，高字节为调整后的新高度</p></li></ul><p>处理此事件的一个示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;iostream&gt; // 使用std::cout包含了这个头文件</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 销毁分配的控制台</span></span><br><span class="line">        <span class="built_in">FreeConsole</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">        <span class="comment">// 给此窗口分配控制台，控制台会由系统处理</span></span><br><span class="line">        <span class="built_in">AllocConsole</span>();</span><br><span class="line">        <span class="comment">// 重定向标准输出流，使得printf可以在控制台输出</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;CONOUT$&quot;</span>,<span class="string">&quot;w+t&quot;</span>, stdout);</span><br><span class="line">    <span class="keyword">case</span> WM_SIZE:</span><br><span class="line">        <span class="comment">// 可用 LOWORD 获取低字节内容 HIWORD 获取高字节内容</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;宽度&quot;</span> &lt;&lt; <span class="built_in">LOWORD</span>(lParam) &lt;&lt; <span class="string">&quot;高度&quot;</span> &lt;&lt; <span class="built_in">HIWORD</span>(lParam) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行此程序，可能的结果如下：</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8or6O.png"></p><h2 id="处理常见鼠标消息"><a href="#处理常见鼠标消息" class="headerlink" title="处理常见鼠标消息"></a>处理常见鼠标消息</h2><p>鼠标移动，按下，松开，会产生鼠标消息。一般情况下，只有在你自己的窗口产生的鼠标消息，才会接收到，要想鼠标在哪个窗口都能处理到鼠标消息，请使用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setcapture">SetCapture 函数 </a>。</p><p>鼠标在窗口移动时，产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-mousemove">WM_MOUSEMOVE消息</a>消息，根据移动的快慢，产生WM_MOUSEMOVE的消息频率是不同的</p><p>鼠标左键按下时，产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-lbuttondown">WM_LBUTTONDOWN消息 </a>，松开时产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-lbuttonup">WM_LBUTTONUP消息</a>。鼠标右键按下时，产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-rbuttondown">WM_RBUTTONDOWN消息</a>，松开时产生<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-rbuttonup">WM_RBUTTONUP消息 </a></p><p>消息产生均附带的两个信息</p><ul><li><p><code>wParam</code> 产生消息时，其他按键的情况（例如Ctrl,Shift键有没有按下）</p></li><li><p><code>lParam</code> 产生消息时，低字节为鼠标的x坐标，高字节为鼠标的y坐标，是相对窗口而言的</p></li></ul><p>处理消息的一种示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">FreeConsole</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">        <span class="built_in">AllocConsole</span>();</span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;CONOUT$&quot;</span>,<span class="string">&quot;w+t&quot;</span>, stdout);</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;鼠标左键按下 x:%d y: %d\n&quot;</span>, <span class="built_in">LOWORD</span>(lParam), <span class="built_in">HIWORD</span>(lParam));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONUP:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;鼠标左键松开 x:%d y: %d\n&quot;</span>, <span class="built_in">LOWORD</span>(lParam), <span class="built_in">HIWORD</span>(lParam));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_MOUSEMOVE:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;鼠标移动消息 x:%d y: %d\n&quot;</span>, <span class="built_in">LOWORD</span>(lParam), <span class="built_in">HIWORD</span>(lParam));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="鼠标双击消息"><a href="#鼠标双击消息" class="headerlink" title="鼠标双击消息"></a>鼠标双击消息</h2><p>当鼠标左键或右键或中键双击时，并且创建窗口时使用CS_DBCLICK风格，才会产生产生鼠标双击消息。很多小伙伴可能疑惑鼠标中键在哪。实际上鼠标的那个滚轮是可以按下去的，那个就是鼠标中键了。并不是鼠标双击消息产生时，就不会产生鼠标单击消息。</p><p>以鼠标左键双击消息(<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-lbuttondblclk">WM_LBUTTONDBLCLK</a>)，产生消息的顺序是：</p><p>WM_LBUTTONDOWN, WM_LBUTTONUP, WM_LBUTTONDBLCLK, WM_LBUTTONUP</p><p>消息产生均附带的两个信息</p><ul><li><p><code>wParam</code> 产生消息时，其他按键的情况（例如Ctrl,Shift键有没有按下）</p></li><li><p><code>lParam</code> 产生消息时，低字节为鼠标的x坐标，高字节为鼠标的y坐标，是相对窗口而言的</p></li></ul><h2 id="键盘消息"><a href="#键盘消息" class="headerlink" title="键盘消息"></a>键盘消息</h2><p>当键盘的案件被按下或松开时，产生键盘事件。如<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-keydown">WM_KEYDOWN 消息</a>，<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-keyup">WM_KEYUP 消息</a>等。</p><p>消息产生均附带的两个信息</p><ul><li><p><code>wParam</code> 按下按键的VirtualKey（虚拟键代码）</p></li><li><p><code>lParam</code> 按键的参数（如点击了几次）</p></li></ul><p>按下按键只会表明按下的是哪个按键，例如在输入大写字母A和小写字母a时，都是按下了a键，产生WM_KEYDOWN或WM_KEYUP等时没法区分。如果要得到按下按键时的ASCII值，使用<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-char">WM_CHAR 消息 </a>更加方便。</p><h2 id="自定义消息"><a href="#自定义消息" class="headerlink" title="自定义消息"></a>自定义消息</h2><p>有的时候，我们想有自定义消息，那么我们可以使用<a href="https://learn.microsoft.com/zh-CN/windows/win32/winmsg/wm-user">WM_USER</a>宏。自定义消息的格式为WM_USER + x。</p><p>以下是消息编号的范围。</p><table><thead><tr><th>范围</th><th>含义</th></tr></thead><tbody><tr><td>0 到 <strong>WM_USER</strong> –1</td><td>保留供系统使用的消息。</td></tr><tr><td>通过 0x7FFF <strong>进行WM_USER</strong></td><td>用于专用窗口类的整数消息。</td></tr><tr><td>通过0xBFFF <a href="https://learn.microsoft.com/zh-CN/windows/win32/winmsg/wm-app"><strong>WM_APP (0x8000)</strong></a></td><td>可供应用程序使用的消息。</td></tr><tr><td>通过 0xFFFF 进行0xC000</td><td>应用程序使用的字符串消息。</td></tr><tr><td>大于 0xFFFF</td><td>系统保留。</td></tr></tbody></table><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">// 定义自己的消息</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_MESSAGE WM_USER + 2</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;window&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(DKGRAY_BRUSH); <span class="comment">// background color</span></span><br><span class="line">    wc.hIcon = <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, IDI_APPLICATION);              <span class="comment">// window&#x27;s icon</span></span><br><span class="line">    wc.hCursor = <span class="built_in">LoadCursor</span>(<span class="literal">NULL</span>, IDC_ARROW);                <span class="comment">// window&#x27;s cursor</span></span><br><span class="line">    wc.hInstance = hInstance;                                <span class="comment">// window&#x27;s instance</span></span><br><span class="line">    wc.lpfnWndProc = WinProc;                                <span class="comment">// window process callback</span></span><br><span class="line">    wc.lpszClassName = CLASSNAME;                            <span class="comment">// name of the window class</span></span><br><span class="line">    wc.lpszMenuName = <span class="literal">NULL</span>;                                  <span class="comment">// name of the menu</span></span><br><span class="line">    wc.style = CS_HREDRAW | CS_VREDRAW;                      <span class="comment">// window style</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>,                   <span class="comment">// optional window style</span></span><br><span class="line">        CLASSNAME,           <span class="comment">// window class</span></span><br><span class="line">        TITLE,               <span class="comment">// window title</span></span><br><span class="line">        WS_OVERLAPPEDWINDOW, <span class="comment">//window style</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// width and height</span></span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT, </span><br><span class="line">        <span class="comment">// x y</span></span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line"></span><br><span class="line">        <span class="literal">NULL</span>,                <span class="comment">// parent window</span></span><br><span class="line">        <span class="literal">NULL</span>,                <span class="comment">// menu</span></span><br><span class="line">        hInstance,           <span class="comment">// instance handle</span></span><br><span class="line">        <span class="literal">NULL</span>                 <span class="comment">// additional application data</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (hwnd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在鼠标左键时发送消息处理，并获得处理结果</span></span><br><span class="line">        LRESULT nRet = <span class="built_in">SendMessage</span>(hwnd, MY_MESSAGE, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (nRet == <span class="number">114514</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;好臭的处理方式!&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;差评&quot;</span>), MB_ICONWARNING);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理自定义消息</span></span><br><span class="line">    <span class="keyword">case</span> MY_MESSAGE:</span><br><span class="line">        <span class="built_in">MessageBox</span>(hwnd, <span class="built_in">TEXT</span>(<span class="string">&quot;处理我自己的消息！&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;MY_MESSAGE&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">114514</span>; <span class="comment">// 返回处理结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行此代码，应该在鼠标左键时弹出一个消息框显示”处理我自己的消息！”，然后显示”好臭的处理方式!”。</p><p>本期到此结束，下期看星光探索者探索使用计时器和菜单，图标，光标等资源文件</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：创建自己的窗口和探索消息机制</title>
      <link href="/blogs/posts/windows/p94939f4d9192.html"/>
      <url>/blogs/posts/windows/p94939f4d9192.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="创建自己的窗口"><a href="#创建自己的窗口" class="headerlink" title="创建自己的窗口"></a>创建自己的窗口</h2><p>前两期的探索内容并没有创建属于自己的窗口，那么我们应该如何创建属于自己的窗口呢？</p><p>一提到窗口，你很可能会想到下面的画面</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oRAA.png"></p><p>没错，这就是一个窗口！实际上，这个应用程序的所有按钮，文本编辑框，菜单都是窗口。有的时候，我们在使用办公软件（如WPS，微软办公套件等），或浏览器时，我们通过点击一下鼠标右键，就弹出了一个菜单，俗称右键菜单。这个右键菜单也可以是窗口，当右键菜单没显示的时候，我们按了一下右键，他就显示了。这样看来，<strong>窗口既可以是显示的，也可以是不显示的</strong>。</p><p>因而，我们可以认为窗口是：</p><ul><li>占据屏幕的某些部分。</li><li>在给定时刻可能看不到或可能不可见。</li><li>了解如何绘制自身。</li><li>响应用户或操作系统的事件。</li></ul><p>说了这么多，让我们一起探索如何创造自己的窗口吧！</p><p>一个完整的窗口程序需要这些步骤：注册窗口类、创建窗口、处理消息。话不多说，看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果报错unresolved symbol无法解析的外部符号错误，就手动链接下面的库</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明窗口处理函数，用于处理窗口消息</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INT APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR TITLE[] = <span class="built_in">TEXT</span>(<span class="string">&quot;window&quot;</span>);</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TCHAR CLASSNAME[] = <span class="built_in">TEXT</span>(<span class="string">&quot;MyStruct&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WNDCLASS 是窗口类结构体</span></span><br><span class="line">    <span class="comment">// 窗口类结构体至少要给 lpfnWndProc，hInstance, lpszClassName</span></span><br><span class="line">    <span class="comment">// 这些属性赋值，否则创建窗口不会成功</span></span><br><span class="line">    WNDCLASS wc&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    wc.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(DKGRAY_BRUSH); <span class="comment">// 窗口的背景颜色</span></span><br><span class="line">    wc.hIcon = <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, IDI_APPLICATION);              <span class="comment">// 标题栏图标样式</span></span><br><span class="line">    wc.hCursor = <span class="built_in">LoadCursor</span>(<span class="literal">NULL</span>, IDC_ARROW);                <span class="comment">// 鼠标样式</span></span><br><span class="line">    wc.hInstance = hInstance;                                <span class="comment">// 实例句柄</span></span><br><span class="line">    wc.lpfnWndProc = WinProc;                                <span class="comment">// 窗口过程函数</span></span><br><span class="line">    wc.lpszClassName = CLASSNAME;                            <span class="comment">// 窗口类名称</span></span><br><span class="line">    wc.lpszMenuName = <span class="literal">NULL</span>;                                  <span class="comment">// 窗口菜单名称</span></span><br><span class="line">    wc.style = CS_HREDRAW | CS_VREDRAW;                      <span class="comment">// 窗口风格</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步：注册窗口类</span></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：创建窗口</span></span><br><span class="line">    <span class="comment">// 调这个函数，返回窗口句柄，如果创建窗口失败，返回NULL</span></span><br><span class="line">    HWND hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>,                   <span class="comment">// 窗口的其他风格</span></span><br><span class="line">        CLASSNAME,           <span class="comment">// 窗口类名</span></span><br><span class="line">        TITLE,               <span class="comment">// 窗口标题栏文字</span></span><br><span class="line">        WS_OVERLAPPEDWINDOW, <span class="comment">// 窗口风格</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// CW_USEDEFAULT 表示使用默认值</span></span><br><span class="line">        <span class="comment">// 窗口初始宽度和高度</span></span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT, </span><br><span class="line">        <span class="comment">// 窗口初始x坐标和y坐标</span></span><br><span class="line">        CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line"></span><br><span class="line">        <span class="literal">NULL</span>,                <span class="comment">// 父窗口</span></span><br><span class="line">        <span class="literal">NULL</span>,                <span class="comment">// 菜单</span></span><br><span class="line">        hInstance,           <span class="comment">// 当前实例句柄</span></span><br><span class="line">        <span class="literal">NULL</span>                 <span class="comment">// 附加的内存</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 判断窗口是否创建成功</span></span><br><span class="line">    <span class="keyword">if</span> (hwnd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建窗口失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 展示窗口（第一个参数为要展示的窗口句柄，第二个参数为显示的方式）</span></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line">    <span class="comment">// 更新窗口</span></span><br><span class="line">    <span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行消息循环</span></span><br><span class="line">    MSG msg&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// GetMessage函数用于抓取窗口的消息，这样才能操作窗口</span></span><br><span class="line">    <span class="comment">// 如果抓不到消息，GetMessage返回0，也就是说应用程序该结束了</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 翻译消息（非必要步骤），如果要处理键盘事件，需要翻译消息</span></span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="comment">// 分发消息（必要步骤，否则窗口无法得到消息）</span></span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口处理函数</span></span><br><span class="line"><span class="comment">// @param hwnd 窗口的句柄</span></span><br><span class="line"><span class="comment">// @param uMsg 消息类型</span></span><br><span class="line"><span class="comment">// @param wParam, lParam 窗口消息的两个附加信息，不同的消息，值是不同的</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 处理窗口摧毁消息</span></span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>); <span class="comment">// 发送退出消息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认的窗口消息处理函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译此段代码，可以看到下面的结果：</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oD1K.png"></p><p>成功创建出窗口了！</p><h2 id="过程解析"><a href="#过程解析" class="headerlink" title="过程解析"></a>过程解析</h2><p>首先是WNDCLASS结构体，示例代码已经大部分标的很清楚了。官网上介绍的比星光探索者探索到的还要详细，<a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winuser/ns-winuser-wndclassa">点击查看官网介绍WNDCLASS窗口类结构体</a>！</p><p>在示例代码中，调用了LoadIcon,LoadCursor来加载图标资源，原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HICON <span class="title">LoadIcon</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,  <span class="comment">// 加载资源的实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpIconName    <span class="comment">// 图标名称字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">HCURSOR <span class="title">LoadCursor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance, <span class="comment">// 加载资源的实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpCursorName <span class="comment">// 加载光标名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>Windows的数据类型，如果以<code>H</code>开头，大多都是…的句柄的意思。</p><p>接下来是<a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindoww">RegisterWindow函数</a>，<a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winuser/nf-winuser-createwindoww">CreateWindow函数</a>，这些都是宏定义，都是根据程序使用的字符集来选择调用哪个版本的。例如CreateWindow如果是多字节字符集，将调用CreateWindowA版本，如果是Unicode字符集，将调用CreateWindowW版本，很多皆是如此。</p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-showwindow">ShowWindow 函数</a>和<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-updatewindow">UpdateWindow 函数</a>参数都很简单。</p><p><strong>(重点内容)</strong> 窗口过程函数，是处理窗口消息的函数。Windows是基于消息系统的，当鼠标点击窗口或键盘输入时，将发送相应消息给窗口。因而窗口过程函数即为重要。窗口过程函数写法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WinProc是窗口处理函数的名称，可以随便改</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WinProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hwnd,     <span class="comment">// 处理消息的窗口句柄 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT uMsg,     <span class="comment">// 窗口消息</span></span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam, <span class="comment">// 窗口消息附带的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam  <span class="comment">// 窗口消息附带的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>此函数的返回值为窗口消息的处理结果，int类型可以转换成HRESULT类型，大多数情况下返回0表示正常处理。</p><p>如果不处理消息，可交给默认的过程函数DefWinProc处理。但是如果不正确处理相关消息，可能会导致窗口关不了，窗口没了进程还在的情况。</p><h2 id="Windows消息机制"><a href="#Windows消息机制" class="headerlink" title="Windows消息机制"></a>Windows消息机制</h2><p>Windows是以消息为基础的操作系统。消息(MSG类型)组成如下：</p><ul><li><p>窗口句柄</p></li><li><p>消息ID</p></li><li><p>消息的两个附带信息</p></li><li><p>消息产生时间</p></li><li><p>消息产生时的鼠标位置</p></li></ul><p><strong>当系统通知窗口工作时，采用消息的方式派发给窗口</strong>。(本段落以下内容引用自微软官网)如果顶级窗口停止响应消息超过几秒钟，系统将认为窗口不会响应。 在这种情况下，系统会隐藏窗口，并将其替换为具有相同 Z 顺序、位置、大小和视觉属性的幽灵窗口。 这样，用户就可以移动它、调整大小，甚至关闭应用程序。 但是，这些操作是唯一可用的操作，因为应用程序实际上没有响应。 在调试器模式下，系统不会生成虚影窗口。</p><p>消息队列，顾名思义就是储存消息的队列，<strong>队列具有先进先出(First in first out, FIFO)</strong> 的特性。操作系统本身就维护有消息队列，每个应用程序也会有他自己的消息队列。</p><p>但是，并不是所有的消息都会进消息队列，有的消息是直接让窗口处理不进消息队列的。因此，根据消息进不进消息队列，我们可将消息分为<strong>队列消息和非队列消息</strong>。</p><ul><li><p>队列消息：消息发送时，首先进入队列，然后通过消息循环，从队列当中获取。常见的队列消息有WM_PAINT，键盘消息，鼠标消息，定时器消息等</p></li><li><p>非队列消息：消息发送时，直接找到消息接收窗口的窗口过程函数，直接调用此函数完成消息。常见的非队列消息有WM_CREATE，WM_SIZE等</p></li></ul><p>上面说的都是常见的队列消息和非队列消息，只要你想让他进队列，他就是队列消息，否则是非队列消息。</p><h2 id="抓取消息的API"><a href="#抓取消息的API" class="headerlink" title="抓取消息的API"></a>抓取消息的API</h2><p> <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessage">GetMessage函数</a>。 上面的消息循环就是用的这个抓取队列中的消息。如果这个函数的最后两个参数都为0，什么消息都抓取。一般不返回非0值。当遇到WM_QUIT消息（使应用程序退出的消息）时，GetMessage将返回FALSE。GetMessage函数是阻塞函数，如果没有消息会一直等待。</p><p>GetMessage函数在工作时，会按顺序执行下列步骤：</p><ul><li><p>在程序（线程）消息队列中查找消息，如果队列有消息，检查是否满足抓取消息的范围，满足就抓取</p></li><li><p>如果程序（线程）消息队列没有消息，向系统队列获取属于本程序的消息，如果有就转发到程序的消息队列。</p></li><li><p>如果还是没有消息，检查当前进程的所有窗口有没有需要重绘的区域，如果发现有需要绘制的区域，产生WM_PAINT消息，然后处理</p></li><li><p>如果没有重绘区域，检查计时器有没有到时的计时器，如果有将产生WM_TIMER消息，然后处理</p></li><li><p>如果没有计时器，就整理程序资源，内存等</p></li><li><p>如果执行到了这一步，GetMessage就会一直等候，直到消息有为止</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPMSG lpMsg,         <span class="comment">// 抓取到消息储存的消息结构体</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HWND  hWnd,          <span class="comment">// 抓取消息的窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT  wMsgFilterMin, <span class="comment">// 抓取消息的最小值</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT  wMsgFilterMax  <span class="comment">// 抓取消息的最大值</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-peekmessagew">PeekMessage函数</a>用于以查看的方式查看队列有没有消息，如果没有消息返回0，否则返回非0值。这个函数的前四个参数与GetMessage函数意义完全相同，第五个参数的意义为如果有消息，如果值为PM_NOREMOVE，将不从消息队列中移除这个消息，如果值为PM_REMOVE，将从消息队列中移除这个消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PeekMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPMSG lpMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND  hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT  wMsgFilterMin,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT  wMsgFilterMax,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT  wRemoveMsg</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="发送消息的API"><a href="#发送消息的API" class="headerlink" title="发送消息的API"></a>发送消息的API</h2><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-sendmessage">SendMessage 函数 </a>用于向指定窗口句柄的窗口发送消息，这种方式发送的消息是不进消息队列的。此函数会一直等待消息处理结果，其返回值即为目标窗口的处理结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">SendMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND   hWnd,   <span class="comment">// 指定的窗口句柄 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT   Msg,    <span class="comment">// 发送的消息类型   </span></span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam, <span class="comment">// 消息附带的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam  <span class="comment">// 消息附带的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-postmessagew">PostMessage函数</a>用于向指定窗口句柄的窗口发送消息，这种方式发送的消息进消息队列。此函数发送完马上返回，不等待消息处理结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PostMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HWND   hWnd,   <span class="comment">// 指定的窗口句柄 </span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT   Msg,    <span class="comment">// 发送的消息类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">  WPARAM wParam, <span class="comment">// 消息附带的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPARAM lParam  <span class="comment">// 消息附带的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>本期到此结束，下期看星光探索者处理常用的消息及自定义消息</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：常用基本数据类型和字符编码</title>
      <link href="/blogs/posts/windows/pd3e66887a323.html"/>
      <url>/blogs/posts/windows/pd3e66887a323.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="常用基本数据类型"><a href="#常用基本数据类型" class="headerlink" title="常用基本数据类型"></a>常用基本数据类型</h2><p>windows定义了很多基本数据类型，常用的有下列等效定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONST const</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VOID void</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> CHAR;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> SHORT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> LONG;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">wchar_t</span> WCHAR;</span><br><span class="line"><span class="keyword">typedef</span> SHORT *PSHORT;  </span><br><span class="line"><span class="keyword">typedef</span> LONG *PLONG;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 字节的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>       DWORD;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>                 BOOL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>       BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>      WORD;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span>               FLOAT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子类型</span></span><br><span class="line"><span class="keyword">typedef</span> WORD                ATOM;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE <span class="comment">// 如果定义了UNICODE宏</span></span></span><br><span class="line"><span class="keyword">typedef</span> WCHAR TCHAR, *PTCHAR;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> CHAR TCHAR, *PTCHAR;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CHAR类型字符串</span></span><br><span class="line"><span class="keyword">typedef</span> CHAR *LPSTR, *PSTR;</span><br><span class="line"><span class="comment">// CONST CHAR类型字符串</span></span><br><span class="line"><span class="keyword">typedef</span> CONST CHAR *LPCSTR, *PCSTR;</span><br><span class="line"><span class="comment">// WCHAR类型字符串</span></span><br><span class="line"><span class="keyword">typedef</span> WCHAR *LPWSTR, *PWSTR;</span><br><span class="line"><span class="comment">// COSNT WCHAR类型字符串</span></span><br><span class="line"><span class="keyword">typedef</span> CONST WCHAR *LPCWSTR, *PCWSTR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TCHAR类型的字符串</span></span><br><span class="line"><span class="keyword">typedef</span> TCHAR *PTSTR, *LPTSTR;</span><br><span class="line"><span class="comment">// CONST TCHAR类型字符串</span></span><br><span class="line"><span class="keyword">typedef</span> CONST TCHAR *PCTSTR, *LPCTSTR;</span><br></pre></td></tr></table></figure><p>这些是主要的类型，各位小伙伴初次看到时都会感到比较难以下手，我们只需要大概了解就可以了，毕竟有文档在，况且我们可以随时查看这些函数的定义。</p><p>这些基本数据类型的定义是有规律的，例如带有<code>P</code>的表明这个类型是指针类型，例如LPSTR(char*), PVOID(void*)，带有<code>STR</code>的表明这是一个字符串，例如PSTR(char*), PTSTR(TCHAR*)，带有<code>C</code>表示具有const属性例如PCWSTR(const wchar_t *)，非常好记。</p><p>还有BOOL定义为int，并不是bool，返回BOOL类型时应该返回TRUE(1)或FALSE(0)</p><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>字符(character)是各位文字和符号的总称，字符集（Character set）是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同，常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、 GB18030字符集、Unicode字符集等。计算机要准确的处理各类字符集，需要进行字符编码。实际上字符都是通过数值表示的。</p><p>下面来探索部分字符集：</p><h3 id="ASCII-字符集"><a href="#ASCII-字符集" class="headerlink" title="ASCII 字符集"></a>ASCII 字符集</h3><p>ASCII (American Standard Code for Information Interchange，美国信息互换标准编码）是基于罗马字母表的一套电脑编码系统，主要用于显示英语和其他西欧语言。ASCII字符集用7位表示一个字符，共128个字符，字符值从0到127，其中32到126是可打印字符。7位编码的字符集只能表示128个字符，为了表示更多的字符，ASCII扩展字符集使用8位（bits）表示一个字符，共256字符。</p><h3 id="GB2313字符集"><a href="#GB2313字符集" class="headerlink" title="GB2313字符集"></a>GB2313字符集</h3><p>GB2312又称为GB2312-80字符集，全称为《信息交换用汉字编码字符集·基本集》，由原中国国家标准总局发布，1981年5月1日实施。是中国国家标准的简体中文字符集，他收录的汉字已经覆盖99.75%的使用评率，基本满足了汉字的计算机处理需要。</p><h3 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h3><p>Unicode字符集是Universal Multiple-Octet Coded Character Set 通用多八位编码字符集的简称，支持现今世界各种不同语言的书面文本的交换、处理及显示。</p><p>因此Win32程序使用不同的字符集，将调用不同的API函数。</p><p>下列代码展示如何处理各种字符集的打印方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印多字节字符集使用这个\n&quot;</span>);</span><br><span class="line">    <span class="built_in">wprintf</span>(<span class="string">L&quot;%ls\n&quot;</span>, <span class="string">L&quot;打印Unicode字符集使用这个&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行这段代码，看到printf正常打印，wprintf打印不出正确内容的运行结果(各位可以尝试一下，wprintf打印宽字符集，也就是Unicode字符，目前大多都是不成功的)</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oBp6.png"></p><p>为什么会这样呢？因为wprintf目前对Unicode的支持还不是很好，为了能正常打印，在Windows我们可以使用<a href="https://learn.microsoft.com/zh-cn/windows/console/writeconsole">WriteConsole函数</a>，看下列代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">wchar_t</span> content[] = <span class="string">L&quot;打印Unicode字符集的解决方案&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得标准输出句柄 STD_OUTPUT_HANDLE</span></span><br><span class="line">    <span class="comment">// 还可以获得标准输入句柄，标准错误句柄等</span></span><br><span class="line">    <span class="comment">// HANDLE是句柄类型</span></span><br><span class="line">    HANDLE hOut = <span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制台输出信息</span></span><br><span class="line">    <span class="built_in">WriteConsole</span>(hOut, content, <span class="built_in">wcslen</span>(content), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于TCHAR类型的字符串，计算长度因使用lstrlen</span></span><br><span class="line">    TCHAR szText = <span class="built_in">TEXT</span>(<span class="string">&quot;好！&quot;</span>);</span><br><span class="line">    <span class="built_in">WriteConsole</span>(hOut, szText, <span class="built_in">lstrlen</span>(szText), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一编译，可以看到程序正确打印，非常好。</p><p><a href="https://learn.microsoft.com/zh-cn/windows/console/writeconsole">点我查看WriteConsole函数有关信息</a></p><p>本期到此结束，下期看星光探索者探索Windows如何创建自己的窗口和探索消息机制</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Windows：第一个Win32程序</title>
      <link href="/blogs/posts/windows/p83a7b5481c29.html"/>
      <url>/blogs/posts/windows/p83a7b5481c29.html</url>
      
        <content type="html"><![CDATA[<p>让我们与星光探索者一起，探索Windows吧!</p><h2 id="探索Windows程序类型"><a href="#探索Windows程序类型" class="headerlink" title="探索Windows程序类型"></a>探索Windows程序类型</h2><p>我们可以给Windows程序分类</p><ul><li><p>控制台程序Console</p><p>DOS程序，本身没有窗口，通过Windows DOS窗口执行。</p><p>在Windows通常为.exe文件，控制台程序的入口为main函数</p></li><li><p>窗口程序</p><p>拥有自己的窗口，可以和用户交互</p><p>通常为.exe文件，情况下窗口程序的入口为WinMain函数</p></li><li><p>库程序</p><p>存放代码，数据的程序，执行文件可以从中取出代码执行和获取数据</p><ul><li><p>静态库程序：拓展名.lib。在链接阶段将代码放入可执行文件中，无入口函数</p></li><li><p>动态库程序：拓展名.dll。在执行文件中执行时从中获得代码，入口函数为DllMain</p></li></ul></li></ul><h2 id="编译工具"><a href="#编译工具" class="headerlink" title="编译工具"></a>编译工具</h2><p>通常编写Win32程序应该使用微软的工具，毕竟Windows是微软的。</p><p>下面让我们一起探索Visual C++的编译工具吧！</p><p>编译器cl.exe：将源代码(.c或.cpp)编译成目标代码.obj</p><p>链接器link.exe：将目标代码，资源，库等链接，生成最终文件</p><p>资源编译器rc.exe：将资源文件(.rc)将资源编译成.res文件，最终通过链接器写入最终文件</p><p>如果你安装了Visual Studio，那么这些编译工具的路径可能为：</p><p>C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.34.31931\bin\Hostx64\x64\</p><h2 id="Windows库和头文件"><a href="#Windows库和头文件" class="headerlink" title="Windows库和头文件"></a>Windows库和头文件</h2><p>下面只是列举部分库和对应的头文件，并不是全部内容</p><ul><li><p>kernel32.dll 提供了核心的API，如进程，线程，内存管理</p></li><li><p>user32.dll 提供了窗口，消息等用户常用的API</p></li><li><p>gdi32.dll 绘图相关的API</p></li></ul><p>路径： C:\Windows\System32\</p><p>Windows的头文件</p><ul><li><p>windows.h 大部分Windows头文件的集合，包含了下列提到的头文件等文件</p></li><li><p>windef.h windows基本数据类型定义</p></li><li><p>winbase.h kernel32.dll 的API</p></li><li><p>wingdi.h gdi32.dll的API</p></li><li><p>winuser.h user32.dll的API</p></li><li><p>winnt.h UNICODE字符集的支持</p></li></ul><p>路径：C:\Program Files\Microsoft Visual Studio\2022\Preview\VC\Tools\MSVC\14.34.31931\include</p><h2 id="第一个Win32程序"><a href="#第一个Win32程序" class="headerlink" title="第一个Win32程序"></a>第一个Win32程序</h2><p>首先先新建一个文件夹，并创建test.cpp源代码文件，在test.cpp文件书写这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">INT WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,      <span class="comment">// 当前实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,  <span class="comment">// 上一个实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,          <span class="comment">// 运行程序的命令行</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow              <span class="comment">// 程序最初显示方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;探索Windows!&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;星光探索者&quot;</span>), MB_OK);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>星光探索者非常喜欢探索，于是星光探索者在命令行调用Visual C++编译工具，输入了像这样的命令行<code>cl test.cpp</code>就可以编译这个Win32程序了。如果有的小伙伴提示错误信息unresolved symbol无法解析的外部符号，那么就需要手动链接相关的库了。MessageBox函数属于user32.dll，因此我们需要使用link指令：<code>cl test.cpp /link user32.lib</code></p><p>当然用MinGW也是可以的，只不过需要加上<code>-mwindows</code>参数，要不然MinGW不会认为是编译Win32程序，而是认为是控制台程序</p><p>运行这个程序，可以看到显示了一个消息框。</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8osXD.png"></p><h2 id="深入探索"><a href="#深入探索" class="headerlink" title="深入探索"></a>深入探索</h2><p>WinMain函数的结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INT WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,      <span class="comment">// 当前实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,  <span class="comment">// 上一个实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,          <span class="comment">// 运行程序的命令行</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> nCmdShow              <span class="comment">// 程序最初显示方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>hInstance</code> 为当前实例句柄。在Windows句柄的概念的随处可见</p></li><li><p><code>hPrevInstance</code> 为上一个实例句柄。他在16位Windows系统使用，现在不使用，值总是为NULL(定义为0)</p></li><li><p><code>pCmdLine</code> 包含命令行参数的字符串。如果需要获取整个命令行，请使用<code>GetCommandLine</code></p></li><li><p><code>nCmdShow</code> 窗口的最初显示方式（最小化，正常，最大化）</p></li></ul><p>这个函数返回INT(定义为int)类型的值，操作系统不使用返回值，但可以传递给其他程序</p><p>WINAPI是Windows的函数调用约定，定义为__stdcall，使用<code>APIENTRY</code>也是相同的结果</p><p>上面那个简易的程序还调用了MessageBox函数，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageBox</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HWND hWnd,          <span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpText,     <span class="comment">//弹窗内容</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpCaption,  <span class="comment">//弹窗标题</span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT uType          <span class="comment">//弹窗类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>hWnd</code> 为显示消息框的窗口句柄，也就是消息框的父窗口，如果没有父窗口就传NULL，关于窗口的更多信息下期星光探索者继续探索。 HWND类型为handle of the windows的意思。</p></li><li><p><code>lpText</code> 是一个TCHAR类型的字符串，为消息框的内容</p><p>TCHAR是windows基本数据类型，是宏定义。如果使用多字节字符集的项目，TCHAR被定义为char；如果使用Unicode字符集的项目，TCHAR被定义为wchar_t。类型<code>LPCTSTR</code>为<code>const TCHAR*</code>，在下一期会深入探索。</p></li><li><p><code>lpCaption</code>是一个TCHAR类型的字符串，为消息框的标题内容</p></li><li><p><code>uType</code>为消息框的显示按钮及消息框标题栏的图标，默认显示一个确定(OK)按钮。这个函数的返回值即为用户按下的按钮。</p><p>可选择的部分样式如下，消息框显示的按钮文本取决于系统的语言，想知道更多信息<a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winuser/nf-winuser-messagebox">请点击我！</a>：</p><p>消息框的按钮：</p><table><thead><tr><th>按钮样式</th><th>效果</th></tr></thead><tbody><tr><td>MB_OK</td><td>消息框包含一个按钮确定，这是默认值</td></tr><tr><td>MB_OKCANCEL</td><td>消息框包含两个按钮，确定取消</td></tr><tr><td>MB_YESNO</td><td>消息框包含两个按钮，是和否</td></tr><tr><td>MB_RETRYCANCEL</td><td>消息框包含两个按钮，重试或取消</td></tr></tbody></table><p> 消息框的图标：</p><table><thead><tr><th>图标样式</th><th>效果</th></tr></thead><tbody><tr><td>MB_ICONWARNING</td><td>消息框中会显示一个感叹号图标</td></tr><tr><td>MB_ICONINFORMATION</td><td>消息框会有一个圆圈，圆圈中间写着小写字母 i(意思为infomation，信息的意思)</td></tr><tr><td>MB_ICONQUESTION</td><td>消息框会显示一个问号图标</td></tr></tbody></table><p>默认选中的按钮</p><table><thead><tr><th>默认选中的按钮</th><th>效果</th></tr></thead><tbody><tr><td>MB_DEFBUTTON1</td><td>选中第一个按钮（默认值）</td></tr><tr><td>MB_DEFBUTTON2</td><td>选中第二个按钮</td></tr><tr><td>MB_DEFBUTTON3</td><td>选中第三个按钮</td></tr><tr><td>MB_DEFBUTTON4</td><td>选中第四个按钮</td></tr></tbody></table><p>等很多功能，但都是以MB_开头，可根据字面意思猜测功能。</p></li></ul><p>MessageBox的返回值为点击的按钮,都是以ID开头。例如IDOK(确认按钮)，IDCANCEL(取消按钮)</p><p>使用案例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (MBCANCEL != <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;是否重试?&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;Error&quot;</span>), MB_YSENO))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 如果消息框想用多个效果，使用 | 运算符</span></span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, </span><br><span class="line">                   <span class="built_in">TEXT</span>(<span class="string">&quot;正在重试&quot;</span>), </span><br><span class="line">                   <span class="built_in">TEXT</span>(<span class="string">&quot;fixing&quot;</span>), </span><br><span class="line">                   MB_OK | MB_ICONINFOMATION | MB_DEFBUTTON1</span><br><span class="line">    );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个TEXT是windows提供的一个宏函数，会根据当前使用的字符集将”…”这样的字符串转换成TCHAR类型的字符串。因为Windows的API要根据不同的字符集调不同的函数，对于要调API的字符串我们可以用TEXT宏来包裹</p><p>定义的效果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE  <span class="comment">// 如果使用UNICODE字符集</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXT(quote) L##quote</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXT(quote) quote</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>刚才上文提到了项目使用的字符集，那个在哪里设置呢？</p><p>打开解决方案管理器(Solution Explorer)</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8o6ne.png"></p><p>对准你要设置字符集的项目按<strong>鼠标右键</strong>，看到菜单，然后点击 <strong>属性(Properties)</strong></p><p><img src="https://s1.ax1x.com/2023/01/20/pS8owfx.png"></p><p>然后选择字符集(Character Set)，在这里就可以设置你项目使用的字符集了。</p><p><img src="https://s1.ax1x.com/2023/01/20/pS8oakR.png"></p><p>本期到此结束，下期看星光探索者探索Windows常用基本数据类型和字符编码</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> programming </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
