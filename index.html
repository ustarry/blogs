<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>星光工作室</title><meta name="author" content="星光探索者"><meta name="copyright" content="星光探索者"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="星光不负缘，梦想终将圆.星光工作室热衷于为迷你世界社区做贡献,做更多优质地图.星光工作室积累了丰富的管理和文创经验,地图玩法制作及编程技术探讨环境">
<meta property="og:type" content="website">
<meta property="og:title" content="星光工作室">
<meta property="og:url" content="http://ustarry.github.io/blogs/index.html">
<meta property="og:site_name" content="星光工作室">
<meta property="og:description" content="星光不负缘，梦想终将圆.星光工作室热衷于为迷你世界社区做贡献,做更多优质地图.星光工作室积累了丰富的管理和文创经验,地图玩法制作及编程技术探讨环境">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ustarry.github.io/image/starlight_avator.png">
<meta property="article:author" content="星光探索者">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ustarry.github.io/image/starlight_avator.png"><link rel="shortcut icon" href="https://ustarry.github.io/image/starlight_avator.png"><link rel="canonical" href="http://ustarry.github.io/blogs/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blogs/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/blogs/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '星光工作室',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2023-08-19 19:36:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://ustarry.github.io/image/starlight_avator.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/blogs/archives/"><div class="headline">Articles</div><div class="length-num">18</div></a><a href="/blogs/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/blogs/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blogs/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/blogs/archives/"><i class="fa-fw fas fa-archive"></i><span> 成就</span></a></div><div class="menus_item"><a class="site-page" href="/blogs/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blogs/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="https://ustarry.github.io/about.html"><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('https://s1.ax1x.com/2023/01/12/pSuJ4Wn.jpg')"><nav id="nav"><span id="blog-info"><a href="/blogs/" title="星光工作室"><span class="site-name">星光工作室</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blogs/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/blogs/archives/"><i class="fa-fw fas fa-archive"></i><span> 成就</span></a></div><div class="menus_item"><a class="site-page" href="/blogs/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blogs/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="https://ustarry.github.io/about.html"><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">星光工作室</h1><div id="site_social_icons"><a class="social-icon" href="https://github.com/ustarry" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left"><a href="/blogs/posts/windows/pd2a35742938d.html" title="探索Windows：Windows内存结构体系"><img class="post-bg" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：Windows内存结构体系"></a></div><div class="recent-post-info"><a class="article-title" href="/blogs/posts/windows/pd2a35742938d.html" title="探索Windows：Windows内存结构体系">探索Windows：Windows内存结构体系</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2023-04-22T00:57:05.000Z" title="Created 2023-04-22 08:57:05">2023-04-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/blogs/categories/windows/">windows</a></span></div><div class="content">让我们与星光探索者一起，探索Windows吧!
</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/blogs/posts/windows/pf26a423cf526.html" title="探索Windows：同步设备IO与异步设备IO"><img class="post-bg" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：同步设备IO与异步设备IO"></a></div><div class="recent-post-info"><a class="article-title" href="/blogs/posts/windows/pf26a423cf526.html" title="探索Windows：同步设备IO与异步设备IO">探索Windows：同步设备IO与异步设备IO</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2023-04-22T00:57:02.000Z" title="Created 2023-04-22 08:57:02">2023-04-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/blogs/categories/windows/">windows</a></span></div><div class="content">让我们与星光探索者一起，探索Windows吧!
线程是我们最好的工具，可以用来对工作进行划分。然而当线程发出一个异步设备I&#x2F;O请求时，他被临时挂起，知道设备完成I&#x2F;O请求为止。此类挂起会损害性能。为了不让线程闲下来，我们需要让各个线程就他们正在执行的操作相互通信。Microsoft开发出了一个非常好的机制进行这类通信–I&#x2F;O完成端口(I&#x2F;O completion port)他可以帮助我们创建高性能而且伸缩性好的应用程序。通过使用I&#x2F;O完成端口，我们可以让线程在读取设备和写入设备时不必等待设备的响应，从而显著提高吞吐量。
打开和关闭设备以下为常见的可称为设备的东西，一般设备使用CreateFile打开，CloseHandle关闭。这些函数都返回一个标识设备的句柄，我们可以将句柄传给许多函数与设备进行通信，如调用SetCommConfig设置串口的波特率，SetMailslotInfo在等待读取数据时，设置超时值。如果我们想知道设备的类型，可通过调用GetFileType函数获得



设备
常见用途



文件
永久储存任何数据


目录 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/blogs/posts/windows/p8acaa0787154.html" title="探索Windows：线程同步"><img class="post-bg" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：线程同步"></a></div><div class="recent-post-info"><a class="article-title" href="/blogs/posts/windows/p8acaa0787154.html" title="探索Windows：线程同步">探索Windows：线程同步</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2023-04-22T00:57:00.000Z" title="Created 2023-04-22 08:57:00">2023-04-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/blogs/categories/windows/">windows</a></span></div><div class="content">让我们与星光探索者一起，探索Windows吧!
通常，线程之间需要进行通信，而通信时很可能就会导致数据混乱的现象。就好比一个人正在读书时，另一个人正在修改书中文字。这样书的内容将乱七八糟。对于多个线程同时访问一个共享资源，或一个线程需要通知其他线程某任务已经完成时，需要用到线程同步。Microsoft已提供了很多基础设施，使得线程同步很容易。
用户模式下的线程同步我们可以有多种方式实现线程同步
使用原子锁线程同步的一大部分与原子访问有关(atomic access)有关。看如下代码
1234567891011121314151617181920long g_x = 0;DWORD WINAPI Work1(PVOID)&#123;    for (int i = 0; i &lt; 100; ++i)    &#123;        g_x++;    &#125;    return 0;&#125;DWORD WINAPI Work2(PVOID)&#123;    for (int i = 0; i &lt; 100; ++i)    &#123;        g_x++;  ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/blogs/posts/windows/pbdbc280bfc62.html" title="探索Windows：探索Windows内核对象线程"><img class="post-bg" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：探索Windows内核对象线程"></a></div><div class="recent-post-info"><a class="article-title" href="/blogs/posts/windows/pbdbc280bfc62.html" title="探索Windows：探索Windows内核对象线程">探索Windows：探索Windows内核对象线程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2023-04-22T00:12:00.000Z" title="Created 2023-04-22 08:12:00">2023-04-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/blogs/categories/windows/">windows</a></span></div><div class="content">让我们与星光探索者一起，探索Windows吧!
线程的创建时机之前的探索过程中，我们知道，每个进程至少都有一个线程。进程有两个组成部分：一个进程内核对象和一个地址空间。类似地，线程也有两个组成成分

线程内核对象：操作系统用它管理线程

线程栈：用于维护线程执行时所需的所有函数参数和局部变量


进程是有惰性的，进程从来不执行任何东西，他只是一个线程的容器。线程共享同一个地址空间，执行同样代码，处理相同数据，此外，这些线程还共享对象句柄。
因此，进程相对于线程使用的系统资源更多。原因在于为一个进程创建一个虚拟的地址空间需要大量系统资源，系统发生大量记录活动，占用大量内存。线程几乎不涉及记录活动，所以不需要占用多少内存。
每个计算机都有强大的资源CPU。让CPU闲着是没有任何道理的（假设不考虑省电和散热等问题）。为了让CPU保持“忙碌”，我们可以让他执行多个任务。下面有多个案例：

Windows Indexing Services(Windows索引服务)创建了一个低优先级的线程，此线程定期醒来，并对硬盘上的特定资源的文件内容进行索引，这极大改进了性能。

只要暂停输入，Microso ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/blogs/posts/windows/p88fd15a5c690.html" title="探索Windows：探索Windows内核对象作业"><img class="post-bg" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：探索Windows内核对象作业"></a></div><div class="recent-post-info"><a class="article-title" href="/blogs/posts/windows/p88fd15a5c690.html" title="探索Windows：探索Windows内核对象作业">探索Windows：探索Windows内核对象作业</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2023-04-05T00:11:00.000Z" title="Created 2023-04-05 08:11:00">2023-04-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/blogs/categories/windows/">windows</a></span></div><div class="content">让我们与星光探索者一起，探索Windows吧!
内核对象作业Job在Visual Studio中，我们有时候想在编译文件中途终止编译，调试程序中途终止调试，Visual Studio是怎么做的呢？虽然这是一个简单而常见的问题，但windows没有维护线程之间的父子关系，解决起来非常难。
Windows提供了一个作业(job)内核对象,它允许你将进程组合在一起并创建一个”沙箱”来限制进程能够做什么.最好将作业对象想象成一个进程容器.但是,即使作业中只包含一个进程,也是非常有用的,因为这样可以对进程施加平时不能施加的限制.点我查看微软官方对于作业对象的介绍
下面的程序代码，将尝试将一个进程放到一个作业中
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#incl ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/blogs/posts/windows/pbce90bc36ce8.html" title="探索Windows：探索Windows内核对象进程 (2)"><img class="post-bg" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：探索Windows内核对象进程 (2)"></a></div><div class="recent-post-info"><a class="article-title" href="/blogs/posts/windows/pbce90bc36ce8.html" title="探索Windows：探索Windows内核对象进程 (2)">探索Windows：探索Windows内核对象进程 (2)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2023-04-05T00:10:05.000Z" title="Created 2023-04-05 08:10:05">2023-04-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/blogs/categories/windows/">windows</a></span></div><div class="content">让我们与星光探索者一起，探索Windows吧!
再探CreateProcess函数我们用CreateProcess函数创建一个进程，CreateProcess函数的原型如下
1234567891011121314BOOL CreateProcess(    LPCTSTR                lpApplicationName,    // 应用程序名称    LPTSTR                 lpCommandLine,        // 命令行参数    LPSECURITY_ATTRIBUTES lpProcessAttributes,   // 默认进程的安全属性，可传NULL    LPSECURITY_ATTRIBUTES lpThreadAttributes,    // 默认进程的安全属性，可传NULL    BOOL                  bInheritHandles,       // 当前进程内核对象能否被子进程继承    DWORD                 dwCreationFlags,       // 创建进程 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/blogs/posts/windows/pf1b6fecfeb59.html" title="探索Windows：探索Windows内核对象进程"><img class="post-bg" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：探索Windows内核对象进程"></a></div><div class="recent-post-info"><a class="article-title" href="/blogs/posts/windows/pf1b6fecfeb59.html" title="探索Windows：探索Windows内核对象进程">探索Windows：探索Windows内核对象进程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2023-04-05T00:10:00.000Z" title="Created 2023-04-05 08:10:00">2023-04-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/blogs/categories/windows/">windows</a></span></div><div class="content">让我们与星光探索者一起，探索Windows吧!
再次探索Windows应用程序进程由以下两部分构成：

一个内核对象，操作系统用于管理进程

一个地址空间，包含所有可执行文件或DLL模块的代码和数据，以及动态内存分配。


进程是有惰性的，进程要做的事情，必须让一个线程在他的上下文中运行，该线程负责执行进程空间包含的代码。一个进程可以有多个线程，所有线程都在进程的地址空间“同时”执行代码。为此，每个线程都有他自己的一组CPU寄存器和它自己的堆栈，每个进程至少有一个线程执行进程地址空间包含的代码。当系统创建一个进程的时候，会自动为进程创建第一个线程，这即为主线程(main thread)。 如果没有线程要执行进程地址空间包含的代码，进程失去了继续存在的理由，这是系统就会自动销毁进程及其地址空间。
对于所有要运行的线程，操作系统会轮流给每个线程调度一些CPU时间，采用循环（round-robin，轮询或轮流）方式，为每个线程分配时间片（quantum，称为“量”或“量程”），从而营造出所有线程都在同时运行的假象。 如果计算机配备了多个CPU，操作系统会采用更复杂的算法为线程分配CPU时间， ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/blogs/posts/windows/p19349a29417d.html" title="探索Windows：Windows内核对象初步探讨"><img class="post-bg" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：Windows内核对象初步探讨"></a></div><div class="recent-post-info"><a class="article-title" href="/blogs/posts/windows/p19349a29417d.html" title="探索Windows：Windows内核对象初步探讨">探索Windows：Windows内核对象初步探讨</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2023-04-04T01:20:00.000Z" title="Created 2023-04-04 09:20:00">2023-04-04</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/blogs/categories/windows/">windows</a></span></div><div class="content">让我们与星光探索者一起，探索Windows吧!
Windows内核对象初步认识Windows中有很多像访问令牌(access token)对象、事件(event)对象、进程(process)对象、线程(thread)对象、文件(file)对象、文件映射（filemapping)、可等待计时器（waitable timer)对象等等这样的对象，我们称之为Windows内核对象。内核对象是系统地址空间中的一个内存块，由系统创建并维护，这个内存对象是一个数据结构，维护着与对象相关的信息。微软提供了一些可以操作内核对象的API，可以使我们以适当的方式操作内核对象。关于内核对象的参考内容。
内核对象的所有者是操作系统，而非进程。如果我们的进程创建了一个内核对象，我们的进程终止之后，内核对象不一定被销毁， 因为可能别的进程使用我们的内核对象（如在下文中提到子进程继承父进程内核对象句柄，此时父进程终止之后，内核对象不一定被销毁）。
操作系统当然知道有多少进程使用同一个内核对象，因为每个内核对象都有一个叫引用计数(usage count)的共有数据成员。 初次创建一个内核对象时，他的引用计数为1，当一 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/blogs/posts/windows/pc190bf13eb0d.html" title="探索Windows：Windows错误处理和字符串处理"><img class="post-bg" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：Windows错误处理和字符串处理"></a></div><div class="recent-post-info"><a class="article-title" href="/blogs/posts/windows/pc190bf13eb0d.html" title="探索Windows：Windows错误处理和字符串处理">探索Windows：Windows错误处理和字符串处理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2023-04-04T01:15:00.000Z" title="Created 2023-04-04 09:15:00">2023-04-04</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/blogs/categories/windows/">windows</a></span></div><div class="content">让我们与星光探索者一起，探索Windows吧!
Windows错误处理在Windows API 调用时，Windows会验证我们传入的参数是否有效，然后才会执行任务。下表为Windows大部分API函数返回值的意义。



返回值类型
返回值意义



VOID
此函数不会调用失败，但只有极少数 Windows函数返回值类型为 VOID


BOOL
如果函数失败返回0，否则返回一个非零值。因此在判断API是否调用成功时，不应该判断返回值是否为 TRUE，而是判读是否为FALSE


HANDLE
如果函数调用失败，返回NULL或INVALID_HANDLE_VALUE，这取决于文档说明。否则返回一个可以操纵的对象


PVOID
失败返回NULL，否则返回一块内存地址


Windows API是通过返回值来表明函数的调用成功情况的。当Windows返回错误代码时，我们就可以知道为什么函数调用失败。当Widnows检测到错误时，他会使用线程本地存储区(thread-local storage)的机制将发出调用的线程(calling thread)关联在一起，这种机制使得我们在不同的线 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/blogs/posts/cplusplus/p46f9f8da9911.html" title="C++面向对象知识点总结"><img class="post-bg" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="C++面向对象知识点总结"></a></div><div class="recent-post-info"><a class="article-title" href="/blogs/posts/cplusplus/p46f9f8da9911.html" title="C++面向对象知识点总结">C++面向对象知识点总结</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2023-02-26T00:57:00.000Z" title="Created 2023-02-26 08:57:00">2023-02-26</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/blogs/categories/cplusplus/">cplusplus</a></span></div><div class="content">本文记录了C++面向对象的相关知识点。
面向对象初识何为面向对象面向过程(Procedure Oriented)：在解决一个问题时，将过程拆分为解决事情的步骤，然后按一定的顺序执行这些步骤，然后解决问题。优点是性能相对面向对象高，因为对象需要构建，开销比较大。缺点是不易维护。
面向对象(Object Oriented)：在解决一个问题时，面向对象会将事物抽象成对象的概念，看此问题有哪些对象，这些对象会有什么行为，什么属性，让每个对象执行自己的行为，然后解决问题。优点是易维护易复用易拓展，缺点是性能比面向过程低，但也不会非常低。对象的行为和属性称为对象的成员。
什么是对象，例如人，手机，是对象什么是行为，例如走路，跑步，转身什么是属性，例如人的年龄，手机的电量，人的身高
具有相同行为，属性的对象组成的集合叫做类。

参考案例：用圆规画圆面向过程：拿出圆规，修改圆规半径，旋转圆规，结束面向对象：圆规创建，圆规.调整自身大小行为，圆规.旋转行为，结束。


参考案例：洗衣服面向过程：把衣服放入洗衣机，设置洗衣时间，设置洗衣模式，开启洗衣机，结束面向对象：构造圆规，洗衣机.放入衣服， 洗衣机. ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/blogs/posts/psychology/p951ad8dc218a.html" title="星光心灵 - 如何安慰他人"><img class="post-bg" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="星光心灵 - 如何安慰他人"></a></div><div class="recent-post-info"><a class="article-title" href="/blogs/posts/psychology/p951ad8dc218a.html" title="星光心灵 - 如何安慰他人">星光心灵 - 如何安慰他人</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2023-02-18T23:55:00.000Z" title="Created 2023-02-19 07:55:00">2023-02-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/blogs/categories/psychology/">psychology</a></span></div><div class="content">Life is like a wave, which will go up and down. We cannot avoid suffering. Thus, we all need others’ comfort. The following informations show the useful tips to comfort people.
人生就像波浪，会起起落落。我们无法避免痛苦。因此，我们都需要别人的安慰。以下信息显示了安慰人们的有用技巧。
Better not to…
最好不要…

Tell him or her that your situation is worse 跟他比惨When someone turns to you, it is clear he or she wants your comfort. Telling “Mine is worse” always means “I can afford the worse situation than yours. So why can’t you?”. Although our thoughts are  ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/blogs/posts/psychology/p320b63238c75.html" title="星光心灵 - 倾听是否重要"><img class="post-bg" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="星光心灵 - 倾听是否重要"></a></div><div class="recent-post-info"><a class="article-title" href="/blogs/posts/psychology/p320b63238c75.html" title="星光心灵 - 倾听是否重要">星光心灵 - 倾听是否重要</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2023-02-18T23:55:00.000Z" title="Created 2023-02-19 07:55:00">2023-02-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/blogs/categories/psychology/">psychology</a></span></div><div class="content">We all like to tell our thoughts to others when in an informal conversation. As you can see, sometimes someone has not ended up talking, others can’t help cutting in. Who masters speaking is welcomed, but a man who is good at listening is also attractive.
我们都喜欢在非正式对话中向他人讲述我们的想法。如你所见，有时有人没有结束说话，其他人会忍不住插话。谁精通说话是受欢迎的，但善于倾听的人也很有吸引力。
In he occasion when a man listens to you, you will feel like you are respected, trusted, not ignored. It is the man who understands you! He does still listen to your wor ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/blogs/posts/windows/pff3fd6e98f0e.html" title="探索Windows：探索绘图编程和对话框"><img class="post-bg" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：探索绘图编程和对话框"></a></div><div class="recent-post-info"><a class="article-title" href="/blogs/posts/windows/pff3fd6e98f0e.html" title="探索Windows：探索绘图编程和对话框">探索Windows：探索绘图编程和对话框</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2023-02-12T01:10:00.000Z" title="Created 2023-02-12 09:10:00">2023-02-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/blogs/categories/windows/">windows</a></span></div><div class="content">让我们与星光探索者一起，探索Windows吧!
探索绘图编程GDI,Graphic Device Interface，Windows提供了大量API供我们绘制各种各样的图形。
Windows每个窗口都是绘制出来的，当窗口需要绘制的时候，产生WM_PAINT消息，进而我们可以绘制窗口。
HDC，即为设备上下文句柄，DC是设备windows特有的一个概念，我们需要使用他来绘图。
下面是简单的绘图代码：
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#define _CRT_SECURE_NO_WARNINGS#include &quot;MyWindowApplication/resource.h&quot;#include &lt;windows.h&gt;#pragma comment(lib, &quot;user32.lib&quot ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/blogs/posts/windows/p71040f0575db.html" title="探索Windows：使用计时器和菜单，图标，光标等资源文件"><img class="post-bg" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：使用计时器和菜单，图标，光标等资源文件"></a></div><div class="recent-post-info"><a class="article-title" href="/blogs/posts/windows/p71040f0575db.html" title="探索Windows：使用计时器和菜单，图标，光标等资源文件">探索Windows：使用计时器和菜单，图标，光标等资源文件</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2023-02-12T01:05:00.000Z" title="Created 2023-02-12 09:05:00">2023-02-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/blogs/categories/windows/">windows</a></span></div><div class="content">让我们与星光探索者一起，探索Windows吧!
使用计时器计时器是Windows的一种资源。定时器每隔一段时间，会产生WM_TIMER消息 。WM_TIMER附带的两个信息wParam, lParam分别是计时器的id, 计时器到点的处理函数。定时器的精度是毫秒，但是准确度不好。也就是说如果设置间隔1000ms，不一定会在1000ms后刚好产生消息。但是误差不会这么大，最多也就几毫秒。
要使用计时器，需要用SetTimer函数创建定时器。SetTimer的定义如下：
123456UINT_PTR SetTimer(    HWND      hWnd,       // 计时器关联的窗口句柄    UINT_PTR  nIDEvent,   // 计时器的ID，自己随意定，但不能为0    UINT      uElapse,    // 计时器的间隔，单位毫秒    TIMERPROC lpTimerFunc // 计时器到点的处理函数);

这个函数返回创建的计时器ID，如果创建失败了返回0。如果lpTimerFunc传的是NULL，计时器的时间到了，就将发送WM_TIMER消息通 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/blogs/posts/windows/p8cad54b0e5bf.html" title="探索Windows：处理常用的消息和自定义消息"><img class="post-bg" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：处理常用的消息和自定义消息"></a></div><div class="recent-post-info"><a class="article-title" href="/blogs/posts/windows/p8cad54b0e5bf.html" title="探索Windows：处理常用的消息和自定义消息">探索Windows：处理常用的消息和自定义消息</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2023-02-12T01:02:00.000Z" title="Created 2023-02-12 09:02:00">2023-02-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/blogs/categories/windows/">windows</a></span></div><div class="content">让我们与星光探索者一起，探索Windows吧!
下发假设您自己的窗口类的窗口过程函数均为WndProc，且您正确的按流程写了自定义的窗口程序
下方均是提供的一种处理方式的代码，并不是必须要这么做。
处理WM_CLOSE消息WM_CLOSE消息在窗口即将终止时产生。
此消息附带的两个信息

wParam 未使用

lParam 未使用


处理窗口过程函数一个例子如下：
12345678910111213LRESULT CALLBACK WinProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)&#123;    switch (uMsg)    &#123;    case WM_CLOSE:        // 应调用此函数，这样会发送WM_QUIT消息        // 使GetMessage返回0，这样进程才会正确退出        PostQuitMessage(0);          // 不要让默认处理函数处理，否则可能会出错        return 0;    &#125;    return DefWi ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/blogs/page/2/#content-inner">2</a><a class="extend next" rel="next" href="/blogs/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://ustarry.github.io/image/starlight_avator.png" onerror="this.onerror=null;this.src='/blogs/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">星光探索者</div><div class="author-info__description">星光不负缘，梦想终将圆.星光工作室热衷于为迷你世界社区做贡献,做更多优质地图.星光工作室积累了丰富的管理和文创经验,地图玩法制作及编程技术探讨环境</div></div><div class="card-info-data site-data is-center"><a href="/blogs/archives/"><div class="headline">Articles</div><div class="length-num">18</div></a><a href="/blogs/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/blogs/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ustarry" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blogs/posts/windows/pd2a35742938d.html" title="探索Windows：Windows内存结构体系"><img src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：Windows内存结构体系"/></a><div class="content"><a class="title" href="/blogs/posts/windows/pd2a35742938d.html" title="探索Windows：Windows内存结构体系">探索Windows：Windows内存结构体系</a><time datetime="2023-04-22T00:57:05.000Z" title="Created 2023-04-22 08:57:05">2023-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blogs/posts/windows/pf26a423cf526.html" title="探索Windows：同步设备IO与异步设备IO"><img src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：同步设备IO与异步设备IO"/></a><div class="content"><a class="title" href="/blogs/posts/windows/pf26a423cf526.html" title="探索Windows：同步设备IO与异步设备IO">探索Windows：同步设备IO与异步设备IO</a><time datetime="2023-04-22T00:57:02.000Z" title="Created 2023-04-22 08:57:02">2023-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blogs/posts/windows/p8acaa0787154.html" title="探索Windows：线程同步"><img src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：线程同步"/></a><div class="content"><a class="title" href="/blogs/posts/windows/p8acaa0787154.html" title="探索Windows：线程同步">探索Windows：线程同步</a><time datetime="2023-04-22T00:57:00.000Z" title="Created 2023-04-22 08:57:00">2023-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blogs/posts/windows/pbdbc280bfc62.html" title="探索Windows：探索Windows内核对象线程"><img src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：探索Windows内核对象线程"/></a><div class="content"><a class="title" href="/blogs/posts/windows/pbdbc280bfc62.html" title="探索Windows：探索Windows内核对象线程">探索Windows：探索Windows内核对象线程</a><time datetime="2023-04-22T00:12:00.000Z" title="Created 2023-04-22 08:12:00">2023-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blogs/posts/windows/p88fd15a5c690.html" title="探索Windows：探索Windows内核对象作业"><img src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：探索Windows内核对象作业"/></a><div class="content"><a class="title" href="/blogs/posts/windows/p88fd15a5c690.html" title="探索Windows：探索Windows内核对象作业">探索Windows：探索Windows内核对象作业</a><time datetime="2023-04-05T00:11:00.000Z" title="Created 2023-04-05 08:11:00">2023-04-05</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>Categories</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/blogs/categories/cplusplus/"><span class="card-category-list-name">cplusplus</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/blogs/categories/psychology/"><span class="card-category-list-name">psychology</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/blogs/categories/windows/"><span class="card-category-list-name">windows</span><span class="card-category-list-count">15</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>Tags</span></div><div class="card-tag-cloud"><a href="/blogs/tags/GUI/" style="font-size: 1.3em; color: #99a1ac">GUI</a> <a href="/blogs/tags/art/" style="font-size: 1.1em; color: #999">art</a> <a href="/blogs/tags/philosophy/" style="font-size: 1.1em; color: #999">philosophy</a> <a href="/blogs/tags/programming/" style="font-size: 1.5em; color: #99a9bf">programming</a> <a href="/blogs/tags/psychology/" style="font-size: 1.1em; color: #999">psychology</a> <a href="/blogs/tags/windows/" style="font-size: 1.3em; color: #99a1ac">windows</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/blogs/archives/2023/04/"><span class="card-archive-list-date">April 2023</span><span class="card-archive-list-count">9</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/blogs/archives/2023/02/"><span class="card-archive-list-date">February 2023</span><span class="card-archive-list-count">9</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>Info</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">Article :</div><div class="item-count">18</div></div><div class="webinfo-item"><div class="item-name">UV :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">PV :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">Last Push :</div><div class="item-count" id="last-push-date" data-lastPushDate="2023-08-19T11:36:16.561Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 星光探索者</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blogs/js/utils.js"></script><script src="/blogs/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>