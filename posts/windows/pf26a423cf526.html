<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>探索Windows：同步设备IO与异步设备IO | Starlight Studio</title><meta name="author" content="Starlight Explorer"><meta name="copyright" content="Starlight Explorer"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="让我们与星光探索者一起，探索Windows吧! 线程是我们最好的工具，可以用来对工作进行划分。然而当线程发出一个异步设备I&#x2F;O请求时，他被临时挂起，知道设备完成I&#x2F;O请求为止。此类挂起会损害性能。为了不让线程闲下来，我们需要让各个线程就他们正在执行的操作相互通信。Microsoft开发出了一个非常好的机制进行这类通信–I&#x2F;O完成端口(I&#x2F;O completi">
<meta property="og:type" content="article">
<meta property="og:title" content="探索Windows：同步设备IO与异步设备IO">
<meta property="og:url" content="http://ustarry.github.io/blogs/posts/windows/pf26a423cf526.html">
<meta property="og:site_name" content="Starlight Studio">
<meta property="og:description" content="让我们与星光探索者一起，探索Windows吧! 线程是我们最好的工具，可以用来对工作进行划分。然而当线程发出一个异步设备I&#x2F;O请求时，他被临时挂起，知道设备完成I&#x2F;O请求为止。此类挂起会损害性能。为了不让线程闲下来，我们需要让各个线程就他们正在执行的操作相互通信。Microsoft开发出了一个非常好的机制进行这类通信–I&#x2F;O完成端口(I&#x2F;O completi">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg">
<meta property="article:published_time" content="2023-04-22T00:57:02.000Z">
<meta property="article:modified_time" content="2023-05-01T07:58:50.631Z">
<meta property="article:author" content="Starlight Explorer">
<meta property="article:tag" content="windows">
<meta property="article:tag" content="programming">
<meta property="article:tag" content="GUI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg"><link rel="shortcut icon" href="https://ustarry.github.io/image/starlight_avator.png"><link rel="canonical" href="http://ustarry.github.io/blogs/posts/windows/pf26a423cf526.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blogs/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/blogs/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '探索Windows：同步设备IO与异步设备IO',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-01 15:58:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://ustarry.github.io/image/starlight_avator.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/blogs/archives/"><div class="headline">Articles</div><div class="length-num">19</div></a><a href="/blogs/tags/"><div class="headline">Tags</div><div class="length-num">7</div></a><a href="/blogs/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blogs/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/blogs/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/blogs/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/blogs/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s1.ax1x.com/2023/01/13/pSKERtU.jpg')"><nav id="nav"><span id="blog-info"><a href="/blogs/" title="Starlight Studio"><span class="site-name">Starlight Studio</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blogs/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/blogs/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/blogs/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/blogs/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">探索Windows：同步设备IO与异步设备IO</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-04-22T00:57:02.000Z" title="Created 2023-04-22 08:57:02">2023-04-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-05-01T07:58:50.631Z" title="Updated 2023-05-01 15:58:50">2023-05-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blogs/categories/windows/">windows</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="探索Windows：同步设备IO与异步设备IO"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>让我们与星光探索者一起，探索Windows吧!</p>
<p>线程是我们最好的工具，可以用来对工作进行划分。然而当线程发出一个异步设备I&#x2F;O请求时，他被临时挂起，知道设备完成I&#x2F;O请求为止。此类挂起会损害性能。为了不让线程闲下来，我们需要让各个线程就他们正在执行的操作相互通信。Microsoft开发出了一个非常好的机制进行这类通信–I&#x2F;O完成端口(I&#x2F;O completion port)他可以帮助我们创建高性能而且伸缩性好的应用程序。通过使用I&#x2F;O完成端口，我们可以让线程在读取设备和写入设备时不必等待设备的响应，从而显著提高吞吐量。</p>
<h2 id="打开和关闭设备"><a href="#打开和关闭设备" class="headerlink" title="打开和关闭设备"></a>打开和关闭设备</h2><p>以下为常见的可称为设备的东西，一般设备使用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a>打开，CloseHandle关闭。这些函数都返回一个标识设备的句柄，我们可以将句柄传给许多函数与设备进行通信，如调用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setcommconfig">SetCommConfig</a>设置串口的波特率，<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setmailslotinfo">SetMailslotInfo</a>在等待读取数据时，设置超时值。如果我们想知道设备的类型，可通过调用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfiletype">GetFileType函数获得</a></p>
<table>
<thead>
<tr>
<th>设备</th>
<th>常见用途</th>
</tr>
</thead>
<tbody><tr>
<td>文件</td>
<td>永久储存任何数据</td>
</tr>
<tr>
<td>目录</td>
<td>属性和文件压缩的设置</td>
</tr>
<tr>
<td>逻辑磁盘驱动器</td>
<td>格式化驱动器</td>
</tr>
<tr>
<td>物理磁盘驱动器</td>
<td>访问分区表</td>
</tr>
<tr>
<td>串口</td>
<td>通过电话线传输数据</td>
</tr>
<tr>
<td>并口</td>
<td>将数据传输到打印机</td>
</tr>
<tr>
<td>邮箱槽</td>
<td>一对多数据传输，通常是通过网络传到另一台运行Windows的机器上</td>
</tr>
<tr>
<td>命名管道</td>
<td>一对一数据传输，通常是通过网络传到另一台运行Windows的机器上</td>
</tr>
<tr>
<td>匿名管道</td>
<td>单机上一对一数据传输，绝对不会跨网络</td>
</tr>
<tr>
<td>套接字</td>
<td>报文或数据流的传输，通常是通过网络传到任何支持套接字的机器上，机器不一定要运行Windows操作系统</td>
</tr>
<tr>
<td>控制台</td>
<td>文本窗口的屏幕缓存</td>
</tr>
</tbody></table>
<p>以下是打开各种设备的函数</p>
<table>
<thead>
<tr>
<th>设备</th>
<th>用于打开设备的函数</th>
</tr>
</thead>
<tbody><tr>
<td>文件</td>
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a>(lpFileName为路径名或UNC路径名)</td>
</tr>
<tr>
<td>目录</td>
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a>(lpFileName为路径名或UNC路径名)，在调用时指定FILE_FLAG_BACKUP_SEMATICS标志，Windows允许我们打开一个目录。打开目录可以使我们更改他的属性和时间戳</td>
</tr>
<tr>
<td>逻辑磁盘驱动器</td>
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a>(lpFileName为“\.{x}:”的形式)，{x}为驱动器的盘符。打开驱动器可以使我们能格式化驱动器或检测驱动器媒介大小</td>
</tr>
<tr>
<td>物理磁盘驱动器</td>
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a>(lpFileName为“\.\PHYSICALDRIV{x}”的形式)，此时{x}为物理驱动器号，这样windows允许我们打开一个物理驱动器。如为了读写用户的第一个物理驱动器的扇区，我们可指定”.\PHYSICALDRIV0”。如果错误写入数据，会导致操作系统无法访问磁盘的内容</td>
</tr>
<tr>
<td>串口</td>
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a>(lpFileName为“COMx”)</td>
</tr>
<tr>
<td>并口</td>
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a>(lpFileName为“LPTx”)</td>
</tr>
<tr>
<td>邮件槽服务器</td>
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createmailslota">CreateMailslot</a>(lpFileName为“\\.\mailslot\mailslotname”)</td>
</tr>
<tr>
<td>邮件槽客户端</td>
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a>(lpName为 “\\servername\mailslot\mailslotname”)</td>
</tr>
<tr>
<td>命名管道服务器</td>
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea">CreateNamedFile</a>(lpName为“\.\pipe\pipename”)</td>
</tr>
<tr>
<td>命名管道客户端</td>
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a>(lpFileName为”\\servername\pipe\pipename”)</td>
</tr>
<tr>
<td>匿名管道</td>
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe">CreatePipe</a>创建服务端或客户端</td>
</tr>
<tr>
<td>套接字</td>
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-socket">socket</a>，<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept">accept</a>或<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/mswsock/nf-mswsock-acceptex">AcceptEx</a></td>
</tr>
<tr>
<td>控制台</td>
<td><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/console/createconsolescreenbuffer">CreateConsoleScreenBuffer</a>或<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/console/getstdhandle">GetStdHandle</a></td>
</tr>
</tbody></table>
<p>下面深入探讨CreateFile函数。CreateFile不仅可以创建和打开磁盘上的文件，还可以打开其他设备。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR               lpFileName,            <span class="comment">// 文件路径</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD                 dwDesiredAccess,       <span class="comment">// 访问模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD                 dwShareMode,           <span class="comment">// 共享模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpSecurityAttributes,  <span class="comment">// 安全描述符</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD                 dwCreationDisposition, <span class="comment">// 创建方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD                 dwFlagsAndAttributes,  <span class="comment">// 文件属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE                hTemplateFile</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>lpFileName为文件路径，文件路径长度不能超过MAX_PATH（260）。如果调用的是Unicode版本，可在路径名加“\\?\”前缀，我们可以超越这个限制，但此时传入的路径不再能是相对路径。更多详细请看<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">官网解释</a>。</p>
<h2 id="使用文件设备"><a href="#使用文件设备" class="headerlink" title="使用文件设备"></a>使用文件设备</h2><p>Windows的设计允许我们处理非常大的文件。Microsoft最初设计者选择了64位值表示文件大小，这意味着理论上一个文件最大可以达到16EB。在32位操作系统处理64位值不太方便，因为Windows函数要求我们将一个64为的值分成两个32位值传入。但处理这个并不难。</p>
<p>我们可调用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfilesizeex">GetFileSizeEx 函数</a>获得文件的逻辑大小，<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getcompressedfilesizea">GetCompressedFileSize函数</a>获得文件的物理大小，<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointerex">SetFilePointerEx</a>设置文件指针，调用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setendoffile">SetEndOfFile 函数</a>设置文件尾</p>
<p>对于I&#x2F;O操作时，我们可以进行同步设备IO也可以异步设备IO。下图为具体的说明</p>
<p><img src="https://learn.microsoft.com/en-us/windows/win32/fileio/images/fig2bedit.png"></p>
<h2 id="同步设备I-x2F-O"><a href="#同步设备I-x2F-O" class="headerlink" title="同步设备I&#x2F;O"></a>同步设备I&#x2F;O</h2><p>最方便最常用对设备数据进行读写的函数是<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile">ReadFile</a>，<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile">WriteFile </a>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReadFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE       hFile,                 <span class="comment">// 设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID       lpBuffer,              <span class="comment">// 读入数据缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD        nNumberOfBytesToRead,  <span class="comment">// 读取字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPDWORD      lpNumberOfBytesRead,   <span class="comment">// 成功读到的字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPOVERLAPPED lpOverlapped           <span class="comment">// 异步IO时使用</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">WriteFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE       hFile,                  <span class="comment">// 设备句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCVOID      lpBuffer,               <span class="comment">// 写入数据缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD        nNumberOfBytesToWrite,  <span class="comment">// 写入字符数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPDWORD      lpNumberOfBytesWritten, <span class="comment">// 成功写入字符数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPOVERLAPPED lpOverlapped            <span class="comment">// 异步IO时使用</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在使用同步I&#x2F;O时，我们打开设备时不能指定FILE_FLAG_OVERLAPPED标志。否则系统认为我们想要与设备执行异步I&#x2F;O。当然只有在用读模式打开设备才能读设备数据。写模式同理。</p>
<p>在CreateFile的时候，我们可以传一些标志来改变系统对设备数据进行缓存的方式。如果我们想要强制把缓存数据写入到设备，调用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers </a>。当然，只有在用写模式打开的设备才会起作用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">FlushFileBuffers</span><span class="params">(HANDLE hFile <span class="comment">/*设备句柄*/</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然而，在进行同步设备I&#x2F;O时，线程由于正在等待CreateFile返回而被阻塞，那么窗口消息将无法得到处理，该线程创建的所有窗口都会停滞在那里。我们总是看到应用程序已停止响应，多半是因为等待同步I&#x2F;O操作。因而为了创建响应性好的应用程序，我们应该尽可能执行异步操作。</p>
<p><img src="https://s1.ax1x.com/2023/05/01/p98dvWj.png"></p>
<p>不幸的是，某些Windows API没有提供任何方法来完成异步调用。我们可调用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/fileio/cancelsynchronousio-func">CancelSynchronousIo</a>来取消正在进行的同步I&#x2F;O操作。</p>
<h2 id="异步设备I-x2F-O"><a href="#异步设备I-x2F-O" class="headerlink" title="异步设备I&#x2F;O"></a>异步设备I&#x2F;O</h2><p>与计算机执行的其他操作相比，IO是最慢不可预测的操作之一。CPU从文件中或跨网络读取数据的速度，以及CPU向文件或跨网络写入数据的速度，比他执行算数运算的速度，甚至比他绘制屏幕的速度都要慢很多。但是，使用异步设备I&#x2F;O使我们能够更好的使用资源。</p>
<p>假设线程向设备发出异步I&#x2F;O请求，这个请求被传给设备驱动程序，后者负责完成实际的I&#x2F;O操作。当驱动程序在等待设备响应时，应用程序的线程并没有因为要等待I&#x2F;O请求而挂起，而是继续执行其他任务。</p>
<p>为了以异步方式访问设备，我们在CreateFile时指定 FILE_FLAG_OVERAPPED 标志，这样就可以异步方式访问设备。对于异步方式访问设备，在ReadFile和WriteFile调用时，需要传第五个参数。lpOverlapped，即我们需要初始化一个<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED 结构</a>，他的Offset，OffsetHigh,hEvent必须初始化，默认可全部初始化为0。对于不同的I&#x2F;O请求，OVERLAPPED结构要初始化不同的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_OVERLAPPED</span> &#123;</span><br><span class="line">  ULONG_PTR Internal;      <span class="comment">// 错误码</span></span><br><span class="line">  ULONG_PTR InternalHigh;  <span class="comment">// 异步I/O请求完成时，已传输的字节数</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;     <span class="comment">// 表示设备读取的开始位置相对于设备起始位置的偏移</span></span><br><span class="line">      DWORD Offset;        <span class="comment">// 低32位设备偏移量</span></span><br><span class="line">      DWORD OffsetHigh;    <span class="comment">// 高32位设备偏移量</span></span><br><span class="line">    &#125; DUMMYSTRUCTNAME;</span><br><span class="line">    PVOID Pointer;</span><br><span class="line">  &#125; DUMMYUNIONNAME;</span><br><span class="line">  HANDLE    hEvent;  <span class="comment">// 接收I/O通知时可能会用到，许多开发人员在这里保存C++对象地址</span></span><br><span class="line">&#125; OVERLAPPED, *LPOVERLAPPED;</span><br></pre></td></tr></table></figure>

<p>在执行异步I&#x2F;O时，我们应意识到，设备驱动程序不必以先进先出的方式来处理I&#x2F;O请求。不按顺序执行I&#x2F;O在某些方面上会提高性能。当我们试图添加一个异步I&#x2F;O请求时，设备驱动程序可能会选择以同步方式处理请求。如我们从文件中读取数据时，系统会检查我们想要的数据是否在系统缓存，这是就很可能发生这种情况。如果数据在缓存中，系统就不把这个I&#x2F;O请求添加到设备驱动程序队列中了，而是将高速缓存中的数据复制过来。对于NTFS文件压缩，增大文件长度，向文件追加信息，通常驱动程序以同步方式操作。</p>
<p>最重要的一点，在进行I&#x2F;O操作时，一定不能移动或释放发出I&#x2F;O请求时使用的数据缓存和OVERLAPPED结构，否则内存可能会遭到破坏。例如下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReadData</span><span class="params">(HANDLE hFile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OVERLAPPED o = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    BYTE b[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">ReadFile</span>(hFile, b, <span class="number">256</span>, <span class="literal">NULL</span>, &amp;o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了ReadData时，似乎没什么问题，但是真的吗？由于这里调用ReadFile时，如果hFile句柄是用异步方式打开的，异步I&#x2F;O请求加入队列之后，此函数就返回了。这就导致局部变量o,b都被释放，但设备驱动程序无法意识到。I&#x2F;O完成之时，设备驱动程序就去修改线程栈中内存，从而破坏数据。</p>
<p>如果在调用ReadFile或WriteFile，同步方式执行，那么这两个函数返回值为非零值；如果异步方式执行，发生了错误，这两个函数返回FALSE。调用GetLastError来检查到底发生了什么，如果GetLastError返回ERROR_IO_PENDING，那么I&#x2F;O请求已加入队列，晚些时候完成；返回ERROR_IO_PENDING以外的值，表明I&#x2F;O请求无法添加到设备驱动队列。</p>
<h2 id="取消队列中的I-x2F-O请求"><a href="#取消队列中的I-x2F-O请求" class="headerlink" title="取消队列中的I&#x2F;O请求"></a>取消队列中的I&#x2F;O请求</h2><p>我们可能想在设备驱动程序对一个已经加入队列的设备I&#x2F;O请求进行处理之前将其取消，我们可以：</p>
<ul>
<li><p>调用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/fileio/cancelio">CancelIo</a>取消给定句柄所标识的线程加入到队列中的所有I&#x2F;O请求（除非该句柄具有与之相关联的I&#x2F;O完成端口）</p>
</li>
<li><p>关闭设备句柄，不管是哪个线程添加的</p>
</li>
<li><p>当线程终止时，系统自动取消该线程发出的所有I&#x2F;O请求，但如果请求被发往的设备句柄具有与之关联的I&#x2F;O完成端口，那么它们不再被取消之列。</p>
</li>
<li><p>调用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/fileio/cancelioex-func">CancelIoEx</a>取消一个指定的I&#x2F;O请求，这个函数要求你传入lpOverlapped，也就是调用ReadFile或WriteFile时的参数。如果lpOverlapped为NULL，那么将取消指定设备所有待处理的I&#x2F;O请求</p>
</li>
</ul>
<h2 id="接收I-x2F-O请求完成通知"><a href="#接收I-x2F-O请求完成通知" class="headerlink" title="接收I&#x2F;O请求完成通知"></a>接收I&#x2F;O请求完成通知</h2><p>Windows提供了下列4种方法来接收I&#x2F;O请求已经完成的通知。</p>
<table>
<thead>
<tr>
<th>技术</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>触发设备内核对象</td>
<td>这种方法允许一个线程发出I&#x2F;O请求，另一个线程处理结果（和之前探索的线程同步时做法有相似之处）。当向一个设备同时发出多个I&#x2F;O请求时，这种方式没什么用</td>
</tr>
<tr>
<td>触发事件内核对象</td>
<td>这种方法允许一个线程发出I&#x2F;O请求，另一个线程处理。这种方法允许我们像同一个涉笔同时发出多个I&#x2F;O请求。</td>
</tr>
<tr>
<td>使用可提醒I&#x2F;O</td>
<td>发出I&#x2F;O请求的线程必须对结果进行处理。这种方法允许我们向一个设备同时发出多个请求。</td>
</tr>
<tr>
<td>使用I&#x2F;O完成端口</td>
<td>他允许一个线程发出I&#x2F;O请求，另一个线程处理结果。这种技术具有高度伸缩性和最佳灵活性。这种方法允许我们向一个设备同时发出多个请求。</td>
</tr>
</tbody></table>
<h3 id="触发设备内核对象"><a href="#触发设备内核对象" class="headerlink" title="触发设备内核对象"></a>触发设备内核对象</h3><p>虽然在执行异步I&#x2F;O请求时线程可以干其他的，但是最终线程还是与I&#x2F;O请求完毕进行同步。设备内核对象可以进行线程同步，在ReadFile和WriteFile函数将I&#x2F;O请求添加到队列之前，设备内核对象处于未触发状态，请求完成时设备内核对象处于触发状态。看下放代码例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 处省去了一些参数</span></span><br><span class="line">HANDLE hFile = <span class="built_in">CreateFile</span>(..., FILE_FLAG_OVERLAPPED, ...);</span><br><span class="line"><span class="comment">// 用FILE_FLAG_OVERLAPPED来异步方式打开设备</span></span><br><span class="line"></span><br><span class="line">BYTE bBuffer[<span class="number">66</span>];</span><br><span class="line">OVERLAPPED o = &#123;<span class="number">0</span>&#125;; <span class="comment">// 必须初始化OVERLAPPED结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件，并尝试获取错误</span></span><br><span class="line">BOOL bReadDone = <span class="built_in">ReadFile</span>(hFile, bBuffer, <span class="number">66</span>, <span class="literal">NULL</span>, &amp;o);</span><br><span class="line">DWORD dwError = <span class="built_in">GetLastError</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// !bReadDone用于判断文件是否读完，有的时候文件一下就读完了</span></span><br><span class="line"><span class="comment">// dwError==ERROR_IO_PENDING用于判断是否已添加I/O请求</span></span><br><span class="line"><span class="keyword">if</span> (!bReadDone &amp;&amp; (dwError == ERROR_IO_PENDING)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 文件没读完，但是成功添加I/O请求，将执行这里的代码</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hFile, INFINITE); <span class="comment">// 等待设备内核对象触发</span></span><br><span class="line">    bReadDone = TRUE; <span class="comment">// 标记我们已读完文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bReadDone)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 读文件读完了，解析bBuffer内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 读文件时发生了错误，可进行错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码先发出了一个异步I&#x2F;O请求，然后立即等待请求完成，异步I&#x2F;O设计来可不是为了这么用的。但是这段代码有利于各位巩固I&#x2F;O请求的相关内容。</p>
<h3 id="触发事件内核对象"><a href="#触发事件内核对象" class="headerlink" title="触发事件内核对象"></a>触发事件内核对象</h3><p>假如我们想在文件中读取10个字节并同时向文件写入10字节（读和写的位置不同），那么：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hFile = <span class="built_in">CreateFile</span>(..., FILE_FLAG_OVERLAPPED, ...);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BYTE bReadBuffer[<span class="number">10</span>];</span><br><span class="line">BYTE bWriteBuffer[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">OVERLAPPED oRead = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">OVERLAPPED oWrite = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">oWrite.Offset = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">ReadFile</span>(hFile, bReadBuffer, <span class="number">10</span>, <span class="literal">NULL</span>, &amp;oRead);</span><br><span class="line"><span class="built_in">WriteFile</span>(hFile, bWriteBuffer, _countof(bWriteBuffer), <span class="literal">NULL</span>, &amp;oWrite);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待hFile触发，hFile触发时，什么完成了：读？写？还是都完成了？</span></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hFile, INFINITE);</span><br></pre></td></tr></table></figure>

<p>我们不能通过等待设备内核对象被触发来对线程进行同步，这是因为任何一个操作完成，内核对象就被触发。我们需要一个更好的方式来同时执行多个异步I&#x2F;O操作。</p>
<p>OVERLAPPED结构的hEvent用来标识一个事件内核对象。我们必须通过CreateEvent来创建他。当一个异步I&#x2F;O请求完成时，设备驱动程序会检查OVERLAPPED结构hEvent成员是否为NULL，如果不为NULL，驱动程序调用SetEvent触发事件。在“触发事件内核对象”这个技术中，我们就不该等待设备对象触发，而是等待事件对象。</p>
<p>为了略微提高性能，我们可以使Windows在操作完成时不要触发文件对象。调用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setfilecompletionnotificationmodes">SetFileCompletionNotificationModes</a>(hFile, FILE_SKIP_SET_EVENT_ON_HANDLE)来完成我们的目的。</p>
<h3 id="可提醒I-x2F-O"><a href="#可提醒I-x2F-O" class="headerlink" title="可提醒I&#x2F;O"></a>可提醒I&#x2F;O</h3><p>最初Microsoft开发人员吹捧说，可提醒I&#x2F;O(或叫可警告I&#x2F;O，alertable I&#x2F;O)是创建高性能且伸缩性好的引用的最佳途径，后来事实证明这并不能达到Microsoft的承诺。</p>
<p>当系统创建一个线程时，会同时创建一个与线程相关的队列，即异步过程调用(asynchronous procedure call, APC)队列。当发出一个I&#x2F;O请求时，我们可以告诉设备驱动程序在调用线程的APC队列中添加一项。为了将I&#x2F;O完成通知添加到线程APC队列中，我们应该调用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfileex">ReadFileEx</a>或<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefileex">WriteFileEx </a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReadFileEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE                          hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCVOID                         lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD                           nNumberOfBytesToRead,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPOVERLAPPED                    lpOverlapped,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">WriteFileEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE                          hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCVOID                         lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD                           nNumberOfBytesToWrite,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPOVERLAPPED                    lpOverlapped,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>与ReadFile和WriteFile相似，ReadFileEx和WriteFileEx在I&#x2F;O请求发给设备驱动程序后，会立即返回。但是，这两个Ex结尾的函数没有一个指向DWORD的指针保存已传输的字节数，只有回调函数lpComplectionRoutine看得到。这个回调函数称为完成函数（complection routine）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">ComplectionRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwError,    <span class="comment">// 错误码</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwNumBytes, <span class="comment">// 传输字节数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    OVERLAPPED* po    <span class="comment">// 调用时传入  </span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当我们用ReadFileEx和WriteFileEx发送I&#x2F;O请求时，这两个函数会将回调函数的地址传给设备驱动程序。设备驱动程序完成I&#x2F;O请求时，会在发出I&#x2F;O请求时的APC队列中添加一项（并不一定按顺序添加），该项包含了完成函数地址和发I&#x2F;O请求时OVERLAPPED地址。</p>
<p>当一个可提醒I&#x2F;O完成时，设备驱动程序不会使用OVERLAPPED的hEvent成员，因此如果需要，我们可以将hEvent据为己用，这就是上方所说在hEvent存放C++对象地址原因。</p>
<p>当线程处于可提醒状态时，系统会检查他的APC队列，对队列中的每一项调用完成函数，并正确传入相关参数。我们通过调用SleepEx、WaitForSingleObjectEx、WaitForMultipleObjectEx、SignalObjectAndWait、GetQueuedCompletionStatusEx、MsgWaitForMultipleObjectEx，将本线程设为可提醒状态。当调用这些函数时，系统会首先检查APC队列，如果队列中至少有一项，那线程不会进入睡眠状态，而是取出APC队列的那一项，调用回调函数。当回调函数返回时，就取出APC队列下一项如此类推。直至队列为空，然后可提醒函数返回。如果调用可提醒函数时，APC队列是空的，则线程才会将自己挂起，进入可提醒的睡眠状态，当APC队列出现一项或正在等待的那个内核对象被触发或超时，线程被唤醒，然后函数立即返回。</p>
<p>可提醒I&#x2F;O的优劣：</p>
<ul>
<li><p>回调函数：必须创建回调函数，使代码变复杂。而且回调函数不能带额外的信息，使用不得不大量使用全局变量，幸运的是这些回调函数是被同一线程调用的，所以不需要同步。</p>
</li>
<li><p>线程问题：发出I&#x2F;O请求的线程必须同时对完成通知进行处理。可能使这个线程负载过大，而其他线程处于空闲状态却无事可做。</p>
</li>
</ul>
<p>此外，我们可以调用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc">QueueUserAPC 函数</a>来手动添加一项到APC队列中。这个函数的第一个函数需要我们传入一个APC函数的地址，必须满足下面的函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">APCFunc</span><span class="params">(ULONG_PTR)</span></span>;</span><br></pre></td></tr></table></figure>

<p>上文提到了APC队列的一些性质，我们通常调用QueueUserAPC进行搞笑的线程间通信甚至能跨过进程界限，但遗憾的是我们只能传递一个值。我们也可以用来使线程强行退出等待状态，甚至还可以使一个线程杀死自己。</p>
<h3 id="I-x2F-O完成端口"><a href="#I-x2F-O完成端口" class="headerlink" title="I&#x2F;O完成端口"></a>I&#x2F;O完成端口</h3><p>Windows设计目标是一个安全的健壮的操作系统。回顾历史，我们可以采用以下两种模型之一构架一个服务应用程序。</p>
<ul>
<li><p>串行模式（serial model）：一个线程等待一个用户（通常是通过网络）发出请求，当线程到达时，线程被唤醒并对客户请求进行处理</p>
</li>
<li><p>并发模式（concurrent model）：一个线程等待一个客户请求，并创建一个新线程来处理请求。当新线程正在处理客户请求的时候，原来的线程进入下一次循环并等待另一个客户请求。当处理客户请求的线程完成整个处理过程时，该线程终止。</p>
</li>
</ul>
<p>串行模型的问题在于他不能很好同时处理多个请求，因而并发模式极其受欢迎。Microsoft意识到并行模式下需要打造Windows一个出色的服务器环境，它设计出了I&#x2F;O完成端口对象。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://ustarry.github.io/blogs">Starlight Explorer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://ustarry.github.io/blogs/posts/windows/pf26a423cf526.html">http://ustarry.github.io/blogs/posts/windows/pf26a423cf526.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blogs/tags/windows/">windows</a><a class="post-meta__tags" href="/blogs/tags/programming/">programming</a><a class="post-meta__tags" href="/blogs/tags/GUI/">GUI</a></div><div class="post_share"><div class="social-share" data-image="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blogs/posts/windows/pd2a35742938d.html" title="探索Windows：Windows内存结构体系"><img class="cover" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="onerror=null;src='/blogs/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">探索Windows：Windows内存结构体系</div></div></a></div><div class="next-post pull-right"><a href="/blogs/posts/windows/p8acaa0787154.html" title="探索Windows：线程同步"><img class="cover" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="onerror=null;src='/blogs/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">探索Windows：线程同步</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/blogs/posts/windows/p94939f4d9192.html" title="探索Windows：创建自己的窗口和探索消息机制"><img class="cover" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-12</div><div class="title">探索Windows：创建自己的窗口和探索消息机制</div></div></a></div><div><a href="/blogs/posts/windows/p71040f0575db.html" title="探索Windows：使用计时器和菜单，图标，光标等资源文件"><img class="cover" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-12</div><div class="title">探索Windows：使用计时器和菜单，图标，光标等资源文件</div></div></a></div><div><a href="/blogs/posts/windows/p8cad54b0e5bf.html" title="探索Windows：处理常用的消息和自定义消息"><img class="cover" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-12</div><div class="title">探索Windows：处理常用的消息和自定义消息</div></div></a></div><div><a href="/blogs/posts/windows/pd3e66887a323.html" title="探索Windows：常用基本数据类型和字符编码"><img class="cover" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-12</div><div class="title">探索Windows：常用基本数据类型和字符编码</div></div></a></div><div><a href="/blogs/posts/windows/p88fd15a5c690.html" title="探索Windows：探索Windows内核对象作业"><img class="cover" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-05</div><div class="title">探索Windows：探索Windows内核对象作业</div></div></a></div><div><a href="/blogs/posts/windows/pc190bf13eb0d.html" title="探索Windows：Windows错误处理和字符串处理"><img class="cover" src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-04</div><div class="title">探索Windows：Windows错误处理和字符串处理</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div><div id="comment-switch"><span class="first-comment">Livere</span><span class="switch-btn"></span><span class="second-comment"> Gitalk</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODAzNy8zNDUwMA=="></div></div><div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://ustarry.github.io/image/starlight_avator.png" onerror="this.onerror=null;this.src='/blogs/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Starlight Explorer</div><div class="author-info__description">Starlight Studio</div></div><div class="card-info-data site-data is-center"><a href="/blogs/archives/"><div class="headline">Articles</div><div class="length-num">19</div></a><a href="/blogs/tags/"><div class="headline">Tags</div><div class="length-num">7</div></a><a href="/blogs/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD%E8%AE%BE%E5%A4%87"><span class="toc-number">1.</span> <span class="toc-text">打开和关闭设备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E8%AE%BE%E5%A4%87"><span class="toc-number">2.</span> <span class="toc-text">使用文件设备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E8%AE%BE%E5%A4%87I-x2F-O"><span class="toc-number">3.</span> <span class="toc-text">同步设备I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%AE%BE%E5%A4%87I-x2F-O"><span class="toc-number">4.</span> <span class="toc-text">异步设备I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84I-x2F-O%E8%AF%B7%E6%B1%82"><span class="toc-number">5.</span> <span class="toc-text">取消队列中的I&#x2F;O请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6I-x2F-O%E8%AF%B7%E6%B1%82%E5%AE%8C%E6%88%90%E9%80%9A%E7%9F%A5"><span class="toc-number">6.</span> <span class="toc-text">接收I&#x2F;O请求完成通知</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E8%AE%BE%E5%A4%87%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.1.</span> <span class="toc-text">触发设备内核对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.2.</span> <span class="toc-text">触发事件内核对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%8F%90%E9%86%92I-x2F-O"><span class="toc-number">6.3.</span> <span class="toc-text">可提醒I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-x2F-O%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3"><span class="toc-number">6.4.</span> <span class="toc-text">I&#x2F;O完成端口</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blogs/posts/windows/pd2a35742938d.html" title="探索Windows：Windows内存结构体系"><img src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：Windows内存结构体系"/></a><div class="content"><a class="title" href="/blogs/posts/windows/pd2a35742938d.html" title="探索Windows：Windows内存结构体系">探索Windows：Windows内存结构体系</a><time datetime="2023-04-22T00:57:05.000Z" title="Created 2023-04-22 08:57:05">2023-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blogs/posts/windows/pf26a423cf526.html" title="探索Windows：同步设备IO与异步设备IO"><img src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：同步设备IO与异步设备IO"/></a><div class="content"><a class="title" href="/blogs/posts/windows/pf26a423cf526.html" title="探索Windows：同步设备IO与异步设备IO">探索Windows：同步设备IO与异步设备IO</a><time datetime="2023-04-22T00:57:02.000Z" title="Created 2023-04-22 08:57:02">2023-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blogs/posts/windows/p8acaa0787154.html" title="探索Windows：线程同步"><img src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：线程同步"/></a><div class="content"><a class="title" href="/blogs/posts/windows/p8acaa0787154.html" title="探索Windows：线程同步">探索Windows：线程同步</a><time datetime="2023-04-22T00:57:00.000Z" title="Created 2023-04-22 08:57:00">2023-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blogs/posts/windows/pbdbc280bfc62.html" title="探索Windows：探索Windows内核对象线程"><img src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：探索Windows内核对象线程"/></a><div class="content"><a class="title" href="/blogs/posts/windows/pbdbc280bfc62.html" title="探索Windows：探索Windows内核对象线程">探索Windows：探索Windows内核对象线程</a><time datetime="2023-04-22T00:12:00.000Z" title="Created 2023-04-22 08:12:00">2023-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blogs/posts/windows/p88fd15a5c690.html" title="探索Windows：探索Windows内核对象作业"><img src="https://s1.ax1x.com/2023/01/13/pSKERtU.jpg" onerror="this.onerror=null;this.src='/blogs/img/404.jpg'" alt="探索Windows：探索Windows内核对象作业"/></a><div class="content"><a class="title" href="/blogs/posts/windows/p88fd15a5c690.html" title="探索Windows：探索Windows内核对象作业">探索Windows：探索Windows内核对象作业</a><time datetime="2023-04-05T00:11:00.000Z" title="Created 2023-04-05 08:11:00">2023-04-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By Starlight Explorer</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blogs/js/utils.js"></script><script src="/blogs/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !true) {
  if (true) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>